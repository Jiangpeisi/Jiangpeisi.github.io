<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我在看着你</title>
  
  <subtitle>by heart</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-23T06:15:59.660Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>镜子</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>shell脚本学习之数组</title>
    <link href="http://yoursite.com/2019/03/23/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2019/03/23/shell脚本学习之数组/</id>
    <published>2019-03-23T14:45:56.000Z</published>
    <updated>2019-03-23T06:15:59.660Z</updated>
    
    <content type="html"><![CDATA[<p><strong>数组定义</strong><br>方法一：</p><pre><code>array_name=(value0 value1 value2 value3)</code></pre><p>方法二：</p><pre><code>array_name[0]=value0array_name[1]=value1array_name[2]=value2</code></pre><p>方法三：</p><pre><code>array_name=(            value0            value1            value2            value3)</code></pre><p><strong>数组的引用</strong><br>1.<code>${array_name[n]}</code>  获取数组第n+1个元素<br>2.<code>${array_name[@]}</code>  获取数组所有的元素<br>3.<code>${array_name[*]}</code>  获取数组所有的元素<br>4.<code>${#array_name[n]}</code>  获取数组第n+1个元素的长度<br>5.<code>${#array_name[@]}</code>  获取数组元素个数<br>6.<code>unset array[n]</code>   删除第n+1个元素<br>7.<code>unset array</code>   删除数组<br><strong>数组的替换</strong><br>方法一：不改变原数组<code>{arrary[@]/old/new}</code></p><pre><code>[root@jiangpeisi shell]# echo ${array1[@]/php/lua}lua c++ python java[root@jiangpeisi shell]# array3=${array1[@]/php/lua}[root@jiangpeisi shell]# echo ${array3[@]}lua c++ python java</code></pre><p>方法二：改变原数组<code>array=（[1]=new1 [2]=new2 [3]=new3）</code>   </p><pre><code>[root@jiangpeisi shell]# array1=([1]=lua [2]=php)[root@jiangpeisi shell]# echo ${array1[@]}lua php</code></pre><p><strong>数组遍历</strong><br>方法一：通过元素遍历</p><pre><code>array1=(php c++ python java)for var in ${array1[@]};do    echo $vardone[root@jiangpeisi shell]# sh array.sh phpc++pythonjava</code></pre><p>方法二：通过下标遍历</p><pre><code>array1=(php c++ python java)for i in &quot;${!array1[@]}&quot;;do    printf &quot;${array1[$i]}\n&quot;done[root@jiangpeisi shell]# sh array.sh phpc++pythonjava</code></pre><p>方法三：使用while循环遍历数组</p><pre><code>array1=(php c++ python java)i=0while [ $i -lt ${#array1[@]} ]do    echo ${array1[$i]}    let i++done[root@jiangpeisi shell]# sh array.sh phpc++pythonJava</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;数组定义&lt;/strong&gt;&lt;br&gt;方法一：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;array_name=(value0 value1 value2 value3)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;方法二：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;array_name[0]=v
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>hexo渲染文章失败</title>
    <link href="http://yoursite.com/2019/03/23/hexo%E6%B8%B2%E6%9F%93%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/03/23/hexo渲染问题/</id>
    <published>2019-03-23T14:04:56.000Z</published>
    <updated>2019-03-23T06:39:40.737Z</updated>
    
    <content type="html"><![CDATA[<p><strong>简述</strong><br>今天写了一个新的笔记打算上传的博客上，结果在渲染博文的时候出现了一个错误。一个神奇的现象就是我如果删除这篇新的博文时，就可以渲染成功，添加新的博文就渲染失败。后来看了官网的文章才知道，是因为我的新博文内出现了一些无法识别的字符。例如不可见的零宽度字符、预保留字符。出现这种情况有两种可能性，一种是你的新页面/帖子，另一种是_config.yml。显然我的属于前者。</p><hr><p><strong>错误代码</strong></p><pre><code>jiang@jiang-PC MINGW64 /F/Myblog                                                                                           $ hexo g                                                                                                                   INFO  Start processing                                                                                                     FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html                    Template render error: (unknown path)                                                                                        Error: expected end of comment, got end of file                                                                              at Object._prettifyError (F:\Myblog\node_modules\nunjucks\src\lib.js:36:11)                                                at Template.render (F:\Myblog\node_modules\nunjucks\src\environment.js:526:21)                                             at Environment.renderString (F:\Myblog\node_modules\nunjucks\src\environment.js:364:17)                                    at Promise.fromCallback.cb (F:\Myblog\node_modules\hexo\lib\extend\tag.js:62:48)                                           at tryCatcher (F:\Myblog\node_modules\bluebird\js\release\util.js:16:23)                                                   at Function.Promise.fromNode.Promise.fromCallback (F:\Myblog\node_modules\bluebird\js\release\promise.js:180:30)           at Tag.render (F:\Myblog\node_modules\hexo\lib\extend\tag.js:62:18)                                                        at Object.onRenderEnd (F:\Myblog\node_modules\hexo\lib\hexo\post.js:282:20)                                                at Promise.then.then.result (F:\Myblog\node_modules\hexo\lib\hexo\render.js:65:19)                                         at tryCatcher (F:\Myblog\node_modules\bluebird\js\release\util.js:16:23)                                                   at Promise._settlePromiseFromHandler (F:\Myblog\node_modules\bluebird\js\release\promise.js:512:31)                        at Promise._settlePromise (F:\Myblog\node_modules\bluebird\js\release\promise.js:569:18)                                   at Promise._settlePromise0 (F:\Myblog\node_modules\bluebird\js\release\promise.js:614:10)                                  at Promise._settlePromises (F:\Myblog\node_modules\bluebird\js\release\promise.js:694:18)                                  at _drainQueueStep (F:\Myblog\node_modules\bluebird\js\release\async.js:138:12)                                            at _drainQueue (F:\Myblog\node_modules\bluebird\js\release\async.js:131:9)                                                 at Async._drainQueues (F:\Myblog\node_modules\bluebird\js\release\async.js:147:5)                                          at Immediate.Async.drainQueues (F:\Myblog\node_modules\bluebird\js\release\async.js:17:14)                                 at runCallback (timers.js:705:18)                                                                                          at tryOnImmediate (timers.js:676:5)                                                                                        at processImmediate (timers.js:658:5)     </code></pre><p><strong>问题原因</strong><br><img src="http://static.zybuluo.com/jiangpeisi/2c8thylc5u8rgj6cbznj580r/image_1d6kkaaka1ue91btk1v0f1npl1skbm.png" alt="image_1d6kkaaka1ue91btk1v0f1npl1skbm.png-23.5kB"></p><p><strong>解决办法</strong></p><p><img src="http://static.zybuluo.com/jiangpeisi/as1qheh918m50h356rbcs8e7/image_1d6kkbo3s128l1o632s0bml19ou1j.png" alt="image_1d6kkbo3s128l1o632s0bml19ou1j.png-17.4kB"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;简述&lt;/strong&gt;&lt;br&gt;今天写了一个新的笔记打算上传的博客上，结果在渲染博文的时候出现了一个错误。一个神奇的现象就是我如果删除这篇新的博文时，就可以渲染成功，添加新的博文就渲染失败。后来看了官网的文章才知道，是因为我的新博文内出现了一些无法识别的字符。
      
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习之正则表达式</title>
    <link href="http://yoursite.com/2019/03/22/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/03/22/shell脚本学习之正则表达式/</id>
    <published>2019-03-22T14:45:56.000Z</published>
    <updated>2019-03-22T03:25:09.084Z</updated>
    
    <content type="html"><![CDATA[<p><strong>简述</strong><br>正则表达式是对字符串（包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”））操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。正则表达式是一种文本模式，模式描述在搜索文本时要匹配的一个或多个字符串。</p><p><strong>正则表达式字符</strong></p><pre><code>\：将下一个字符标记符、或一个向后引用、或一个八进制转义符。例如，“\\n”匹配\n。“\n”匹配换行符。序列“\\”匹配“\”而“\(”则匹配“(”。即相当于多种编程语言中都有的“转义字符”的概念。^：匹配输入字行首。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。$：匹配输入行尾。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。*：匹配前面的子表达式任意次。例如，zo*能匹配“z”，也能匹配“zo”以及“zoo”。*等价于{0,}。+：匹配前面的子表达式一次或多次(大于等于1次）。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。?：匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”。?等价于{0,1}。{n}：n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。{n,}：n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。{n,m}：m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o为一组，后三个o为一组。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。?：当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少地匹配所搜索的字符串，而默认的贪婪模式则尽可能多地匹配所搜索的字符串。例如，对于字符串“oooo”，“o+”将尽可能多地匹配“o”，得到结果[“oooo”]，而“o+?”将尽可能少地匹配“o”，得到结果 [&apos;o&apos;, &apos;o&apos;, &apos;o&apos;, &apos;o&apos;].：匹配除“\n”和&quot;\r&quot;之外的任何单个字符。要匹配包括“\n”和&quot;\r&quot;在内的任何字符，请使用像“[\s\S]”的模式。(pattern)：匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\(”或“\)”。(?:pattern)：非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分时很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。(?=pattern)：非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。(?!pattern)：非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。(?&lt;=pattern)：非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。(?&lt;!patte_n)：非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。x|y：匹配x或y。例如，“z|food”能匹配“z”或“food”(此处请谨慎)。“[z|f]ood”则匹配“zood”或“food”。[xyz]：字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。[^xyz]：负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”任一字符。[a-z]：字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。注意:只有连字符在字符组内部时,并且出现在两个字符之间时,才能表示字符的范围; 如果出字符组的开头,则只能表示连字符本身[^a-z]：负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。\b：匹配一个单词的边界，也就是指单词和空格间的位置（即正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置，这里的\b就是匹配位置的）。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”；“\b1_”可以匹配“1_23”中的“1_”，但不能匹配“21_3”中的“1_”。\B：匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。\cx：匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。\d：匹配一个数字字符。等价于[0-9]。grep 要加上-P，perl正则支持\D：匹配一个非数字字符。等价于[^0-9]。grep要加上-P，perl正则支持\f：匹配一个换页符。等价于\x0c和\cL。\n：匹配一个换行符。等价于\x0a和\cJ。\r：匹配一个回车符。等价于\x0d和\cM。\s：匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。\S：匹配任何可见字符。等价于[^ \f\n\r\t\v]。\t：匹配一个制表符。等价于\x09和\cI。\v：匹配一个垂直制表符。等价于\x0b和\cK。\w：匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的&quot;单词&quot;字符使用Unicode字符集。\W：匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。</code></pre><p><strong>实例</strong><br>匹配手机号码：<code>^1[3|4|5|7|8][0-9]{9}$</code><br>匹配IP地址：<code>[0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3}</code>   不准确<br>匹配电子邮箱：<code>/^[a-z\d]+(\.[a-z\d]+)*@([\da-z](-[\da-z])?)+(\.{1,2}[a-z]+)+$/</code><br>匹配URL：<code>/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/</code><br>匹配6-18位的密码：<code>/^[a-z0-9_-]{6,18}$/</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;简述&lt;/strong&gt;&lt;br&gt;正则表达式是对字符串（包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”））操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习之四剑客grep</title>
    <link href="http://yoursite.com/2019/03/22/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9B%9B%E5%89%91%E5%AE%A2grep/"/>
    <id>http://yoursite.com/2019/03/22/shell脚本学习之四剑客grep/</id>
    <published>2019-03-22T14:45:56.000Z</published>
    <updated>2019-03-22T03:43:06.363Z</updated>
    
    <content type="html"><![CDATA[<p><strong>简述</strong><br>grep是一种强大的文本搜索工具，与正则表达式配合搜索文本，并把匹配的行打印出来。</p><hr><p><strong>语句格式：</strong></p><pre><code>grep -options ‘word’ filename</code></pre><p><strong>常用参数：</strong><br>-a：以文本文件方式搜索<br>-c：计算找到的符合行的次数<br>-i：忽略大小写<br>-n：顺便输出行号<br>-v：反向选择，输出不包含匹配的所有行<br>-h：查询多文件时不现实文件名<br>-l：查询多文件时，只输出包含匹配字符的文件名<br>-s：不显示不存在或无匹配文本的错误信息<br>-E：使用egrep扩展匹配模式<br>– color：指定匹配输出字符的颜色<br><strong>正则表达式</strong><br><a href="https://jiangpeisi.github.io/2019/03/22/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" target="_blank" rel="noopener">点这里</a><br><strong>实例</strong></p><pre><code>[root@jiangpeisi shell]# cat a.txt | grep &apos;^m.*l$&apos; mysql[root@jiangpeisi shell]# cat a.txt | grep -E &quot;\&lt;([0-9]{1,3}\.){3}([0-9]{1,3})\&gt;&quot; 192.168.32.1[root@jiangpeisi shell]# cat a.txt | grep -c  &apos;^m.*l$&apos; 1[root@jiangpeisi shell]# cat a.txt | grep  -n &apos;^m.*l$&apos; 2:mysql[root@jiangpeisi shell]# cat a.txt | grep  -i -n  &apos;^M.*l$&apos; 2:mysql[root@jiangpeisi shell]# netstat -ntlp | grep namedtcp        0      0 172.17.0.1:53           0.0.0.0:*               LISTEN      3585/named          tcp        0      0 172.16.30.80:53         0.0.0.0:*               LISTEN      3585/named          tcp        0      0 127.0.0.1:53            0.0.0.0:*               LISTEN      3585/named          tcp        0      0 127.0.0.1:953           0.0.0.0:*               LISTEN      3585/named  </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;简述&lt;/strong&gt;&lt;br&gt;grep是一种强大的文本搜索工具，与正则表达式配合搜索文本，并把匹配的行打印出来。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;语句格式：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grep -options ‘word’ f
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习之四剑客awk</title>
    <link href="http://yoursite.com/2019/03/21/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9B%9B%E5%89%91%E5%AE%A2awk/"/>
    <id>http://yoursite.com/2019/03/21/shell脚本学习之四剑客awk/</id>
    <published>2019-03-21T14:45:56.000Z</published>
    <updated>2019-03-21T10:41:47.151Z</updated>
    
    <content type="html"><![CDATA[<p><strong>简述</strong><br>awk本身就是一种编程语言，它支持条件判断、循环、数组遍历等功能。我们可以使用它来对文本进行分析和处理。与sed相比，sed是逐行处理文本内数据，awk也是，不过awk又在此基础上实现对每一行每一列的操作。专业的角度来讲awk是一个报告生成器，因为awk可以对行和列进行操作，所以在awk命令下，一个文本就像是一个表格。默认列之间的分隔符是空格，行之间分隔符是\n，可以通过-F或者-v FS:指定分割符。</p><hr><p><strong>命令格式</strong></p><pre><code>awk &apos;{pattern + action}&apos; {filenames}</code></pre><p><strong>1.基本语法参数</strong><br>1.单引号‘’：为了和shell语法分开，防止混淆<br>2.大括号{}：用来表示一组命令<br>3.pattern：一个过滤器，表示匹配pattern的条件的行才可以执行action<br>4.pattern可以是以下任意一种<br>    -正则表达式：使用通配符匹配<br>    -关系表达式：使用关系运算符<br>    -模式匹配表达式：使用运算符~或者！~匹配<br>5.action：处理动作，一系列命令，常见的动作为print</p><p>实例：抓取IP地址</p><pre><code>[root@jiangpeisi ~]# ifconfig eth0 |awk  &apos;/inet/{print $2}&apos;172.16.30.80[root@jiangpeisi ~]# ifconfig eth0 | grep inet | awk &apos;{print $2}&apos;172.16.30.80[root@jiangpeisi ~]# ip addr | awk &apos;/eth0/&apos; | awk &apos;/inet/{print $2}&apos;172.16.30.80/18</code></pre><p><strong>2.内置参数</strong><br>FS：分隔符，默认是空格作为分隔符<br>OFS：输出行分隔符<br>NR：当前行数，从1开始<br>NF：当前行的字段（列）个数<br>$0：当前记录<br><code>$1~$n</code>：当前记录的第n个字段</p><p>实例：输出字段个数</p><pre><code>[root@jiangpeisi ~]# whoroot     pts/1        2019-03-21 11:14 (49.70.207.182)[root@jiangpeisi ~]# who | awk &apos;{print NF}&apos;5</code></pre><p>实例：打印奇数行的行号和第一列内容</p><pre><code>[root@jiangpeisi ~]# awk -F: &apos;NR%2==0{next}{print NR,$1}&apos; /etc/passwd1 root3 daemon5 lp7 shutdown9 mail11 games13 nobody15 systemd-network17 polkitd19 sshd21 chrony23 nscd25 admin27 dockerroot-latest29 test131 ftpuser133 dhcpd35 saslauth</code></pre><p><strong>3.内置函数</strong><br>1.gsub（r，s）：在$0中用s代替r<br>2.index（s，t）：返回s中t的第一个位置<br>3.length（s）：返回s的长度<br>4.match（s，r）：s是否匹配r<br>5.split（s，a，fs）：在fs上讲s分成序列a<br>6.substr（s，p）：返回s从p开始的子串</p><p>实例：输出字段长度</p><pre><code>[root@jiangpeisi ~]# whoroot     pts/1        2019-03-21 11:14 (49.70.207.182)[root@jiangpeisi ~]# who | awk &apos;{print length($2)}&apos;5</code></pre><p><strong>4.流程控制语句</strong><br>1.if（condition）{}else{}<br>2.while（condition）{}<br>3.for（init；condition；step）{}<br>4.Break/contitnue<br>实例：比较大小</p><pre><code>[root@jiangpeisi ~]# echo 2 3 |awk &apos;{if($1&gt;$2){print $1}else{print $2}}&apos;3[root@jiangpeisi ~]# echo 3 2 |awk &apos;{if($1&gt;$2){print $1}else{print $2}}&apos;3</code></pre><p><strong>补充</strong><br>使用awk可以对一个文件写一个脚本，格式：</p><pre><code>awk &apos;BEGIN{ commands } pattern{ commands } END{ commands }&apos; file </code></pre><p>执行顺序：<br>第一步： 执行BEGIN { commands } pattern 语句块中的语句，在对文件操作前执行<br>第二步：从文件或标准输入中读取一行，然后执行pattern{ commands }语句块。它逐行扫描文件，从第一行到最后一行重复这个过程，直到全部文件都被读取完毕。<br>第三步：当读至输入流末尾时，执行END { commands }语句块</p><p>实例：计算用户数量</p><pre><code>[root@jiangpeisi ~]# awk &apos;BEGIN {count=0;print &quot;[start] user count is &quot;,count} {;;count++} END{print &quot;[end] user count is &quot;,count}&apos; /etc/passwd[start] user count is  0[end] user count is  36</code></pre><p>实例：计算文件夹大小</p><pre><code>[root@jiangpeisi ~]# ls -lF /etc/ | awk &apos;BEGIN {sum=0}{sum+=$5}END{print &quot;The size of this dir is&quot;,sum/1024/1024,&quot;M&quot;}&apos;The size of this dir is 1.30004 M</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;简述&lt;/strong&gt;&lt;br&gt;awk本身就是一种编程语言，它支持条件判断、循环、数组遍历等功能。我们可以使用它来对文本进行分析和处理。与sed相比，sed是逐行处理文本内数据，awk也是，不过awk又在此基础上实现对每一行每一列的操作。专业的角度来讲awk是
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习之四剑客sed</title>
    <link href="http://yoursite.com/2019/03/21/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9B%9B%E5%89%91%E5%AE%A2sed/"/>
    <id>http://yoursite.com/2019/03/21/shell脚本学习之四剑客sed/</id>
    <published>2019-03-21T14:45:56.000Z</published>
    <updated>2019-03-21T06:25:04.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sed简介"><a href="#sed简介" class="headerlink" title="sed简介"></a>sed简介</h1><p>sed是一个非交互式文本编辑器，它可以对文本文件和标准输入进行编辑，标志输入可以来自键盘输入、文本重定向、字符串、变量、甚至来自于管道符。逐行处理内容，一次只处理一行内容。</p><h1 id="sed工作流程"><a href="#sed工作流程" class="headerlink" title="sed工作流程"></a>sed工作流程</h1><p>1、读新的一行到缓存空间（pattern space）<br>2、从指定的操作指令中依次取出指令执行，判断是否匹配缓存空间内容<br>3、如果不匹配则忽略后续的编辑命令，回到第2步继续取出下一条指令<br>4、如果匹配，则针对缓存的行执行后续的编辑命令；完成后，回到第2步继续取出下一条指令<br>5、当所有指令都应用之后，输出缓存行的内容；回到第1步继续读入下一行内容<br>6、当所有行都处理完之后，结束；<br>sed操作的所有数据都是pattern space缓存空间内的数据，原文件并没有发生该表。如果想保留sed操作后的数据，可以使用重定向符输出到新的文件中。或者使用- i参数更改原文件。</p><h1 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h1><h2 id="命令格式："><a href="#命令格式：" class="headerlink" title="命令格式："></a>命令格式：</h2><pre><code>sed  [options]  [commands]  filename;</code></pre><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><p>x：指定行号<br>x,y：指定从x行到y行<br>/pattern/：指定包含模式的行<br>/pattern/,n：指定包含模式的行到第n行<br>p：打印匹配行<br>n：读取下一个输入行，用下一个命令处理新的行<br>a：在匹配行后面新的一行追加内容<br>i：在匹配行前面新的一行插入内容<br>d：删除匹配的行<br>c：用指定内容替代匹配的内容，一般操作多行<br>s：用指定内容替代匹配的内容，一般替代具体单词</p><h2 id="常用参数实例"><a href="#常用参数实例" class="headerlink" title="常用参数实例"></a>常用参数实例</h2><p><strong>原文本</strong></p><pre><code>[root@jiangpeisi shell]# cat a.txt mysqlappachenginxredismemachedphppython</code></pre><p><strong>1.打印指定行内容</strong></p><pre><code>[root@jiangpeisi shell]# sed -n &apos;1,3p&apos; a.txt mysqlappachenginx</code></pre><p><strong>2.删除指定行</strong></p><pre><code>[root@jiangpeisi shell]# sed &apos;/php/,$d&apos; a.txt mysqlappachenginxredismemached</code></pre><p><strong>3.在指定行前后添加内容</strong></p><pre><code>[root@jiangpeisi shell]# sed &apos;$a java&apos; a.txt mysqlappachenginxredismemachedphppythonJava[root@jiangpeisi shell]# sed &apos;$i java&apos; a.txt mysqlappachenginxredismemachedphpjavaPython</code></pre><p><strong>4.替换指定内容</strong></p><pre><code>[root@jiangpeisi shell]# sed &apos;2,3c java&apos; a.txt mysqljavaredismemachedphppython</code></pre><p>[root@jiangpeisi shell]# sed ‘s/php/java/‘ a.txt </p><pre><code>mysqlappachenginxredismemachedjavapython</code></pre><p><strong>5.多个命令组合 使用；或者-e参数</strong></p><pre><code>[root@jiangpeisi shell]# sed -e &apos;$a java&apos; -e &apos;s/php/java/&apos; a.txt mysqlappachenginxredismemachedjavapythonjava[root@jiangpeisi shell]# sed &apos;/mysql/d ; s/php/java/&apos;  a.txt appachenginxredismemachedjavapython</code></pre><h2 id="进阶参数"><a href="#进阶参数" class="headerlink" title="进阶参数"></a>进阶参数</h2><p>N：将当前读入行的下一行读取到当前的模式空间<br><img src="http://static.zybuluo.com/jiangpeisi/kwppvxf1du6mj1c0w55iuulz/image_1d6fdc4i41r4rujbos01old5h23j.png" alt="image_1d6fdc4i41r4rujbos01old5h23j.png-2.5kB"><br>h：将模式缓存区的文本复制到保持缓冲区<br><img src="http://static.zybuluo.com/jiangpeisi/c0yf7m2q8chbvbixsh5qxii4/image_1d6fdcepm13br129vmfuh7615sm40.png" alt="image_1d6fdcepm13br129vmfuh7615sm40.png-3.4kB"><br>H：将模式缓冲区的文本追加到保持缓冲区<br><img src="http://static.zybuluo.com/jiangpeisi/hrya3jucdxeg5ayw8luxhiri/image_1d6fdcn2u1iiv3gllj7mats94d.png" alt="image_1d6fdcn2u1iiv3gllj7mats94d.png-3.4kB"><br>x：互换模式缓冲区和保持缓冲区的内容<br><img src="http://static.zybuluo.com/jiangpeisi/qu8oykohe71m6an3sipqvdms/image_1d6fdfb8cbj61u0a18rs1cfi5b470.png" alt="image_1d6fdfb8cbj61u0a18rs1cfi5b470.png-2.8kB"><br>g：将保持缓冲区的内容复制到模式缓冲区<br><img src="http://static.zybuluo.com/jiangpeisi/hlk49s1ai3igt6tviirme4xi/image_1d6fdfjoi1u9qgts1hqp4701doo7d.png" alt="image_1d6fdfjoi1u9qgts1hqp4701doo7d.png-3.3kB"><br>G：将保持缓冲区的内容追加到模式缓冲区<br><img src="http://static.zybuluo.com/jiangpeisi/479c4zr05uucdwqfijkfm2uj/image_1d6fdfom84pco1qehi1hvk1ua77q.png" alt="image_1d6fdfom84pco1qehi1hvk1ua77q.png-3.5kB"><br>两个缓冲空间pattern space与hold space。pattern space是一个临时缓冲区，用于保存当前读入的行信息，每处理完一行就会清除缓存内的信息，读取下一行。hold space 同样也是一个临时缓冲去，在处理行信息时，可以与pattern space之间进行互相拷贝。</p><h2 id="进阶参数实例"><a href="#进阶参数实例" class="headerlink" title="进阶参数实例"></a>进阶参数实例</h2><p><strong>1.在每一行后添加一个空行</strong></p><pre><code>[root@jiangpeisi shell]# sed &apos;/^ $/p;G&apos; a.txt mysqlappachenginxredismemachedphppython</code></pre><p><strong>2.将指定行的后一行与指定行合并为一行</strong></p><pre><code>[root@jiangpeisi shell]# sed  &apos;3N;s/\n/ /&apos; a.txt mysqlappachenginx redismemachedphppython</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sed简介&quot;&gt;&lt;a href=&quot;#sed简介&quot; class=&quot;headerlink&quot; title=&quot;sed简介&quot;&gt;&lt;/a&gt;sed简介&lt;/h1&gt;&lt;p&gt;sed是一个非交互式文本编辑器，它可以对文本文件和标准输入进行编辑，标志输入可以来自键盘输入、文本重定向、字符串、变
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习之函数</title>
    <link href="http://yoursite.com/2019/03/20/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/03/20/shell脚本学习之函数/</id>
    <published>2019-03-20T14:45:56.000Z</published>
    <updated>2019-03-20T14:55:31.064Z</updated>
    
    <content type="html"><![CDATA[<p><strong>函数定义格式：</strong></p><pre><code>function name（）{command}</code></pre><p><strong>调用：</strong></p><pre><code>name argv1 argv2  </code></pre><p><strong>实例：安装Apache函数</strong></p><pre><code>#!/bin/bash#Auto install appache#By Auther jiangpeisiURL=http://mirrors.shu.edu.cn/apache//httpdFILE=httpd-2.4.38.tar.gzFILES_DIR=httpd-2.4.38PREFIX=/usr/local/apachefunction Apache_install(){if [ $1 -eq 1 ];then        yum install  openssl openssl-devel zlib zlib-devel gcc-c++ pcre pcre-devel -y &amp;&amp; cd /usr/local/src/ &amp;&amp; wget $URL/$FILE &amp;&amp; tar -xvf $FILE &amp;&amp; cd $FILES_DIR &amp;&amp; ./configure --prefix=$PREFIX  if [ $? -eq 0 ];then    make&amp;&amp;make install    echo &quot;The $FILES_DIR Server Install Sucess!&quot;    . /usr/local/apache/bin/httpd  else    echo &quot;The $FILES_DIR Server Install Fail!&quot;  fifi}Apache_install 1</code></pre><p><strong>测试：</strong></p><p><img src="http://static.zybuluo.com/jiangpeisi/369raax3bt02mth1v541lp5z/image_1d6dpfhvfkkohu3fk21gg8185116.png" alt="image_1d6dpfhvfkkohu3fk21gg8185116.png-23.1kB"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;函数定义格式：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function name（）
{
command
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;调用：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name argv1 argv2 
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习之选择语句</title>
    <link href="http://yoursite.com/2019/03/20/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5/"/>
    <id>http://yoursite.com/2019/03/20/shell脚本学习之选择语句/</id>
    <published>2019-03-20T14:45:56.000Z</published>
    <updated>2019-03-20T14:50:35.384Z</updated>
    
    <content type="html"><![CDATA[<p><strong>case 语句格式：</strong></p><pre><code>case value in （表达式）pattern1)    command    ;;pattern2）    command    ;;*）   commandesac</code></pre><p><strong>实例：菜单选择</strong></p><pre><code>#!/bin/bashMenu=(beef,noodles,rice,juice)echo &quot;The menu is:&quot;for i in ${Menu[*]}do   echo  &quot;$i&quot;doneread -p &quot;Please choose one:&quot; foodcase $food in        beef)         echo &quot;You choose beef!&quot;        ;;        noodles)          echo &quot;You choose noodles!&quot;        ;;        rice)          echo &quot;You choose rice!&quot;        ;;        juice)          echo &quot;You choose juice!&quot;        ;;        *)          echo &quot;Don&apos;t have this one!&quot;        ;;esac[root@jiangpeisi shell]# sh menu.sh The menu is:beef,noodles,rice,juicePlease choose one:noodlesYou choose noodles!</code></pre><p><strong>select 语法格式：</strong></p><pre><code>select i in （表达式）do   commanddone</code></pre><p><strong>实例：测试服务状态</strong></p><pre><code>#!/bin/bashPS3=&quot;Please enter your select menu:&quot;select i in http php mysql quitdocase $i in        http)          echo &quot;Test http&apos;s state!&quot;        ;;        php)          echo &quot;Test php&apos;s state!&quot;        ;;        mysql)          echo &quot;Test mysql&apos;s state!&quot;        ;;        quit)          echo &quot;Exit!&quot;          exitesacdone[root@jiangpeisi shell]# sh lnmp.sh1) http2) php3) mysql4) quitPlease enter your select menu:1Test http&apos;s state!Please enter your select menu:2Test php&apos;s state!Please enter your select menu:3Test mysql&apos;s state!Please enter your select menu:4Exit!</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;case 语句格式：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;case value in （表达式）
pattern1)
    command
    ;;
pattern2）
    command
    ;;
*）
   command
es
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习之四剑客find</title>
    <link href="http://yoursite.com/2019/03/20/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9B%9B%E5%89%91%E5%AE%A2find/"/>
    <id>http://yoursite.com/2019/03/20/shell脚本学习之四剑客find/</id>
    <published>2019-03-20T14:45:56.000Z</published>
    <updated>2019-03-20T16:02:35.465Z</updated>
    
    <content type="html"><![CDATA[<p><strong>简述</strong><br>  find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。<br><strong>语句格式：</strong></p><pre><code>find path -option [ -print ] [ -exec -ok command ] {} \;-print ：表示find命令将匹配的文件输出到标准输出中，默认执行该命令-exec  ：表示find命令对匹配的文件执行该参数给出的shell命令。相应命令的形式为 cmd {} \;-ok      ：它的作用和-exec一样，只是需要用户交互，更安全</code></pre><p><strong>option参数说明：</strong></p><pre><code>-name ：按照文件名查找文件-perm  ：按照权限查找文件-prune ：使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略-user  ： 按照文件属主来查找文件-group  ：按照文件数组来查找文件-mtime -n +n  ：按照文件的更改时间来查找文件    -n ：表示从此刻算起，文件的更改是在n天以内    +n ：表示文件的更改时间是在n天以前-atime -n +n ： 按文件访问时间来查询-ctime -n +n ：按文件创建时间来查询 -nogroup  ：查找无有效属组的文件，即该文件所属的组在/etc/groups中不存在-nouser  :：查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在-newer file1 ！ file2  :查找更改时间比file1新但比file2旧的文件-type      b：表示块设备文件     block     d：表示目录         directory     c：表示字符设备文件   char     p：表示管道文件      pipe     l：表示符号链接文件   link     f：表示普通文件      file-depth ：在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找-fstype ：表示查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/etc/fstab中找到，该配置文件中包含了本系统中有关文件系统的信息-mount  ：表示在查找文件时不跨越文件系统的mount点-follow   ：表示如果find命令遇到符号链接文件，就跟踪至链接所指向的文件-cpio      ：表示对匹配的文件使用cpio命令，将这些文件备份至磁带设备中</code></pre><p><strong>实例：</strong><br>实例1：查找/root/shell目录下以.sh结尾 并且创建时间在1天以内的文件</p><pre><code>[root@jiangpeisi ~]# find /root/shell/ -name *.sh -ctime -1/root/shell/menu.sh/root/shell/apache-install.sh/root/shell/lnmp.sh/root/shell/select.sh/root/shell/sum.sh/root/shell/while.sh</code></pre><p>实例2：查找/root/shell目录下以.sh结尾 并且创建时间在1天以内的文件，并将文件移动到/opt/目录下</p><pre><code>[root@jiangpeisi ~]# find /root/shell/ -name *.sh -ctime -1 -exec mv {} /opt/ \; [root@jiangpeisi ~]# ll /opt/total 36-rw-r--r-- 1 root root  621 Mar 20 15:32 apache-install.sh-rw-r--r-- 1 root root   48 Mar 17 11:08 b.sh-rw-r--r-- 1 root root  303 Mar 18 11:28 e.sh-rw-r--r-- 1 root root  258 Mar 20 14:25 lnmp.sh-rw-r--r-- 1 root root  357 Mar 20 08:49 menu.shdrwxr-xr-x 2 root root 4096 Mar 15 15:41 nginx-rw-r--r-- 1 root root  138 Mar 20 14:12 select.sh-rw-r--r-- 1 root root   82 Mar 20 00:00 sum.sh-rw-r--r-- 1 root root   70 Mar 20 00:07 while.sh</code></pre><p>实例3：查找/data目录下以.log结尾，修改时间在1天以内，文件大小大于10M的文件，并将文件打包</p><pre><code>[root@jiangpeisi ~]# find /data/ -name *.log -ctime -1 -size +10k -exec tar -czPf /datacd/backup.tar.gz {} \;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;简述&lt;/strong&gt;&lt;br&gt;  find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。&lt;br&gt;&lt;str
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习之循环语句</title>
    <link href="http://yoursite.com/2019/03/19/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"/>
    <id>http://yoursite.com/2019/03/19/shell脚本学习之循环语句/</id>
    <published>2019-03-19T14:45:56.000Z</published>
    <updated>2019-03-19T16:24:27.690Z</updated>
    
    <content type="html"><![CDATA[<p><strong>for循环语句格式</strong></p><pre><code>for var in （表达式）do    Commanddone</code></pre><p><strong>实例：计算1-100和</strong></p><pre><code>#!/bin/bashsum=0for i in `seq 1 100`do  sum=$(expr $sum + $i)doneecho $sum[root@jiangpeisi shell]# sh for.sh 5050</code></pre><p><strong>while循环语句格式</strong></p><pre><code>while（表达式）do    commanddone</code></pre><p><strong>实例：循环按行打印文件内容</strong></p><pre><code>#!/bin/bashwhile read linedo   echo $linedone &lt; /root/shell/a.txt[root@jiangpeisi shell]# sh while.sh lkitd:x:998:997:User for polkitd:/:/sbin/nologintss:x:59:59:Account used by the trousers package to sandbox the tcsd daemon:/dev/null:/sbin/nologinsshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologinpostfix:x:89:89::/var/spool/postfix:/sbin/nologinchrony:x:997:995::/var/lib/chrony:/sbin/nologinntp:x:38:38::/etc/ntp:/sbin/nologinnscd:x:28:28:NSCD Daemon:/:/sbin/nologintcpdump:x:72:72::/:/sbin/nologinadmin:x:1000:1000::/home/admin:/bin/bashdockerroot:x:996:993:Docker User:/var/lib/docker:/sbin/nologindockerroot-latest:x:995:992:Docker User:/var/lib/docker-latest:/sbin/nologinzarafa:x:994:991:Zarafa Service Account:/var/lib/zarafa:/sbin/nologintest1:x:1002:1002::/home/test1:/bin/bashjiangpeisi:x:1004:1004::/home/jiangpeisi:/bin/bashftpuser1:x:1005:1005::/home/ftpuser1:/bin/bashnamed:x:25:25:Named:/var/named:/bin/falsedhcpd:x:177:177:DHCP server:/:/sbin/nologinmysql:x:27:27:MariaDB Server:/var/lib/mysql:/sbin/nologinsaslauth:x:993:76:Saslauthd user:/run/saslauthd:/sbin/nologinapache:x:48:48:Apache:/usr/share/httpd:/sbin/nologin</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;for循环语句格式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for var in （表达式）
do
    Command
done
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;实例：计算1-100和&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;cod
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习之if条件判断</title>
    <link href="http://yoursite.com/2019/03/19/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8Bif%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD/"/>
    <id>http://yoursite.com/2019/03/19/shell脚本学习之if条件判断/</id>
    <published>2019-03-19T14:45:56.000Z</published>
    <updated>2019-03-19T15:57:03.332Z</updated>
    
    <content type="html"><![CDATA[<p><strong>语句格式：</strong></p><pre><code>if(条件表达式)  commandelif(条件表达式)  commandelse  commandfi</code></pre><p><strong>if常见的判断逻辑运算符</strong></p><pre><code>-f: 判断文件是否存在,例如if[-f filename ]。-d: 判断目录是否存在,例如if[ -d dir]。-eq :等于,应用于整型比较,即equal.-ne:不等于,应用于整型比较,即not equal。-lt: 小于,应用于整型比较,即letter。-gt:大于,应用于整型比较,即greater。-le: 小于或等于,应用于整型比较。-ge: 大于或等于,应用于整型比较。-a:双方都成立(and) ,用法为逻辑表达式-a逻辑表达式-o:单方成立(or),用法为逻辑表达式-o逻辑表达式。-z:空字符串。||:单方成立。&amp;&amp;:双方都成立表达式。</code></pre><p><strong>实例：</strong><br>使用if条件判断分数</p><pre><code>#!/bin/bashscores=$1if [ $scores -eq 100 ]; then   echo &quot; very good!&quot; ;elif [ $scores -gt 85 ];then   echo &quot;good!&quot; ;elif [ $scores -gt 60 ];then   echo &quot; pass! &quot; ;elif [ $scores -lt 60 ]; then   echo &quot;no pass!&quot;;fi[root@jiangpeisi shell]# sh scores.sh 95good!</code></pre><p>判断网络主机状态</p><pre><code>#!/bin/bashping -c2 -W1 $1 &amp;&gt;/dev/nullif [ $? -eq 0 ];then  echo &quot;$1 is UP&quot;else  echo &quot;$1[root@jiangpeisi shell]# sh state.sh 192.168.32.2192.168.32.2 is DOWN</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;语句格式：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(条件表达式)
  command
elif(条件表达式)
  command
else
  command
fi
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;if常见的判断逻辑运算符&lt;/s
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习之变量得使用</title>
    <link href="http://yoursite.com/2019/03/18/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8F%98%E9%87%8F%E5%BE%97%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/03/18/shell脚本学习之变量得使用/</id>
    <published>2019-03-18T14:45:56.000Z</published>
    <updated>2019-03-18T03:49:52.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量得定义"><a href="#变量得定义" class="headerlink" title="变量得定义"></a>变量得定义</h2><p>格式：变量名称 = 变量值</p><pre><code>[root@jiangpeisi ~]# name=Andy[root@jiangpeisi ~]# echo $nameAndy</code></pre><p>1.变量名称不能以数字、特殊字符开头<br>2.=代表为变量赋值<br>3.变量的值可以是数字、字符串、文件的位置、命令、命令的结果</p><hr><h2 id="变量的分类"><a href="#变量的分类" class="headerlink" title="变量的分类"></a>变量的分类</h2><p><strong>自定义变量</strong></p><pre><code>Hostname=AndyIP=192.168.32.1echo $Hostname &quot;- $IP&quot;echo $Hostname &apos;- $IP&apos;[root@jiangpeisi ~]# sh d.sh Andy - 192.168.32.1Andy - $IP</code></pre><p>引号的区别：<br>    单引号与双引号的区别在于：单引号内若存在变量，存在的变量当做字符串不会被解析，原样输出；而双引号中若存在变量，该变量会被解析出其具体的值再加入到字符串中。<br>引号用法：<br>    1.不加引号可以直接定义内容包含数字、字符串、路径名等，适合定义数字<br>    2.单引号适合于纯定义字符串，<br>    3.而双引号适合于字符串的内容中包含有变量的内容的定义。</p><p><strong>环境变量</strong><br>使用env命令显示当前系统的环境变量</p><pre><code>[root@jiangpeisi ~]# envXDG_SESSION_ID=1189HOSTNAME=jiangpeisiTERM=xtermSHELL=/bin/bashHISTSIZE=1000SSH_CLIENT=49.70.204.253 2085 22SSH_TTY=/dev/pts/0USER=rootLS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=01;05;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=01;36:*.au=01;36:*.flac=01;36:*.mid=01;36:*.midi=01;36:*.mka=01;36:*.mp3=01;36:*.mpc=01;36:*.ogg=01;36:*.ra=01;36:*.wav=01;36:*.axa=01;36:*.oga=01;36:*.spx=01;36:*.xspf=01;36:MAIL=/var/spool/mail/rootPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/binPWD=/rootLANG=en_US.UTF-8HISTCONTROL=ignoredupsSHLVL=1HOME=/rootLOGNAME=rootSSH_CONNECTION=49.70.204.253 2085 172.16.30.80 22LESSOPEN=||/usr/bin/lesspipe.sh %sXDG_RUNTIME_DIR=/run/user/0_=/usr/bin/env</code></pre><p>定义全局变量</p><pre><code>export 变量名=变量值</code></pre><p>定义路径变量</p><pre><code>export PATH=$PATH:/root/bin    Export PATH=$PATH:格式不能错</code></pre><p>  单纯使用export命令设置全局变量仅临时有效，在机器重启后会失效，若想设置永久全局变量需要将环境变量的定义写在开机加载的配置文件中。例如：/etc/profile、/etc/profile.d、/etc/bashrc</p><p><strong>位置变量</strong><br>主要是向脚本中传递数据，变量名不能自定义，变量作用是固定的$n</p><pre><code>$0：代表命令本身，$1-9代表接受的第1-9个参数，10以上需要用{}括起来比如${10}代表接收的第10个参数$*：代表接收所有的参数，将所有参数看作一个整体$@：代表接收的所有参数，将每个参数区别对待$#：代表接收的参数个数dirname $0     获取目录名部分basename $0   获取文件名部分</code></pre><p>实例：</p><pre><code>echo &quot;path of script : $0&quot;echo &quot;name of script : $(basename $0)&quot;echo &quot;parameter 1 : $1&quot;echo &quot;parameter 2 : $2&quot;echo &quot;parameter 3 : $3&quot;echo &quot;parameter 4 : $4&quot;echo &quot;parameter 5 : $5&quot;echo &quot;The number of arguments passed : $#&quot;echo &quot;Show all arguments : $*&quot;echo &quot;Prncess TD : $$&quot;echo &quot;errors : $?&quot;[root@jiangpeisi ~]# sh /opt/e.sh a b c d e path of script : /opt/e.shname of script : e.shparameter 1 : aparameter 2 : bparameter 3 : cparameter 4 : dparameter 5 : eThe number of arguments passed : 5Show all arguments : a b c d ePrncess TD : 12807errors : 0</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;变量得定义&quot;&gt;&lt;a href=&quot;#变量得定义&quot; class=&quot;headerlink&quot; title=&quot;变量得定义&quot;&gt;&lt;/a&gt;变量得定义&lt;/h2&gt;&lt;p&gt;格式：变量名称 = 变量值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@jiangpeisi ~]# name=And
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Docker镜像构建</title>
    <link href="http://yoursite.com/2019/03/15/Docker%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA/"/>
    <id>http://yoursite.com/2019/03/15/Docker镜像构建/</id>
    <published>2019-03-15T14:45:56.000Z</published>
    <updated>2019-03-15T15:36:18.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>Docker镜像的制作一共有两种方法，一种是手动构建，另一种是使用Dockerfile自动构建Docker镜像。本例使用两种方法，基于centos镜像重新构建两个nginx镜像。</p><hr><h2 id="手动构建Docker镜像"><a href="#手动构建Docker镜像" class="headerlink" title="手动构建Docker镜像"></a>手动构建Docker镜像</h2><p><strong>基于centos 创建容器</strong></p><pre><code>run -it --name yum_nginx centos </code></pre><p><strong>进入容器安装需要用到的软件包</strong></p><pre><code>yum install  openssl openssl-devel zlib zlib-devel gcc-c++ pcre pcre-devel wget -y</code></pre><p><strong>下载nginx源码</strong></p><pre><code>cd  /usr/local/src/ wget http://nginx.org/download/nginx-1.14.2.tar.gz   </code></pre><p><strong>解压源码</strong></p><pre><code>tar -xvf nginx-1.14.2.tar.gz</code></pre><p><strong>添加nginx用户</strong></p><pre><code>useradd -M nginx -s /sbin/nologin </code></pre><p><strong>编译源码</strong></p><pre><code>cd nginx-1.14.2./configure --prefix=/usr/local/nginx --user=nginx --group=nginx --with-pcremake &amp;&amp; make install</code></pre><p><strong>修改配置文件，让nginx在前台运行，放置容器主进程退出后，nginx也终止运行</strong></p><pre><code>echo &quot;daemon off;&quot; &gt;&gt;  /usr/local/nginx/conf/nginx.conf</code></pre><p><strong>退出容器，并让容器处于退出状态</strong><br><img src="http://static.zybuluo.com/jiangpeisi/wjfsy1e6st7hmvifj2ru1hr8/image_1d60ttqhs1mp31qgb5bhn7h8f21t.png" alt="image_1d60ttqhs1mp31qgb5bhn7h8f21t.png-16.5kB"><br><strong>构建镜像</strong></p><pre><code>docker commit -m &quot;my nginx&quot;  ac7b398c89a5  jiangpeisi/my-nginx:v1</code></pre><p><strong>查看构建的镜像</strong></p><pre><code>docker images</code></pre><p><img src="http://static.zybuluo.com/jiangpeisi/rqxhkol42uggjsyzwiq8yfoh/image_1d60u01la1qov1iasd541t2c1jp33n.png" alt="image_1d60u01la1qov1iasd541t2c1jp33n.png-12.7kB"><br><strong>使用新构建镜像创建容器</strong></p><pre><code>docker run -d -p 8080:80 jiangpeisi/my-nginx:v1 /usr/local/nginx/sbin/nginxlinks 47.107.103.142:8080</code></pre><p><img src="http://static.zybuluo.com/jiangpeisi/zcrz47yv76c7lgfplwx0i9x8/image_1d60u265915ev19t78rb1a0qo7a4u.png" alt="image_1d60u265915ev19t78rb1a0qo7a4u.png-17.1kB"></p><hr><h2 id="使用Dockerfile自动创建镜像"><a href="#使用Dockerfile自动创建镜像" class="headerlink" title="使用Dockerfile自动创建镜像"></a>使用Dockerfile自动创建镜像</h2><p><strong>创建Dockerfile目录</strong></p><pre><code>mkdir /opt/nginx/</code></pre><p><strong>下载需要用到的文件</strong></p><pre><code>wget http://nginx.org/download/nginx-1.14.2.tar.gz  #下载到Dockerfile目录下</code></pre><p><strong>创建Dockerfile</strong></p><pre><code>vim /opt/nginx/Dockerfile  #Dockerfile一定要写正确#This is my first Dockerfile#Version 1.0#Base images FROM centos#MAINTAINERMAINTAINER Jiang Pei Si#ADDADD nginx-1.14.2.tar.gz /usr/local/src#RUNRUN yum install  openssl openssl-devel zlib zlib-devel gcc-c++ pcre pcre-devel wget -yRUN useradd -M nginx -s /sbin/nologin#WORKDIRWORKDIR /usr/local/src/nginx-1.14.2RUN ./configure --prefix=/usr/local/nginx --user=nginx --group=nginx --with-pcreRUN make &amp;&amp; make installRUN echo &quot;daemon off;&quot; &gt;&gt; /usr/local/nginx/conf/nginx.confEXPOSE 80ENV PATH /usr/local/nginx/sbin:$PATHCMD [&quot;nginx&quot;]</code></pre><p><strong>构建镜像</strong></p><pre><code>docker build -t my-nginx:v1 /opt/nginx/ </code></pre><p><img src="http://static.zybuluo.com/jiangpeisi/eaqp4j0r9xnrgl3ieimtxqfy/image_1d60u8mfd9drpr3127bcravt477.png" alt="image_1d60u8mfd9drpr3127bcravt477.png-15.3kB"><br><strong>使用新构造的镜像创建容器</strong></p><pre><code>docker run -d -p 8088:80 my-nginx:v1 links 47.107.103.142：8088 </code></pre><p><img src="http://static.zybuluo.com/jiangpeisi/ompae3nlc8znrszripxmlvii/image_1d60urjrues3170a7opndck3m8e.png" alt="image_1d60urjrues3170a7opndck3m8e.png-16.9kB"></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>  docker 容器默认会把容器内部第一个进程，也就是pid=1的程序作为docker容器是否正在运行的依据，如果docker 容器pid挂了，那么docker容器便会直接退出。<br>  dockerrun的时候把command做为容器内部命令，如果你使用nginx，那么nginx程序将后台运行，这个时候nginx并不是pid为1的程序，而是执行的bash，这个bash执行了nginx指令后就挂了，所以容器也就退出了<br>  daemon off     nginx可以在没有主进程的情况下在前台运行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;&lt;p&gt;Docker镜像的制作一共有两种方法，一种是手动构建，另一种是使用Dockerfile自动构建Docker镜像。本例使用两种方法，基于cen
      
    
    </summary>
    
      <category term="虚拟化" scheme="http://yoursite.com/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="Docker" scheme="http://yoursite.com/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/Docker/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="虚拟化" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>DNS服务配置</title>
    <link href="http://yoursite.com/2019/03/13/DNS%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/03/13/DNS配置/</id>
    <published>2019-03-13T14:45:56.000Z</published>
    <updated>2019-03-14T06:11:49.644Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><strong>基本IP配置</strong><br>服务器：</p><p> BOOTPROTO=static<br> IPADDR=192.168.32.152<br> NETMASK=255.255.255.0<br> GATEWAY=192.168.32.2<br> ONBOOT=yes<br>客户端：</p><p> BOOTPROTO=static<br> ONBOOT=yes<br> IPADDR=192.168.32.151<br> NETMASK=255.255.255.0<br> GATEWAY=192.168.32.2</p></li><li><p><strong>安装bind</strong></p><p> yum install bind bind-devel bind-utils bind-libs bind-chroot -y</p></li><li><p><strong>修改主配置文件：/etc/named.conf</strong><br><img src="http://static.zybuluo.com/jiangpeisi/6y4auc81ay92fwny3fobq8fs/image_1d5qnrnal1sip1p47198s1m7712le4h.png" alt="image_1d5qnrnal1sip1p47198s1m7712le4h.png-128.6kB"><br> listen-on port 53 { any; };  //监听所有IP地址<br> listen-on-v6 port 53 { ::1; };  //可以注释掉<br> directory       “/var/named”;  //定义区域数据库文件位置<br> dump-file       “/var/named/data/cache_dump.db”;  //域名缓存数据库文件位置<br> statistics-file “/var/named/data/named_stats.txt”; //状态统计文件位置<br> memstatistics-file “/var/named/data/named_mem_stats.txt”;  //内存使用统计文件位置<br> allow-query     { any; };  //允许查询的客户端IP地址<br> recursion yes;  //是否企业轮询查询模式<br> dnssec-enable yes;  //是否启用DNSSEC支持<br> severity dynamic;  //定义日志输出的安全级别<br> include “/etc/named.rfc1912.zones”;  //包含辅助区域配置文件的所有配置</p></li><li><strong>修改服务区域文件：/etc/named.rfc1912.zones</strong><br>设置正向区域<br><img src="http://static.zybuluo.com/jiangpeisi/t4ufb51tooz40udtyppgem1k/image_1d5qnvdrp1lgs7jg1ro71ree2lk5b.png" alt="image_1d5qnvdrp1lgs7jg1ro71ree2lk5b.png-4.4kB"><br>设置逆向区域<br><img src="http://static.zybuluo.com/jiangpeisi/ozeiepuknyo7hfauan0zixqe/image_1d5qnvstf78b166r1nk499iap25o.png" alt="image_1d5qnvstf78b166r1nk499iap25o.png-5.7kB"></li><li><strong>设置正向解析区域数据配置文件：/var/named/mirror.com.zone</strong><br><img src="http://static.zybuluo.com/jiangpeisi/tnc15ph3708hdhdhsbjgzskl/image_1d5qo7b0s1obg1qv5vmo614miu9b.png" alt="image_1d5qo7b0s1obg1qv5vmo614miu9b.png-10.2kB"><br>@       IN      NS      <a href="http://www.mirror.com" target="_blank" rel="noopener">www.mirror.com</a>.  //指定DNS服务器域名，必须有一天A记录与之对应<br>www     IN      A       192.168.32.152  //www表示域的名称</li><li><p><strong>设置逆向解析区域配置文件：/var/named/192.168.32.arpa</strong><br><img src="http://static.zybuluo.com/jiangpeisi/xm1ohm3ajuiwiae761ksw7l7/image_1d5qoba55qdtag31v30ps49n9o.png" alt="image_1d5qoba55qdtag31v30ps49n9o.png-9kB"><br> 152     IN      PTR     <a href="http://www.mirror.com" target="_blank" rel="noopener">www.mirror.com</a>.  //152表示192.168.32.152</p></li><li><p><strong>防火墙放行服务</strong></p><p> firewall-cmd –add-service=dns </p></li><li><p><strong>重启named.service</strong></p><p> systemctl restart named.service</p></li><li><p><strong>修改dns配置文件：/etc/resolv.conf</strong></p><p> nameserver 192.168.32.152</p></li><li><p><strong>正向解析测试</strong></p><p> [root@jiangpeisi named]# nslookup <a href="http://www.mirror.com" target="_blank" rel="noopener">www.mirror.com</a><br> Server:        192.168.32.152<br> Address:    192.168.32.152#53</p><p> Name:    <a href="http://www.mirror.com" target="_blank" rel="noopener">www.mirror.com</a><br> Address: 192.168.32.152</p></li><li><p><strong>逆向解析测试</strong></p><p> [root@jiangpeisi named]# nslookup 192.168.32.152<br> Server:        192.168.32.152<br> Address:    192.168.32.152#53</p><p> 152.32.168.192.in-addr.arpa    name = <a href="http://www.mirror.com" target="_blank" rel="noopener">www.mirror.com</a>.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;基本IP配置&lt;/strong&gt;&lt;br&gt;服务器：&lt;/p&gt;
&lt;p&gt; BOOTPROTO=static&lt;br&gt; IPADDR=192.168.32.152&lt;br&gt; NETMASK=255.255.255.0&lt;br&gt; GATEWAY=192.168
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="DNS" scheme="http://yoursite.com/categories/linux/DNS/"/>
    
    
      <category term="DNS" scheme="http://yoursite.com/tags/DNS/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>自动部署博客</title>
    <link href="http://yoursite.com/2019/03/11/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2019/03/11/自动部署博客/</id>
    <published>2019-03-11T14:04:56.000Z</published>
    <updated>2019-03-10T16:58:54.531Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><strong>创建.bat文件</strong></p><p> @echo off<br> F:<br> cd F:\Myblog<br> hexo clean&amp;&amp;hexo g&amp;&amp;hexo d</p></li><li><p><strong>指令解释</strong><br>第一条指令@echo off，关闭回显。<br>第二叫指令F:，切换到博客站点目录所在的盘符，我这里是F盘，<br>第三条指令cd F:\Myblog，进入站点目录，我这里是cd F:\Myblog<br>第四条指令hexo clean&amp;&amp;hexo g&amp;&amp;hexo d，清楚本地缓存，重新在本地部署，在推送到GitHub上。</p></li><li><p><strong>运行</strong><br><img src="http://static.zybuluo.com/jiangpeisi/j8ot6tcf8hoof0njcrsdkqpw/image_1d5k75ao212b417581b3af55n2l9.png" alt="image_1d5k75ao212b417581b3af55n2l9.png-65.5kB"></p></li><li><p><strong>添加定时任务</strong><br>Win+R 输入 compmgmt.msc 打开计算机管理，添加计划任务<br><img src="http://static.zybuluo.com/jiangpeisi/cwatgva011d8kkyfh8wmwu11/image_1d5k7ni3vhidici170ilj7t9im.png" alt="image_1d5k7ni3vhidici170ilj7t9im.png-35.1kB"></p><p> 设置计划任务执行时间<br> <img src="http://static.zybuluo.com/jiangpeisi/hc4rw8qux0q4wqxgwyot9bv4/image_1d5k7oebm1tcq9rcj810s81us613.png" alt="image_1d5k7oebm1tcq9rcj810s81us613.png-39.6kB"></p><p> 设置计划任务执行程序<br> <img src="http://static.zybuluo.com/jiangpeisi/cor89r9jlgzq10c1yf890rt2/image_1d5k7r28bbak1il4fauih41h2p1g.png" alt="image_1d5k7r28bbak1il4fauih41h2p1g.png-18.9kB"></p><p> 添加完成<br> <img src="http://static.zybuluo.com/jiangpeisi/m13bs2pvltlgrhx578qnpbvz/image_1d5k7sspa1jog1nlo10jlicb1gc2d.png" alt="image_1d5k7sspa1jog1nlo10jlicb1gc2d.png-117kB"></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;创建.bat文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; @echo off&lt;br&gt; F:&lt;br&gt; cd F:\Myblog&lt;br&gt; hexo clean&amp;amp;&amp;amp;hexo g&amp;amp;&amp;amp;hexo d&lt;/p&gt;
&lt;/li&gt;
&lt;li
      
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>DNS解析过程及查询模式</title>
    <link href="http://yoursite.com/2019/03/09/DNS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/03/09/DNS解析过程及查询模式/</id>
    <published>2019-03-09T14:45:56.000Z</published>
    <updated>2019-03-13T05:35:49.345Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>DNS简介</strong><br> DNS（Domain Name Server）是一种主机域名和IP地址转换机制，使用一种分层的分布式数据库来处理Internet上成千上万个主机和IP地址的转换。基于C/S模式设计</li><li><strong>域名层次结构</strong><br><img src="http://static.zybuluo.com/jiangpeisi/yo9xyl3z4p3lt133f9btnyw3/image_1d5gj25qdr8k1jsc1mkn1dj8kq03n.png" alt="image_1d5gj25qdr8k1jsc1mkn1dj8kq03n.png-27.2kB"><br><img src="http://static.zybuluo.com/jiangpeisi/dy5ox1fmut0rykilknfx5isc/image_1d5giqc091h5di6rphm1gpuepg1g.png" alt="image_1d5giqc091h5di6rphm1gpuepg1g.png-89.4kB"></li><li><strong>DNS解析过程</strong><br><img src="http://static.zybuluo.com/jiangpeisi/7r01q8cf9wow42cuksr79cxv/image_1d5gis09d1b5s1seu1k781f57ed92t.png" alt="image_1d5gis09d1b5s1seu1k781f57ed92t.png-47.3kB"><br> 当我们去解析一个域名时，比如解析xxx.sh.com,会经过如下步骤:<br> 1.查看本机的缓存有无该域名记录，如果没有，查看本机的host文件有无该域名记录，如果没有，则发个请求到本地DNS服务器。<br> 2.本地DNS服务器收到请求后，查看是否有该域名的解析，如果有，返回解析记录给主机，如果没有，则请求根域名服务器.。<br> 3.根域名服务器收到请求后，返回该域名对应的顶级域名服务器,比如这次请求返回.com的服务器地址。<br> 4.本地域名服务器接到顶级域名服务器地址后，向该顶级域名服务器请求。<br> 5.顶级域名服务器返回该域名的二级域名务器地址，返回.sh.com对应的二级服务器地址。<br> 6.本地域名服务器获得该地址后，发请求到该域名的二级域名服务器。<br> 7.二级域名服务器解析xxx.sh.com，并将解析结果返回给本地域名服务器。<br> 8.本地域名服务器获取该解析后，返回给主机，解析完成。</li><li><strong>DNS解析模式</strong><br> 1.递归查询 ：当服务器收到DNS客户发来的请求，如果本地没有客户请求的数据就代替客户向其他DNS服务器请求，并将结果返回给客户，所以递归查询只会向客户返回查询结果或查询失败两种信息。<br> 2.迭代查询：当服务器收到DNS客户发来的请求，如果在服务器内没有查到客户需要的数据，会返回给客户另外一台DNS服务器的地址。客户就会向下一台DNS服务器进行查询，这样一直查询下去，一直查询到所需要的数据或没有DNS服务器可以查询为止。</li><li><strong>常用DNS服务器地址</strong><br>国内：114.114.114.114 备用：114.114.114.115<br>国外：8.8.8.8 备用：8.8.4.4</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;DNS简介&lt;/strong&gt;&lt;br&gt; DNS（Domain Name Server）是一种主机域名和IP地址转换机制，使用一种分层的分布式数据库来处理Internet上成千上万个主机和IP地址的转换。基于C/S模式设计&lt;/li&gt;
&lt;li&gt;&lt;str
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="DNS" scheme="http://yoursite.com/categories/linux/DNS/"/>
    
    
      <category term="DNS" scheme="http://yoursite.com/tags/DNS/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>FTP传输模式及安装配置</title>
    <link href="http://yoursite.com/2019/03/08/FTP%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2019/03/08/FTP简介/</id>
    <published>2019-03-08T14:45:56.000Z</published>
    <updated>2019-03-13T05:36:34.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FTP简介"><a href="#FTP简介" class="headerlink" title="FTP简介"></a>FTP简介</h2><ul><li><strong>FTP端口号</strong><br>FTP使用20和21端口，FTP服务器使用21端口来等待控制连接建立请求,并通过控制连接传送命令及命令的响应。控制连接与数据连接相互独立，首先建立控制连接，通过身份验证后才会建立数据连接。数据连接是传输文件时临时建立的，服务器使用20端口建立数据连接并传送数据。数据连接存在时，控制连接一定是存在的。</li><li><p><strong>FTP传输模式</strong><br>FTP基于C/S模式,服务端与客户端传输数据有两种模式：主动模式和被动模式，主被动模式都是在建立数据链接时相对于服务器而言的。</p><p> 主动模式：<br> FTP客户端随机开启一个大于1024的端口N向服务器的21号端口发起连接，并进行账户密码验证。验证通过后开放N+1端口进行监听，并向服务器发送一个PORT N+1命令，告诉服务器服务器现在使用主动模式。服务器接收到命令后会有用其本地20端口连接客户端的N+1端口进行数据传输。主动模式数控制接与数据连接方向是相反的。<br> 被动模式：</p><p> FTP客户端随机开启一个大于1024的端口N向服务器的21端口发起连接，并进行账户密码验证。验证通过后开放N+1端口进行监听，并发送一个PASV命令，告诉服务器现在使用被动模式，服务器接到命令后会随机开放一个大于1024的端口P,并发送命令PORT P命令给客户端,客户端使用自己的N+1端口连接服务器的端口P。被动模式控制连接和数据连接方向是一致的。</p><p> 应用场景：<br> 主动模式的FTP通常用在客户端访问处于防火墙内部的FTP服务器的情况。<br> 被动模式的FTP通常用在处于防火墙之后的FTP客户端访问外部的FTP服务器的情况。<br> 因为防火墙默认会关闭所有端口，但是在进行数据连接建立时需要开放随机端口，所以在防火墙内部的主机或服务器会因为端口被防火墙关闭而造成建立连接失败。</p></li><li><p><strong>FTP三种用户</strong><br>匿名用户：anonymous或ftp<br>本地用户：真实用户，帐号名称、密码等信息保存在passwd、shadow文件中<br>虚拟用户：使用独立的账号/密码数据文件 </p></li></ul><h2 id="FTP安装配置"><a href="#FTP安装配置" class="headerlink" title="FTP安装配置"></a>FTP安装配置</h2><ul><li><p><strong>安装</strong><br>yum install vsftpd*  -y<br>systemctl start vsftp.service<br>出现问题：<br><img src="http://static.zybuluo.com/jiangpeisi/hbcn913ox83o6ro98pntmfwf/image_1d5cdv1gs6ekcda1mh6t3b10vt34.png" alt="image_1d5cdv1gs6ekcda1mh6t3b10vt34.png-12.5kB"><br>原因：使用被动模式，服务端需要开启随机端口，而服务端端口又被防火墙关闭，所以导致连接失败。<br>解决：<br>打开控制面板-&gt;Internet选项-&gt;高级-&gt;FTP被动传输模式取消<br><img src="http://static.zybuluo.com/jiangpeisi/0qjgorj8harhooz0p4x7d1bj/image_1d5ce2ntsuod178hh971kj5nmq3h.png" alt="image_1d5ce2ntsuod178hh971kj5nmq3h.png-50kB"></p></li><li><p><strong>配置匿名用户</strong><br>默认匿名用户不可以上传和下载文件，创建文件的，修改配置文件可对匿名用户权限进行修改。<br><img src="http://static.zybuluo.com/jiangpeisi/xs13r9jhp14kgbmrs47dple6/image_1d5ceqrh5r63c2a6doqio3qh4o.png" alt="image_1d5ceqrh5r63c2a6doqio3qh4o.png-53.7kB"><br>1.修改配置：</p><p> vim /etc/vsftpd/vsftpd.conf</p><p> 设置如下选项：</p><pre><code>anonymous_enable=YES :允许匿名登陆anon_upload_enable=YES  ：允许匿名用户上传下载anon_mkdir_write_enable=YES  ：允许匿名用户创建目录anon_other_write_enable=YES  ：允许匿名用户写入其他权限</code></pre><p> 2.修改/var/ftp/pub目录权限</p><pre><code>chown -R ftp /var/ftp/pub/chmod 755 /var/ftp/pub/</code></pre><p> 3.再次使用匿名用户上传下载或创建文件<br> <img src="http://static.zybuluo.com/jiangpeisi/4n3ayp2k2sy9zizujaga57kl/image_1d5dajp5nbqa1eohmlu98rr4h55.png" alt="image_1d5dajp5nbqa1eohmlu98rr4h55.png-74.8kB"><br> 4.检查是否上传成功<br> <img src="http://static.zybuluo.com/jiangpeisi/cbqrh4frjai4u1zsnaqho5w3/image_1d5dalcqo1csv6hd1fm11h1010585i.png" alt="image_1d5dalcqo1csv6hd1fm11h1010585i.png-15.8kB"><br> 5.修改匿名用户和本地用户根目录：</p><pre><code>local_root=/var/www/htmlchroot_local_user=YES 将用户活动范围限制在主目录anon_root=/var/www/html</code></pre></li><li><p><strong>配置本地用户</strong><br>1.本地创建用户：</p><p> useradd ftpuser1 -s /sbin/nologin<br> echo 123456 | passwd –stdin ftpuser1</p><p> 修改配置文件:</p><pre><code>local_enable=YESanonymous_enable=YES</code></pre><p> 2.重启服务：</p><pre><code>systemctl restart vsftpd.service</code></pre><p> 3.验证：<br> <img src="http://static.zybuluo.com/jiangpeisi/z4ajomazutk2km68axqhsen0/image_1d5dbl2qootj1rtk169j1us1cld6c.png" alt="image_1d5dbl2qootj1rtk169j1us1cld6c.png-28kB"><br> ftp本地用户默认登陆后进入用户的家目录。</p></li><li><p><strong>ftp虚拟用户配置</strong><br>虚拟用户在FTP服务器上并不真实存在，而是映射到某一个系统真实用户及设置相应的权限来实现访问验证。<br>1.安装虚拟用户认证所需模块及软件：<br>yum install db4 db4_utils</p><p> 2.创建虚拟用户文件</p><pre><code>touch ftpuser.txt </code></pre><p> 3.在文件内添加虚拟用户</p><pre><code>ftpuser1123456ftpuser2123456</code></pre><p> 奇数行写账户，偶数行写密码<br> 4.生成虚拟用户认证数据库文件</p><pre><code>db_load -T -t hash -f /etc/vsftpd/ftpuser.txt /etc/vsftpd/vsftpd_login.db chmod 600 /etc/vsftpd/vsftpd_login.db</code></pre><p> 5.配置PAM认证文件：</p><pre><code>vim /etc/pam.d/vsftpd 把其他行注释掉添加如下配置auth       required     pam_userdb.so db=/etc/vsftpd/vsftpd_loginaccount    required     pamuserdb.so db=/etc/vsftpd/vsftpd_login</code></pre><p> 6.修改配置文件：</p><pre><code>pam_service_name=vsftpdguest_enable=YESguest_username=jiangpeisiuser_config_dir=/etc/vsftpd/vsftpd_guestuser_confvirtual_use_local_privs=YES 匿名用户具有与本地用户相同的权限chroot_local_user=YESchroot_list_enable=YESallow_writeable_chroot=YES 如果使用chroot，需要设置此项chroot_list_file=/etc/vsftpd/chroot_list</code></pre><p> 7.创建虚拟用户配置文件</p><pre><code>mkdir /etc/vsftpd/vsftpd_guestuser_conf/touch /etc/vsftpd/vsftpd_guestuser_conf/ ftpguest{1,2} </code></pre><p>  此处文件名必须与虚拟用户同名<br> 配置ftpguest1</p><pre><code>local_root=/home/jiangpeisi/ftpguest1write_enable=YESanon_world_readable_only=YESanon_upload_enable=YESanon_mkdir_write_enable=YESanon_other_write_enable=YES</code></pre><p> ftpguest2与ftpguest2类似<br> 8.创建虚拟用户家目录</p><pre><code>mkdir /home/jiangpeisi/ftpguest{1,2}chown -R jiangpeisi:jiangpeisi /home/jiangpeisi/</code></pre><p> 注：2.3.5之后，vsftpd增强了安全检查，如果用户被限定在了其主目录下，则该用户的主目录不能再具有写权限了！如果检查发现还有写权限，就会报该错误。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;FTP简介&quot;&gt;&lt;a href=&quot;#FTP简介&quot; class=&quot;headerlink&quot; title=&quot;FTP简介&quot;&gt;&lt;/a&gt;FTP简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;FTP端口号&lt;/strong&gt;&lt;br&gt;FTP使用20和21端口，FTP服务器使用21端口
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="FTP" scheme="http://yoursite.com/categories/linux/FTP/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="FTP" scheme="http://yoursite.com/tags/FTP/"/>
    
  </entry>
  
  <entry>
    <title>Docker基本原理</title>
    <link href="http://yoursite.com/2019/03/07/Docker%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/03/07/Docker基本原理/</id>
    <published>2019-03-07T14:45:56.000Z</published>
    <updated>2019-03-15T15:27:27.904Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>传统虚拟化与docker</strong><br>传统虚拟化是在宿主机上使用VMM对底层硬件资源进行管理和封装、隔离抽象为一种逻辑独立的资源，分配给上层虚拟主机使用。<br>Docker是直接在宿主主机操作系统的层次上通过Cgroups对物理资源隔离和Namespace对系统资源隔离，直接实现APP或者应用的虚拟化，实现轻量级的虚拟化容器。传统虚拟化技术创建虚拟主机的代价很大，一般创建两位数的虚拟主机，而使用Docker可以创建上千个Containers。</li><li><strong>Docker与LXC</strong><br>LXC是一种容器技术，它提供轻量级Linux容器，用户可以在LXC容器内安装应用程序和服务，而Docker被设计限制为单个应用程序，是基于容器的单一应用程序虚拟化引擎。Cgroups可以限制、记录、隔离进程组所使用的物理资源，Cgroups给LXC实现虚拟化提供了资源管理手段。从资源管理角度来看，三者的关系是，Cgroup在最底层落实资源管理，LXC在Cgroups、Namespace,unionFS上又封装了一层，而Docker是在LXC的基础上进行改进实现轻量级容器，所以Docker的实现是建立在LXC技术基础之上的。<br><img src="http://static.zybuluo.com/jiangpeisi/dbny9pj7ej74cb0mko9yq6ax/image_1d5aoehrclhutp61bgd1fma1b8r1g.png" alt="image_1d5aoehrclhutp61bgd1fma1b8r1g.png-198.3kB"></li><li><p><strong>LXC之Cgroups、Namespace、unionFS</strong><br><strong>Cgroups</strong><br> 由Linux内核支持，可以对物理资源进行限定、记录、隔离，比如CPU、磁盘和网络的IO,LXC技术的物理基础。<br><strong>Namespace</strong><br> 隔离系统资源，可以为每一个容器提供一个独立的namespace，在每一个namespace空间内有自己独立的进程号（即用户在每一个namespace内仿佛享有了系统可以使用的全部进程号，好像独占了一台linux虚拟机），每个namespace的进程号相对于另一个namespace是透明的，整个子namespace可以映射到父namespace的某一个进程号。<br><img src="http://static.zybuluo.com/jiangpeisi/demr66m33k1zrmwq0kd8pl9i/image_1d5aolh2l1tk21ge2149d1p53fj82d.png" alt="image_1d5aolh2l1tk21ge2149d1p53fj82d.png-96.4kB"><br><strong>unionFS：联合挂载文件系统</strong><br> 两个特殊的文件：<br> bootfs：包含boot loader和kernel，系统加电自检后挂载，当整个内核加载进内存后卸载，并释放内存。<br> rootfs：Linux启动时，rootfs会被以只读的方式挂载，启动完成后只读模式会被改为读写模式。典型 Linux 系统中的/dev，/proc，/bin，/etc等标准目录和文件。</p><p> Docker与传统linux启动不同，Docker在bootfs自检完毕后不会将rootfs设置为读写模式，而是利用unionFS将一个或多个read-only的rootfs加载到之前的rootfs之上，多层rootfs在加载之后仍然是一个文件系统，此时所有联合挂载的rootfs还属于镜像层，当使用镜像创建容器，在镜像层的read-only rootfs之上分配一个可读写的read-write的rootfs，这个rootfs成为容器层。当docker容器运行时，顶层是读写，下面的所有层都是只读的，只读层只需要读取读写层的数据，完成相应策略即可，符合策略于机制分离原则。<br><img src="http://static.zybuluo.com/jiangpeisi/1nugo3fesxgd1fdaz1m08a5d/image_1d5apedk91gkm88a8ul1b4s8qh5r.png" alt="image_1d5apedk91gkm88a8ul1b4s8qh5r.png-24.1kB"></p></li><li><strong>Docker 特性</strong><br>1.文件系统隔离：每个进程容器运行在完全独立的根文件系统里。<br>2.资源隔离：可以使用cgroup为每个进程容器分配不同的系统资源，例如CPU和内存。<br>3.网络隔离：每个进程容器运行在自己的网络命名空间里，拥有自己的虚拟接口和IP地址。<br>4.写时复制：采用写时复制方式创建根文件系统，这让部署变得极其快捷，并且节省内存和硬盘空间。<br>5.日志记录：Docker将会收集和记录每个进程容器的标准流（stdout/stderr/stdin），用于实时检索或批量检索。<br>6.变更管理：容器文件系统的变更可以提交到新的映像中，并可重复使用以创建更多的容器。无需使用模板或手动配置。<br>7.交互式Shell：Docker可以分配一个虚拟终端并关联到任何容器的标准输入上，例如运行一个一次性交互shell。</li><li><strong>三个重要概念</strong><br>1.Docker镜像：一个静态模板，类似于ISO镜像，不能修改，可以通过封装生成。<br>2.Docker容器：基于Docker镜像运行启动的应用或系统，也可称为Docker虚拟机。<br>3.Docker仓库：存放Docker镜像的地方，分为公开仓库和私有仓库。<br>Docker镜像类似于面向对象编程中的类，Docker容器类似于类实例化后的对象。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;传统虚拟化与docker&lt;/strong&gt;&lt;br&gt;传统虚拟化是在宿主机上使用VMM对底层硬件资源进行管理和封装、隔离抽象为一种逻辑独立的资源，分配给上层虚拟主机使用。&lt;br&gt;Docker是直接在宿主主机操作系统的层次上通过Cgroups对物理资源
      
    
    </summary>
    
      <category term="虚拟化" scheme="http://yoursite.com/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="Docker" scheme="http://yoursite.com/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/Docker/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="虚拟化" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Docker容器网络模式</title>
    <link href="http://yoursite.com/2019/03/07/Docker%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/03/07/Docker容器网络模式/</id>
    <published>2019-03-07T14:45:56.000Z</published>
    <updated>2019-03-15T15:25:05.858Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><strong>配置容器网络模式</strong></p><p> Docker run -net=pattern</p></li><li><p><strong>四种模式</strong></p><p> host模式：host模式下的容器不会独立创建一个network namespace,而是与宿主机公用一个network namespace。容器不会再虚拟出自己的网卡，配置IP，直接使用宿主机的IP及端口。</p><p> container模式：container模式下的容器与host模式下的容器类似，同样不会独立创建一个network namespace，而是和其他容器共用一个network namespace。两个容器除了network namespace是共享的之外，其他的如文件系统、进程列表等还是相互隔离的。</p><p> none模式：none模式下的容器拥有自己的network namespace，但是不会为容器进行任何网络配置，需要人工添加网卡、配置IP等信息，典型的pipework工具可以为此模式下的容器配置IP等信息。</p><p> bridge模式：docker容器默认的网络模式，该模式会为每一个容器分配一个network namespace，设置IP、路由等信息，并且默认会将这些容器连接到一个虚拟的交换机docker0上。</p></li><li><p><strong>bridge模式下的docker 容器创建过程</strong><br>1.启动docker容器，docker宿主机会创建一对虚拟网卡，veth pair设备，用于两个设备通信。<br>2.Docker 将veth pair 的一端放在新创建的docker 容器中，并命名为eth0，另一端放在宿主机中，以veth-container-id的方式命名，并将这个veth加入到docker0中。<br>3.Docker0从子网中分配一个IP给容器使用，并将容器的网关设置为docker0的IP地址。<br>此时容器间，容器与宿主机之间是可以通信的，容器也可以访问外网，但是其他宿主机不可以访问容器内的IP地址，需要通过NAT将容器IP的port映射为宿主机的IP和port，方可访问。</p></li><li><p><strong>docker桥接网络拓扑</strong><br><img src="http://static.zybuluo.com/jiangpeisi/062j0akdehbba7vej72yb1o3/image_1d5aqqol11q8733oqtbjqm1e4ic.png" alt="image_1d5aqqol11q8733oqtbjqm1e4ic.png-27.1kB"></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;配置容器网络模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; Docker run -net=pattern&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;四种模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; host模式：host模式下的容器不会独立创建
      
    
    </summary>
    
      <category term="虚拟化" scheme="http://yoursite.com/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="Docker" scheme="http://yoursite.com/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/Docker/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="虚拟化" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Dokcer安装并部署多个nginx</title>
    <link href="http://yoursite.com/2019/03/07/Docker%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2%E5%A4%9A%E4%B8%AAnginx/"/>
    <id>http://yoursite.com/2019/03/07/Docker安装并使用docker部署多个nginx/</id>
    <published>2019-03-07T14:45:56.000Z</published>
    <updated>2019-03-15T15:27:41.031Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><strong>Docker 安装</strong></p><p> 1.查看当前内核版本，要求3.10及以上版本</p><pre><code>uname -r</code></pre><p> 2.安装相关的包</p><pre><code>yum install -y yum-utils device-mapper-persistent-data lvm2 lxc libcgroup</code></pre><p> 3.安装docker</p><pre><code>yum install docker docker-* -y</code></pre><p> 4.关闭selinux并重启</p><pre><code>sed -i &apos;/SELINUX/s/enforcing/disabled/g&apos; /etc/selinux/config &amp;&amp; reboot</code></pre><p> 5.启动docker</p><pre><code>systemctl start docker </code></pre><p> 6.使用脚本一键安装</p><pre><code>curl -fsSL https://get.docker.com -o get-docker.shsh get-docker.sh</code></pre></li><li><p><strong>部署多台nginx服务器</strong></p><p> 1.获取Nginx镜像</p><pre><code>docker pull nginx</code></pre><p> 2.创建容器，并将容器内的80端口分别映射到宿主机的8080|8088端口，将容器的nginx配置文件挂载到本地，方便绕过写时复制，提高容器读写效率</p><pre><code>docker run -it --name nginx1 -h nginx1 -v /usr/local/etc/nginx1/html/:/usr/share/nginx/html -p 8080:80 nginx /bin/bashdocker run -it --name nginx2 -h nginx2 -v /usr/local/etc/nginx2/html/:/usr/share/nginx/html -p 8088:80 nginx /bin/bash</code></pre><p> <img src="http://static.zybuluo.com/jiangpeisi/gkzpvqgz3wxx28fda28r1zq7/image_1d5b1a092dct8lt1s331b451tm20.png" alt="image_1d5b1a092dct8lt1s331b451tm20.png-10.2kB"><br> 3.开启刚刚创建的容器</p><pre><code>docker start $(docker ps -qa)</code></pre><p> <img src="http://static.zybuluo.com/jiangpeisi/mrha1024sock53rz1ccnhoi9/image_1d5b1c9qvtf818bm2si498kiv2t.png" alt="image_1d5b1c9qvtf818bm2si498kiv2t.png-10.6kB"><br> 4.将容器内的nginx放置在后台运行</p><pre><code>docker exec -it nginx1 nginx &amp;docker exec -it nginx2 nginx &amp;</code></pre><p> 5.修改配置文件</p><pre><code>cd /usr/local/etc/nginx1/html/echo &quot;&lt;h1&gt;This is Nginx1&lt;/h1&gt;&quot; &gt; index.html cd /usr/local/etc/nginx2/html/echo &quot;&lt;h1&gt;This is Nginx2&lt;/h1&gt;&quot; &gt; index.html </code></pre><p> 6.浏览器访问<br><img src="http://static.zybuluo.com/jiangpeisi/faqgy3uozt8ukvbvi09tcmxt/image_1d5b1kdms3me1ssi1npr15m9h1m44.png" alt="image_1d5b1kdms3me1ssi1npr15m9h1m44.png-14kB"><br><img src="http://static.zybuluo.com/jiangpeisi/f47wg1yoq5zs0ioziifpy26e/image_1d5b1kp8f1d6712h81hap13le68f51.png" alt="image_1d5b1kp8f1d6712h81hap13le68f51.png-14.2kB"></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Docker 安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 1.查看当前内核版本，要求3.10及以上版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;uname -r
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 2.安装相关的包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yum i
      
    
    </summary>
    
      <category term="虚拟化" scheme="http://yoursite.com/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="Docker" scheme="http://yoursite.com/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/Docker/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="虚拟化" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
</feed>
