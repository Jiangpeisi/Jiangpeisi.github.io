<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我在看着你</title>
  
  <subtitle>by heart</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-19T04:46:45.887Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>镜子</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>海康威视技术支持实习生面试经过</title>
    <link href="http://yoursite.com/2019/04/18/%E6%B5%B7%E5%BA%B7%E5%A8%81%E8%A7%86%E6%8A%80%E6%9C%AF%E6%94%AF%E6%8C%81%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E7%BB%8F/"/>
    <id>http://yoursite.com/2019/04/18/海康威视技术支持实习生面经/</id>
    <published>2019-04-18T14:45:56.000Z</published>
    <updated>2019-04-19T04:46:45.887Z</updated>
    
    <content type="html"><![CDATA[<h2 id="废话"><a href="#废话" class="headerlink" title="废话"></a>废话</h2><p>  人生处女面，感觉有必要好好记录一下。提前一星期就通知了面试时间，期间疯狂恶补简历上的知识点，之前在简历上吹的牛逼，在这期间付出了惨重代价。更难受的是简历上技能和知识点，在整个面试过程中基本没问！What fuck？？就很难受。</p><p>  面试时间约在下午一点半，一早买了七点的火车票，九点到了上海，身为一个农村出来的土包子，出了火车站还是挺震撼的，各种高楼大厦。出了火车站就乘坐地铁先到要面试的地点踩了点，这个很重要，不然很有可能摸不到面试地点导致面试迟到。踩了点后就在公司附近奶茶店买了杯奶茶，因为实在太热了，穿个大风衣，室外温度将近30°，不来杯冰凉的奶茶实在太委屈自己了，买了奶茶后就在随便找了个餐馆吃了个午餐，然后在里面休息了一下。</p><p>  到了12点半左右去了公司，因为提前去的，前台招待就让我现在休息区等一下。等待的过程真的很煎熬，内心各种慌张。后来陆陆续续也来了很多面试的，跟他们简单的交流了一下，一共问了三个人，两个研究生，一个硕士，就很难受。顿时感觉自己很弱，看了一下他们的简历，就更难受了，一大堆已完成和在研项目，我感觉我就是自己给自己找麻烦，干嘛要看人家简历。。。。</p><p>  大概到了一点前台招待拿来了一个表格，主要填写一些个人信息啥的，填完表格交给前台就开始安排面试了。废话了那么多，下面来点干货。</p><hr><h2 id="干货"><a href="#干货" class="headerlink" title="干货"></a>干货</h2><p><strong>一面</strong><br>1.介绍一下自己<br>答:主要在学校学习方面，生活方面，还有性格方面对自己进行了介绍，最后分析了一下自己对应聘职位的符合程度，表达了一下入海康的期望</p><p>2.在自我介绍过程中我有说到自己花了两个月的时间完成了linux所有基础课程的学习，并且去考了红帽的系统工程师，他问了一下通过没有，我说过了就没有在继续问linux方面的知识。</p><p>3.看了你的简历感觉你技术方面应该是很厉害，说一下tcp与udp的区别吧，有哪些应用?<br>答:tcp协议可以实现可靠传输，因为在建立链接之前要经历三次握手机制，udp对于数据传输质量不高，因为udp只是把数据发送给接收方，并不管对方是否接收到了数据.应用方面，tcp应用的比较广泛，很多应用层协议都是在tcp的基础上实现的，udp用的比较少，主要用于音频传输。</p><p>4.什么是子网掩码?<br>答:子网掩码主要是用来区分网络位和主机位，为1的表示要匹配，为0表示可以匹配任意值。</p><p>5.你tcp/ip两卷都看完了吗？<br>答:第一卷看完了，第二卷看了一半，后面感觉太复杂了，没有在继续看，而且在当时看了也用不到。<br>后面没有继续问技术上的问题，感觉技术的提问略水。</p><p>6.问了一下工作经历。你是否了解海康威视。<br>答:之前有了解过海康威视，但不是特别多。海康威视主要做安防和视频监控方面的业务，在视频监控方面是行业龙头企业，并且业务涉及范围很广，在医疗 教育 交通 公安等方面都有涉及，对于产品具体的细节没有做详细的了解。</p><p>7.谈一下你对于技术支持这个岗位的看法<br>答：技术支持类似于售后一般公司将产品交到客户手中，客户在使用过程中如果产品出站了什么问题，或者不懂的地方，技术支持可以提供一定的帮助。––答的不好，面试官说我对于技术支持岗位的认识太局限了，我说其实之前对于我对于技术支持的看法不是这样的，主要是因为我之前在官网投简历的时候，看了一下工作内容，才对技术支持的看法有所改变，我之前认为技术支持工程师，主要是负责服务器的管理等等（根据面试官的讲解来看，还是太过片面）。然后她给我讲解了技术支持工程师在整个项目中的作用，从项目开始到项目的提交，挺详细的，记忆力有限，记不太清了。。</p><p>8.讲解过程中有提及到项目，问了一下我知道什么是项目吗？<br>沉默，微笑不语，然后她让我多看一下项目方面的书。</p><p>9.由于我说了自己肯吃苦耐劳，她就问了我吃苦耐劳的程度?<br>答。。。。。结合具体情况阐述了一下。</p><p>10.跟我说他们公司可能工作压力比较大，一周内可能会有两三天加班到11点，问我对于加班可以接受吗。<br>答:我自己每天的生活状态大概就是这样，白天学习，晚上出去做一些兼职，一般都会到10点11点，所以不存在什么问题。</p><p>11.问了一下自己的职业规划<br>答:近期目标就是找一个实习工作，其实我挺想进海康的，如果在海康实习的情况比较好，发展前景比较好，我会留在海康，如果不好可能会考虑往其他方向发展。</p><p>12.你所认为的发展前景好是什么样的?怎么样才算好？<br>答:就是公司对我的实习情况比较满意，愿意让我继续留在公司，并且我个人认可公司的工作机制，就会留在公司。</p><p>13.问了一下家庭情况</p><p>  一面差不多就这些，对于技术都是潦草带过，更多问的是个人问题，还有职业发展方面的问题，整个过程大概十来分钟，面试官就让我等下一步安排了。<br>面试官很和蔼，整个过程感觉良好。</p><p><strong>二面</strong><br>  感觉不是很好，进来问了一下我跟前面的面试官聊了什么，因为面试官给人感觉就是一个女强人形象所以，刚开始说话有点紧张，不是很顺利。<br>  后面让我自我介绍，自我介绍过程中面试官看着我的简历一直在笑，而且是那种略带嘲讽的感觉，让我很不舒服。</p><p>1.你是江苏大学的，为什么不投江苏那边的公司，选择投上海的呢?<br>答:对于工作地点我并不是很在意，更在意的是能够有这么一个实习的机会。</p><p>2.你是从哪里了解到海康威视的?<br>答:官网，还有就是有一个学长之前又在海康实习过，然后现在也留在了海康。</p><p>3.你学长叫什么，实习的什么岗位？<br>答:xxx,也是技术支持岗位，在杭州总部那边。</p><p>4.我看你的简历上面有写，掌握python，有没有考虑搞开发？<br>答：有想过，但是我在这方便不是特别强，所以也就仅仅是想了想，意愿不是很强。</p><p>5.问了我现在大三课程的进度，大四课多不多，我们这里实习一般要求两个月以上，你时间足够吗？<br>答:现在大三课程还没有完结，大四的话只有上学期有一些课，下学期没有课。我暑假假期有将近3个月，所以正好可以实习两到三个月。</p><p>6.你说你经常兼职，为什么简历上面只写了一个工作经历？<br>答:因为跟专业基本都不想干，所以就没有写</p><p>7.那你为什么干这些兼职？<br>主要就是想锻炼自己，充实自己的课余时间，丰富一下社会经验。</p><p>8.我有什么想问的？<br>(1)海康的实习生提不提供直接就业的机会?<br>答:会提供，因为我们本身就是针对下一年毕业的在校生进行招聘。所以是可以提供就业机会的。<br>(2)如果面试成功或者失败有没有通知?<br>答:面试成功一星期内会通过邮箱的方式通知，在这期间你要多留意一下自己的邮箱。<br>(3)我感觉整个面试过程，你们对于我的知识技能提问的不是很多，是不是咱们公司对于技术不是特别看重？<br>答:。。。。。吧啦吧啦一堆<br>4.如果要进入海康还需要做什么准备吗？<br>答:面试成功会在邮件没推荐阅读书籍。。。。巴拉巴拉一堆</p><p>  二面前半部分感觉不是特别好，不知道为什么面试官看着我的简历总是笑，后半部分还可以,对于我的问题回答的也挺认真的。</p><p><strong>总结</strong><br>  整个面试过程还算可以，一面整个过程很流畅，一面面完中间大概隔了10几分钟，就被叫去二面。二面前面感觉不是特别好，后面还行。感觉有机会，但是机会不大。</p><h2 id="敲黑板"><a href="#敲黑板" class="headerlink" title="敲黑板"></a>敲黑板</h2><p>  回答问题一定要自信，你对问题回答的情况决定了面试官对于该知识点是否还要继续问下去。回答的好没准面试官就会认为你对于该知识点已经掌握了，回答的不好，面试官不确定你对与该知识点是否掌握，可能会继续问下去。面试前要做好充分准备，准备工作做足了，自己也会更自信。回答问题要思路清晰，抓住重点回答，尽量多回答，引导面试官的思路，这样面试会轻松很多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;废话&quot;&gt;&lt;a href=&quot;#废话&quot; class=&quot;headerlink&quot; title=&quot;废话&quot;&gt;&lt;/a&gt;废话&lt;/h2&gt;&lt;p&gt;  人生处女面，感觉有必要好好记录一下。提前一星期就通知了面试时间，期间疯狂恶补简历上的知识点，之前在简历上吹的牛逼，在这期间付出了惨重代价
      
    
    </summary>
    
      <category term="杂谈" scheme="http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://yoursite.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>磁盘分区</title>
    <link href="http://yoursite.com/2019/04/14/%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/"/>
    <id>http://yoursite.com/2019/04/14/磁盘分区/</id>
    <published>2019-04-14T14:45:56.000Z</published>
    <updated>2019-04-14T01:41:07.842Z</updated>
    
    <content type="html"><![CDATA[<p><strong>fdisk命令</strong> </p><pre><code>用法： fdisk [选项] &lt;磁盘&gt;    更改分区表 fdisk [选项] -l &lt;磁盘&gt; 列出分区表 fdisk -s &lt;分区&gt;        给出分区大小(块数)选项： -b &lt;大小&gt;             扇区大小(512、1024、2048或4096) -c[=&lt;模式&gt;]           兼容模式：“dos”或“nondos”(默认) -h                    打印此帮助文本 -u[=&lt;单位&gt;]           显示单位：“cylinders”(柱面)或“sectors”(扇区，默认) -v                    打印程序版本 -C &lt;数字&gt;             指定柱面数 -H &lt;数字&gt;             指定磁头数 -S &lt;数字&gt;             指定每个磁道的扇区数</code></pre><p><img src="http://static.zybuluo.com/jiangpeisi/zdqh99oavfa0nb7b7tctigpg/image_1d8cn6s5p6i4l31eq33vh1sojp.png" alt="image_1d8cn6s5p6i4l31eq33vh1sojp.png-75.1kB"></p><p>有4个设备，分别为/dev/sda、/dev/sdb、/dev/mapper/cl-root、/dev/mapper/cl-swap。其中/dev/sda硬盘已经有2个分区分区为：/dev/sda1和/dev/sda2。/dev/mapper/cl-root和/dev/mapper/cl-swap两个设备是/dev/sda2分区创建的逻辑卷下</p><p><strong>磁盘分区</strong><br><img src="http://static.zybuluo.com/jiangpeisi/aaf8fvoe5fj2tumfzbcblj2r/image_1d8cn94orsmfh20ec41obu1bj31j.png" alt="image_1d8cn94orsmfh20ec41obu1bj31j.png-48.6kB"></p><pre><code>a   toggle a bootable flag 切换可引导标志b   edit bsd disklabel 编辑BSD磁盘标签c   toggle the dos compatibility flag 切换DOS兼容性标志d   delete a partition 删除分区g   create a new empty GPT partition table 创建一个新的空GPT分区表G   create an IRIX (SGI) partition table 创建一个ILIX（SGI）分区表l   list known partition types 列出已知分区类型m   print this menu 打印此菜单n   add a new partition 添加新分区o   create a new empty DOS partition table 创建一个新的空DOS分区表p   print the partition table 打印分区表q   quit without saving changes 不保存更改退出s   create a new empty Sun disklabel 创建一个新的空太阳标签t   change a partition&apos;s system id 更改分区的系统IDu   change display/entry units 更改显示/输入单元v   verify the partition table 验证分区表w   write table to disk and exit 将表写入磁盘并退出x   extra functionality (experts only) 额外功能（仅专家）</code></pre><p>1.创建主分区分区和扩展分区<br>三个主分区一个扩展分区<br><img src="http://static.zybuluo.com/jiangpeisi/jaz129e3ipjya2jty3lkxf8w/image_1d8cnbaim1c089hl69k5mr1eo82d.png" alt="image_1d8cnbaim1c089hl69k5mr1eo82d.png-26.3kB"><br><img src="http://static.zybuluo.com/jiangpeisi/5p1nus231x7eezccsil0wnbb/image_1d8cnbq9j15te1o801ltp1iuiesl2q.png" alt="image_1d8cnbq9j15te1o801ltp1iuiesl2q.png-33.8kB"><br>2.创建逻辑分区<br>    <img src="http://static.zybuluo.com/jiangpeisi/fiydwxiiayf8ozjqt8ca103k/image_1d8cnpfi398nhd01d7j12vv4qq5e.png" alt="image_1d8cnpfi398nhd01d7j12vv4qq5e.png-21kB"><br>    <img src="http://static.zybuluo.com/jiangpeisi/viy48ck1h8fjgf627mlqwyl6/image_1d8cnec18f6l17ll1g41rs5vgs47.png" alt="image_1d8cnec18f6l17ll1g41rs5vgs47.png-60.9kB"><br>主分区、扩展分区、逻辑分区三者关系：<br>主分区和扩展分区最多有4个。扩展分区最多只能一个，逻辑分区是对扩展分区持续切割出来的分区。能够被格式化的是主分区和逻辑分区，扩展分区无法被格式化。1–4号是保留给主、扩展分区的，逻辑分区一定是从5号开始。<br>3.格式化分区</p><pre><code>mkfs用法： mkfs [选项] [-t &lt;类型&gt;] [文件系统选项] &lt;设备&gt; [&lt;大小&gt;]选项： -t, --type=&lt;类型&gt;  文件系统类型；若不指定，将使用 ext2     fs-options     实际文件系统构建程序的参数     &lt;设备&gt;         要使用设备的路径     &lt;大小&gt;         要使用设备上的块数 -V, --verbose      解释正在进行的操作；                      多次指定 -V 将导致空运行(dry-run) -V, --version      显示版本信息并退出                      将 -V 作为 --version 选项时必须是惟一选项 -h, --help         显示此帮助并退出[root@jiangpeisi ~]# mkfs.xfs /dev/sdb5 -fmeta-data=/dev/sdb5              isize=512    agcount=4, agsize=65536 blks         =                       sectsz=512   attr=2, projid32bit=1         =                       crc=1        finobt=0, sparse=0data     =                       bsize=4096   blocks=262144, imaxpct=25         =                       sunit=0      swidth=0 blksnaming   =version 2              bsize=4096   ascii-ci=0 ftype=1log      =internal log           bsize=4096   blocks=2560, version=2         =                       sectsz=512   sunit=0 blks, lazy-count=1realtime =none                   extsz=4096   blocks=0, rtextents=0</code></pre><p>4.挂载</p><pre><code>mkdir /mnt/testmount /dev/sdb5 /mnt/test</code></pre><p>5.设置开机自动挂载</p><pre><code>vim /etc/fstab </code></pre><p>添加以下行</p><pre><code>/dev/sdb5       /mnt/test       xfs     defaults        0       </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;fdisk命令&lt;/strong&gt; &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;用法：
 fdisk [选项] &amp;lt;磁盘&amp;gt;    更改分区表
 fdisk [选项] -l &amp;lt;磁盘&amp;gt; 列出分区表
 fdisk -s &amp;lt;分区&amp;gt;        
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="磁盘分区" scheme="http://yoursite.com/tags/%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Samba服务</title>
    <link href="http://yoursite.com/2019/04/14/Samba%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2019/04/14/Samba服务/</id>
    <published>2019-04-14T14:45:56.000Z</published>
    <updated>2019-04-14T02:43:19.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>在早期的网络世界中，档案数据在不同主机之间的传输大多是使用FTP服务，但是FTP服务传输档案有一些小小的问题，那就是我们无法直接修改主机上面的档案数据，也就是说我们如果想要修改某个档案的数据时，就必须将该档案的服务器下载后才能修改，这样就很麻烦了。其实解决这个问题也很简单，NFS服务就很好的解决档案数据不能直接修改的问题，因为NFS服务是直接将共享目录挂载到客户端的机器上，那么共享目录就好像成了自己的目录一样，共享数据的使用自然就很方便，但是，NFS也有一些小小的问题，它仅能使Unix Like的机器相互分享。那么我要是需要Windows与Unix-Like这两个不同的平台相互分享呢？那该怎么办？也就是说，FTP服务实现了跨平台分享，却无法修改共享数据；NFS解决了共享数据的修改问题，却没办法实现跨平台的共享。所以，SAMBA服务也就随着需要产生了。 它综合了FTP和NFS的有点，既实现了跨平台的传输，还满足了修改数据的功能。</p><hr><h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><p>服务端：</p><pre><code>[root@jiangpeisi ~]# yum install samba -y</code></pre><p>客户端：</p><pre><code>[root@jiangpesi ~]# yum install samba-client -y</code></pre><h2 id="samba实例配置文件详解"><a href="#samba实例配置文件详解" class="headerlink" title="samba实例配置文件详解"></a>samba实例配置文件详解</h2><p>注：;开头的行都是实例配置，并不会起作用，#开的的行时注释行</p><pre><code>[global]# ----------------------- Network-Related Options -------------------------        workgroup = MYGROUP                                        设置Samba所在工作组或域名        server string = Samba Server Version %v                      设置服务器描述信息;       netbios name = MYSERVER                             设置服务器的NetBIOS名称;       interfaces = lo eth0 192.168.12.2/24 192.168.13.2/24            这只Samba服务器所使用的网卡接口，可以实验网卡的名称或者IP地址;       hosts allow = 127. 192.168.12. 192.168.13.                     设置允许访问Samba服务器的网络地址、主机地址及域名，多个参数以空格隔开# --------------------------- Logging Options -----------------------------        log file = /var/log/samba/log.%m                            设置日志文件保存路径和名称。%m代表客户端主机名        max log size = 50                              设置日志文件的最大值，单位为KB。当值为0时，表示不限制文件大小# ----------------------- Standalone Server Options ------------------------        security = user                       设置用户访问Samba服务器的安全级别;      encrypt passwords = yes           设置是否对Samba的密码进行加密;      smb passwd file = /etc/samba/smbpasswd           设置Samba密码文件的路径和名称        passdb backend = tdbsam                    如果使用加密密码，指定所使用的密码数据库类型# ----------------------- Domain Members Options ------------------------;       security = domain                          设置安全级别为domain，需要指定用户名和密码，指定Windows域控制器做身份验证;       passdb backend = tdbsam;       realm = MY_REALM;       password server = &lt;NT-Server-Name&gt;          指定身份验证服务器#----------------------------- Name Resolution -------------------------------;       wins support = yes;       wins server = w.x.y.z;       wins proxy = yes;       dns proxy = yes# --------------------------- Printing Options -----------------------------        load printers = yes             是否允许使用Samba打印机共享        cups options = raw            ;       printcap name = /etc/printcap        # obtain a list of printers automatically on UNIX System V systems:;       printcap name = lpstat;       printing = cups# --------------------------- File System Options ---------------------------;       map archive = no;       map hidden = no;       map read only = no;       map system = no;       store dos attributes = yes#============================ Share Definitions ==============================[homes]                           []内设置共享目录的名称        comment = Home Directories                                设置共享目录的注释说明        browseable = no                         设置在浏览时显示共享目录        writable = yes                              设置共享目录可写        create mode              设置默认创建的文件的权限        directory mode           设置默认创建的目录的权限        force  group             设置默认创建的文件的群组        force user               设置默认创建的文件的所有者        hosts allow              设置允许访问该共享资源的主机、网段、域        hosts deny               设置不能访问该共享资源的主机、网段、域;       valid users = %S                          设置只有允许访问共享目录的用户;       valid users = MYDOMAIN\%S                [printers]        comment = All Printers        path = /var/spool/samba        browseable = no        guest ok = no             设置是否允许匿名用户访问共享资源        writable = no        printable = yes;       [netlogon];       comment = Network Logon Service;       path = /var/lib/samba/netlogon;       guest ok = yes;       writable = no;       share modes = no;       [Profiles];       path = /var/lib/samba/profiles;       browseable = no;       guest ok = yes;       [public];       comment = Public Stuff;       path = /home/samba;       public = yes;       writable = no;       printable = no;       write list = +staff         设置可写的用户和群组</code></pre><h2 id="配置实例"><a href="#配置实例" class="headerlink" title="配置实例"></a>配置实例</h2><p><strong>share级别配置</strong><br>1.具体参数：</p><ul><li>Samba服务器所在工作组为：workgroup</li><li>Samba服务器描述信息:Samba Server</li><li>Samba服务器NetBIOS名称：test</li><li>共享目录：sharedir</li><li>共享目录名：share</li><li>允许访问服务器的网络：192.168.32.0/24</li><li>日志文件路径：/var/log/samba/log.%m</li><li>服务器网卡：ens33</li><li>访问权限：读写</li></ul><p>2.创建共享目录</p><pre><code>[root@jiangpeisi ~]# mkdir sharedir</code></pre><p>3.修改配置文件</p><pre><code>[root@jiangpeisi userdir]# vim /etc/samba/smb.conf</code></pre><p>修改配置如下：</p><pre><code>[global]        workgroup = SAMBA#       security = share        server string = Samba Server        netbios name = test        interfaces = ens33 lo        hosts allow = 192.168.32. 127.        log file = /var/log/samba/log.%m[share]        comment = share        path = /sharedir        public = yes</code></pre><p>貌似现在samba不支持直接指定security = share选项，添加会报错警告，这里先注释掉。<br>4.服务器修改共享文件权限</p><pre><code>[root@jiangpeisi ~]# chmod 777 -R /sharedir/</code></pre><p>5.客户端登陆并创建文件</p><pre><code>[root@jiangpesi ~]# smbclient  //192.168.32.152/shareEnter SAMBA\root&apos;s password: Anonymous login successfulTry &quot;help&quot; to get a list of possible commands.mb: \&gt; mkdir asmb: \&gt; </code></pre><p>6.服务器查看客户端创建的文件</p><pre><code>[root@jiangpeisi samba]# cd /sharedir/[root@jiangpeisi sharedir]# ll总用量 0drwxr-xr-x 2 nobody nobody 6 4月  13 22:56 a</code></pre><p>由于使用的匿名登陆，所以客户端登陆时会默认映射到nobody（nfsnoboody）用户，所以创建的文件所属用户和组都为noboody。</p><p><strong>user级别配置</strong><br>1.具体参数：</p><ul><li>Samba服务器所在工作组为：workgroup</li><li>Samba服务器描述信息:Samba Server</li><li>Samba服务器NetBIOS名称：test</li><li>共享目录：userdir</li><li>共享目录名：user</li><li>允许访问服务器的网络：192.168.0.0/16</li><li>日志文件路径：/var/log/samba/log.%m</li><li>服务器网卡：ens33</li><li>对Samba密码进行加密</li><li>加密数据库类型为：tdbsam</li><li>userdir目录的所有者和群组所有者为user</li><li>访问权限：读写</li></ul><p>2.创建组和用户</p><pre><code>[root@jiangpeisi ~]# useradd user</code></pre><p>2.创建samba用户</p><pre><code>[root@jiangpeisi ~]# smbpasswd  -a userNew SMB password:Retype new SMB password:Added user user.</code></pre><p>3.创建共享目录</p><pre><code>[root@jiangpeisi ~]# mkdir /userdir</code></pre><p>4.递归设置userdir目录的所有者和组为user</p><pre><code>[root@jiangpeisi ~]# chown -R user.user /userdir/</code></pre><p>5.修改配置文件</p><pre><code>[root@jiangpeisi userdir]# vim /etc/samba/smb.conf</code></pre><p>修改配置文件如下</p><pre><code>[global]        workgroup = SAMBA        server string = Samba Server        netbios name = test        interfaces = ens33        hosts allow = 192.168. 127.        log file = /var/log/samba/log.%m        security = user        passdb backend = tdbsam        encrypt passwords = yes[user]        comment = user        path = /userdir        writable = yes        public = no</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><strong>linux测试</strong><br>1.客户端登陆：</p><pre><code>[root@jiangpesi ~]# smbclient  //192.168.32.152/user -U userEnter SAMBA\user&apos;s password: Try &quot;help&quot; to get a list of possible commands.smb: \&gt; ls  .                                   D        0  Sat Apr 13 23:10:58 2019  ..                                 DR        0  Sat Apr 13 23:10:58 2019        17811456 blocks of size 1024. 15489980 blocks availablesmb: \&gt; mkdir asmb: \&gt; ls  .                                   D        0  Sat Apr 13 23:23:23 2019  ..                                 DR        0  Sat Apr 13 23:10:58 2019  a                                   D        0  Sat Apr 13 23:23:23 2019        17811456 blocks of size 1024. 15490020 blocks available</code></pre><p>2.服务端查看：</p><pre><code>[root@jiangpeisi userdir]# ll总用量 0drwxr-xr-x 2 user user 6 4月  13 23:23 a</code></pre><p>3.挂载</p><pre><code>[root@jiangpesi ~]# mount -o username=user //192.168.32.152/user /mnt/usermount: //192.168.32.152/user 写保护，将以只读方式挂载mount: 无法以只读方式挂载 //192.168.32.152/user</code></pre><p>出现此问题是因为缺少cifs-utils，安装包后重新挂载。</p><pre><code>[root@jiangpesi ~]# yum -y install cifs-utils[root@jiangpesi ~]# mount -o username=user //192.168.32.152/user /mnt/user[root@jiangpesi ~]# df -h文件系统               容量  已用  可用 已用% 挂载点/dev/mapper/cl-root     17G  2.0G   15G   12% /devtmpfs               478M     0  478M    0% /devtmpfs                  489M     0  489M    0% /dev/shmtmpfs                  489M  6.7M  482M    2% /runtmpfs                  489M     0  489M    0% /sys/fs/cgroup/dev/sda1             1014M  139M  876M   14% /boottmpfs                   98M     0   98M    0% /run/user/0//192.168.32.152/user   17G  2.3G   15G   14% /mnt/user</code></pre><p>4.挂载后使用<br>客户端创建文件：</p><pre><code>[root@jiangpesi ~]# cd /mnt/user/[root@jiangpesi user]# touch b[root@jiangpesi user]# ll总用量 0drwxr-xr-x. 2 1000 1000 0 4月  13 23:23 a-rw-r--r--. 1 1000 1000 0 4月  13 23:37 b</code></pre><p>服务端查看：</p><pre><code>[root@jiangpeisi userdir]# ll总用量 0drwxr-xr-x 2 user user 6 4月  13 23:23 a-rw-r--r-- 1 user user 0 4月  13 23:37 b</code></pre><p><strong>windows测试：</strong><br>1.客户端登陆<br><img src="http://static.zybuluo.com/jiangpeisi/svkc6sapn28tdhs7loga26zo/image_1d8cqg1u213hqrkb1a6q13k3f5u2m.png" alt="image_1d8cqg1u213hqrkb1a6q13k3f5u2m.png-14.6kB"><br>注意是斜杠（\）反斜杠不是（/）windows和linux路径分割符不同。<br><img src="http://static.zybuluo.com/jiangpeisi/l8q0r642sf6h6m6dkib14x8j/image_1d8cqgahn1an61bth4oijghv7q33.png" alt="image_1d8cqgahn1an61bth4oijghv7q33.png-59.6kB"><br>2.创建文件<br><img src="http://static.zybuluo.com/jiangpeisi/13qphizsscfw3nqqzwqrslii/image_1d8cqgnsdlcb9gt1b3c1rqhs5a3g.png" alt="image_1d8cqgnsdlcb9gt1b3c1rqhs5a3g.png-63.4kB"><br>3.编辑文件<br><img src="http://static.zybuluo.com/jiangpeisi/8bzp7a2b3dsuzzmbcg1nutr4/image_1d8cqhc3ab037pi7soav510om3t.png" alt="image_1d8cqhc3ab037pi7soav510om3t.png-17kB"><br>4.服务器查看</p><pre><code>[root@jiangpeisi userdir]# ll总用量 4drwxr-xr-x 2 user user 6 4月  13 23:23 a-rw-r--r-- 1 user user 0 4月  13 23:37 b-rwxr--r-- 1 user user 9 4月  13 23:45 新建文本文档.txt[root@jiangpeisi userdir]# cat 新建文本文档.txt 测试[root@jiangpeisi userdir]# </code></pre><p><strong>windows添加网络位置</strong><br>1.在设备和驱动区域点击右键<br><img src="http://static.zybuluo.com/jiangpeisi/d6eiltifdjt9orqb9yc9wwy0/image_1d8cqme6g12291vv960alljvvl57.png" alt="image_1d8cqme6g12291vv960alljvvl57.png-44.7kB"><br>2.添加服务器共享目录位置<br><img src="http://static.zybuluo.com/jiangpeisi/3574y2ngg1759rsu1q9de6bl/image_1d8cqn2to142t1u2sjdd1sl91lj95k.png" alt="image_1d8cqn2to142t1u2sjdd1sl91lj95k.png-21.5kB"><br>3.添加完成<br><img src="http://static.zybuluo.com/jiangpeisi/lniuvtp1kyt9pqthj6om68kn/image_1d8cqnd2g88br2k1kss1ua219o061.png" alt="image_1d8cqnd2g88br2k1kss1ua219o061.png-37.9kB"><br>添加完网络位置，samba共享目录就可以像本地windows本地目录一样使用了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;&lt;p&gt;在早期的网络世界中，档案数据在不同主机之间的传输大多是使用FTP服务，但是FTP服务传输档案有一些小小的问题，那就是我们无法直接修改主机上面
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="Samba" scheme="http://yoursite.com/tags/Samba/"/>
    
  </entry>
  
  <entry>
    <title>NFS</title>
    <link href="http://yoursite.com/2019/04/13/NFS/"/>
    <id>http://yoursite.com/2019/04/13/NFS/</id>
    <published>2019-04-13T14:45:56.000Z</published>
    <updated>2019-04-13T16:31:01.301Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP/IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。NFS在文件传送或信息传送过程中依赖于RPC协议。</p><hr><h2 id="NFS与RPC的关系"><a href="#NFS与RPC的关系" class="headerlink" title="NFS与RPC的关系"></a>NFS与RPC的关系</h2><p>因为NFS支持的功能相当的多，而不同的功能都会使用不同的程序来启动，每启动一个功能就会启用多个端口来传输数据，因此，NFS的功能所对应的端口才没有固定住，而是随机取用一些未被使用的小于1024的端口用来传输。这样做就导致当客户端连接服务器时，不知道要连接哪个端口。</p><p>那RPC又是如何知道每个NFS的端口呢？这是因为当服务器在启动NFS时会随机取用多个端口口，并主动的向RPC注册，因此RPC可以知道每个端口对应的NFS功能，然后RPC又是固定使用端口号111来监听客户端的需求并回报客户端正确的端口。这样RPC就作为了一个中介代理，解决了客户端不知道该连接NFS服务端哪个端口的问题。</p><p>要启动NFS之前，要先启用RPC，否则NFS会无法向RPC注册。另外，RPC若重新启动时，原本注册的数据会不见，因此RPC重新启动后，它管理的所有服务都需要重新启动来重新向RPC注册。</p><p>当客户端有NFS档案存取需求时，他会如何向服务器端要求数据呢？<br>1.客户端会向服务器端的RPC端口（111) 发出NFS档案存取功能的询问要求；<br>2.服务器端找到对应的已注册的NFS 守护进程（daemon） 端口后，会回报给客户端；<br>3.客户端了解正确的端口口后，就可以直接连接NFS 守护进程端口了。</p><h2 id="配置实例"><a href="#配置实例" class="headerlink" title="配置实例"></a>配置实例</h2><p><strong>服务端</strong><br>1.安装nfs服务</p><pre><code>[root@jiangpeisi ~]# yum -y install nfs-utils rpcbind</code></pre><p>RPC主程序：rpcbind ：完成端口注册<br>NFS主程序：nfs-utils：包含两个 rpc.nfsd 、rpc.mountd守护进程<br>2.创建共享目录</p><pre><code>[root@jiangpeisi ~]# mkdir /mnt/nfstest</code></pre><p>3.修改/etc/exports文件：控制NFS服务器要导出的共享目录以及访问控制。</p><pre><code>/mnt/nfstest    192.168.32.0/24(rw,sync)</code></pre><p>4./etc/port配置文件解析：</p><pre><code>共享目录    允许访问的主机（控制访问）</code></pre><ul><li>设置允许访问的主机：<br>使用具体IP地址<br>192.168.32.5<br>使用IP地址指定网段<br>192.168.32.0/24<br>192.168.32.0/255.255.255.0<br>192.168.32.<em><br>使用具体域名<br>Mirror.sh.com<br>使用通配符匹配域名内客户端</em>.sh.com<br>指定所有客户端</li><li><p>控制访问：<br>rw/ro：该目录分享的权限是可擦写 (read-write) 或只读 (read-only)，但最终能不能读写，还是与文件系统的 rwx 及身份有关。</p><p> sync/async：sync 代表数据会同步写入到内存与硬盘中，async 则代表数据会先暂存于内存当中，而非直接写入硬盘。</p><p> no_root_squash/root_squash：客户端使用 NFS 文件系统的账号若为 root 时，系统该如何判断这个账号的身份？预设的情况下，客户端 root 的身份会由 root_squash 的设定压缩成 nfsnobody， 如此对服务器的系统会较有保障。但如果你想要开放客户端使用 root 身份来操作服务器的文件系统，那么这里就得要开 no_root_squash 才行！</p><p> all_squash：不论登入 NFS 的使用者身份为何， 他的身份都会被压缩成为匿名用户。</p><p> anonuid/anongid：anonuid 意指 anonymous (匿名者) 前面关于 *_squash 提到的匿名用户的 UID 设定值，通常为 nfsnobody，但是可以自行设定这个 UID，这个 UID 必需要存在于 /etc/passwd 当中！ anongid 设置匿名用户的GID。</p></li></ul><p>5.启动服务</p><pre><code>[root@jiangpeisi ~]# systemctl start rpcbind[root@jiangpeisi ~]# systemctl start nfs</code></pre><p>6.由于端口不固定无法放行固定端口，暂时防火墙关闭</p><pre><code>[root@jiangpeisi ~]# systemctl stop firewalld.service </code></pre><p><strong>客户端</strong><br>1.安装NFS主程序</p><pre><code>[root@jiangpesi ~]# yum install nfs-utils.x86_64 -y</code></pre><p>3.查看NFS服务器共享目录信息</p><pre><code>[root@jiangpeisi ~]# showmount -e 192.168.32.152Export list for 192.168.32.152:/mnt/nfstest 192.168.32.0/24</code></pre><p>4.挂载</p><pre><code>[root@jiangpesi ~]# mkdir /mnt/client[root@jiangpesi ~]# mount -t nfs 192.168.32.152:/mnt/nfstest /mnt/client/[root@jiangpesi client]# df -h文件系统                     容量  已用  可用 已用% 挂载点/dev/mapper/cl-root           17G  2.0G   16G   12% /devtmpfs                     478M     0  478M    0% /devtmpfs                        489M     0  489M    0% /dev/shmtmpfs                        489M  6.8M  482M    2% /runtmpfs                        489M     0  489M    0% /sys/fs/cgroup/dev/sda1                   1014M  139M  876M   14% /boottmpfs                         98M     0   98M    0% /run/user/0192.168.32.152:/mnt/nfstest   17G  2.2G   15G   13% /mnt/client</code></pre><p><strong>测试</strong><br>1.服务端创建文件</p><pre><code>[root@jiangpeisi nfstest]# touch a[root@jiangpeisi nfstest]# ll总用量 0-rw-r--r-- 1 root root 0 4月  12 11:07 a</code></pre><p>2.客户端查看</p><pre><code>[root@jiangpesi client]# ll总用量 0-rw-r--r--. 1 root root 0 4月  12 11:07 a</code></pre><p>3.服务端修改共享目录权限</p><pre><code>[root@jiangpeisi mnt]# chmod 777 nfstest/</code></pre><p>4.客户端创建文件</p><pre><code>[root@jiangpesi client]# touch b</code></pre><p>5.服务端查看</p><pre><code>[root@jiangpeisi nfstest]# ll总用量 0-rw-r--r-- 1 root      root      0 4月  12 11:07 a-rw-r--r-- 1 nfsnobody nfsnobody 0 4月  12 11:09 b</code></pre><p><strong>设置自动挂载</strong><br>设置自动挂载可以在不用到远程共享目录的时候自动卸载，在用到的时候自动挂载上远程目录。<br>1.安装工具包</p><pre><code>[root@jiangpesi ~]# yum install autofs.x86_64 -y</code></pre><p>2.修改配置文件</p><pre><code>[root@jiangpesi ~]# vim /etc/auto.master/mnt    /etc/auto.nfs[root@jiangpesi ~]# vim /etc/auto.nfs/client -fstype=nfs     192.168.32.152:/mnt/nfstest</code></pre><p>3.启用服务</p><pre><code>[root@jiangpesi ~]# systemctl start autofs.service </code></pre><p>4.测试</p><pre><code>[root@jiangpesi mnt]# umount /mnt/client/[root@jiangpesi mnt]# df -h文件系统             容量  已用  可用 已用% 挂载点/dev/mapper/cl-root   17G  2.0G   16G   12% /devtmpfs             478M     0  478M    0% /devtmpfs                489M     0  489M    0% /dev/shmtmpfs                489M  6.8M  482M    2% /runtmpfs                489M     0  489M    0% /sys/fs/cgroup/dev/sda1           1014M  139M  876M   14% /boottmpfs                 98M     0   98M    0% /run/user/0[root@jiangpesi mnt]# cd client/[root@jiangpesi client]# df -h文件系统                     容量  已用  可用 已用% 挂载点/dev/mapper/cl-root           17G  2.0G   16G   12% /devtmpfs                     478M     0  478M    0% /devtmpfs                        489M     0  489M    0% /dev/shmtmpfs                        489M  6.8M  482M    2% /runtmpfs                        489M     0  489M    0% /sys/fs/cgroup/dev/sda1                   1014M  139M  876M   14% /boottmpfs                         98M     0   98M    0% /run/user/0192.168.32.152:/mnt/nfstest   17G  2.2G   15G   13% /mnt/client</code></pre><p><strong>NFS是支持设置固定端口的，方便防火墙的配置</strong><br>1.修改端口配置文件</p><pre><code>[root@jiangpeisi nfstest]# vim /etc/sysconfig/nfs </code></pre><p>2.修改注释行</p><pre><code>RQUOTAD_PORT=30001LOCKD_TCPPORT=30002LOCKD_UDPPORT=30002MOUNTD_PORT=30003STATD_PORT=30004   </code></pre><p>3.重启服务</p><pre><code>service nfs restart</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;&lt;p&gt;NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP/
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="NFS" scheme="http://yoursite.com/tags/NFS/"/>
    
  </entry>
  
  <entry>
    <title>IP sev VPN</title>
    <link href="http://yoursite.com/2019/04/11/IP%20sec%20VPN/"/>
    <id>http://yoursite.com/2019/04/11/IP sec VPN/</id>
    <published>2019-04-11T14:45:56.000Z</published>
    <updated>2019-04-11T05:13:05.615Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>IPSec本身不规定使用哪些算法，只提供框架，使用者可选择任一支持的算法，如果算法被破解，可随时更换。使用的参数如下： </p><p><1>散列函数：MD5，SHA1； </1></p><p><2>加密算法：DES，3DES，AES； </2></p><p><3>封装协议：AH，ESP； </3></p><p><4>封装模式：传输模式，隧道模式； </4></p><p><5>密钥有效期：60s~86400s；</5></p><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p><strong>四个特点：</strong><br>1.固定长度：MD5散列值128bit SHA-1散列值160bit<br>2.雪崩效应：数据有一点微小的改变都会使散列值差距变的很大<br>3.单向：只能通过原始数据得到散列值，不能逆推<br>4.冲突避免：即唯一性<br><strong>作用：</strong><br>1.验证数据完整性 将原始文件散列值和文件一同发送，接收方比较散列值<br>2.进行源认证  紧紧验证数据完整性是不足以保障安全，因此需要进行源认证，密钥化散列信息代码（HMAC）技术不仅可以检测完整性，还可以检测更新源。<br>HMAC实现方式，首先双方设置共享密码，然后将密码与数据一起进行散列计算得到散列值，然后与数据一起发送出去。</p><h2 id="加密算法："><a href="#加密算法：" class="headerlink" title="加密算法："></a>加密算法：</h2><p>1.对称密钥算法<br>2.非对称密钥算法<br><strong>对称密钥算法</strong><br>发送和接收双发有相同的密钥，发送发使用密钥进行加密，接收方使用密钥进行解密。<br>优点：速度快，安全，紧凑<br>缺点：明文传输共享密钥，容易被劫持；不支持数字签名和不可否认性。<br>对称算法中的主流协议：DES,3DES,AES,RC4..<br><strong>非对称密钥算法</strong><br>先使用非对称算法获得公钥和私钥，使用其中一个密钥进行加密时必须使用另一个密钥进行解密。发送方要先获取接收方的公钥，然后使用公钥进行加密，接收方在使用私钥进行解密。</p><p>非对称密钥可用于数字签名<br>步骤：首先对要认证的重要明文信息进行散列计算获得散列值，然后发送方使用自己的私钥进行加密，加密后的散列值称为数字签名。然后把明文和数字签名一起发送给对方。接收方加收到数据后提取其中的明文信息和数字签名，然后对明文进行散列计算得到散列值一，在用发送方的公钥解密数字签名得到散列值二对比两个散列值即可确认明文信息。保证了完整性和源认证。</p><p>特点：仅用于密钥交换（对密钥进行加密）和数字签名<br>优点：安全，支持数字签名和不可否认性<br>缺点：加密速度满，密文会边长一般仅用来加密密钥或者散列值</p><h2 id="封装协议："><a href="#封装协议：" class="headerlink" title="封装协议："></a>封装协议：</h2><p><strong>ESP （Encapsulation Security Payload）安全封装负载</strong><br>ESP仅能保护IP负载数据，不对原始IP头部进行保护<br>包格式<br><img src="http://static.zybuluo.com/jiangpeisi/ivevvy7m6n1dl3f1wsg4r4q8/image_1d856i1tr8b3u268dh95199a4d.png" alt="image_1d856i1tr8b3u268dh95199a4d.png-34.8kB"><br>ESP头部和尾部之间的数据会进行HMAC计算散列值，得到ESP验证数据</p><p><strong>AH（Authentication Header）头部认证</strong><br>IP 协议号为 51，只提供完整性校验和源认证两方面的安全服务，并且抵御重放攻击，不支持数据加密。<br>AH 对数据验证的范围更广，不仅包含原始数据，还包含了原始 IP 头部，AH 认证头部的名称就由此而得名。<br>缺点：不提供私密性服务，不可以进行加密，而且会对IP头部进行认证，导致数据包不可以经过NAT。使用较少。</p><h2 id="传输模式："><a href="#传输模式：" class="headerlink" title="传输模式："></a>传输模式：</h2><p>1.传输模式<br>2.隧道模式<br>传输模式即在IP头部和IP负载间插入ESP头部，再在尾部插入ESP尾部和ESP验证数据<img src="http://static.zybuluo.com/jiangpeisi/mfnshd4sm0rbkvddovfgvho2/image_1d856t0pe1dos1k2v1usv60j1jr361.png" alt="image_1d856t0pe1dos1k2v1usv60j1jr361.png-10.1kB"><br>隧道模式是在原始IP数据包封装在了一个新的IP包内，而且在新IP头（加密点IP）部和原始IP头部之间插入ESP头部，尾部加上ESP尾部和验证数据。<br><img src="http://static.zybuluo.com/jiangpeisi/r5j24kkk1j9bqggvb6k3cpxu/image_1d856tktj1o4h11s3igi1p83150n6h.png" alt="image_1d856tktj1o4h11s3igi1p83150n6h.png-14.3kB"></p><h2 id="密钥有效期："><a href="#密钥有效期：" class="headerlink" title="密钥有效期："></a>密钥有效期：</h2><p>长期使用一个密钥不安全，需要不断更新，新的密钥可由旧的密钥衍生。<br>完美向前保密：每次密钥更新都会重新生成一起密钥和前面的密钥无关</p><h2 id="互联网密钥交换协议-IKE（Internet-Key-Exchange）"><a href="#互联网密钥交换协议-IKE（Internet-Key-Exchange）" class="headerlink" title="互联网密钥交换协议 IKE（Internet Key Exchange）"></a>互联网密钥交换协议 IKE（Internet Key Exchange）</h2><p>对建立 IPSec的双方进行认证（需要预先协商认证方式），通过密钥交换，产生用于加密和 HMAC 的随机密钥，协商协议参数(加密协议、散列函数、封装协议、封装模式和密钥有效期)，协商完成后的结果就叫做安全关联(SA)。<br>SA 一共有两种类型：<br>IKE SA：安全防护(加密协议、散列函数、认证方式、密钥有效期等）协议的细节。<br>IPSec SA：安全防护实际用户流量（通信点之间流量）的细节。 </p><p><strong>三个模式两个阶段</strong><br><img src="http://static.zybuluo.com/jiangpeisi/46l4hj78wc6wbqeszdxbvlri/image_1d857513sun918et7661bcri7i7b.png" alt="image_1d857513sun918et7661bcri7i7b.png-45.4kB"><br><strong>第一阶段</strong><br>1.1-2个包交换<br>主要任务：<br>（1）通过核对收到的ISAKMP数据包的源IP地址，判断收到的ISAKMP数据包是否源自于合法对等体<br><img src="http://static.zybuluo.com/jiangpeisi/ai3rf5wdbqfab8nqv5aos8oh/image_1d8577qc87t1kmr1gmc1v0n5v77r.png" alt="image_1d8577qc87t1kmr1gmc1v0n5v77r.png-17.7kB"><br>（2）协商IKE策略<br><img src="http://static.zybuluo.com/jiangpeisi/8k1q3r5fca8f6xvpn5njpdbx/image_1d8578dgqcj88j0mcb1iss110o88.png" alt="image_1d8578dgqcj88j0mcb1iss110o88.png-71.4kB"><br>IKE协商策略包含内容：加密策略，散列函数，DH组，认证方式，密钥有效期。协商出来的策略主要用于第5-6个包交换认证和第二阶段QM模式3个包策略协商，并不用于加密感兴趣流。</p><p>2.3-4个包交换：<br><img src="http://static.zybuluo.com/jiangpeisi/1f548pq29h19besehjiayuh1/image_1d857jfa51lpli4ilfg1ps51s69bo.png" alt="image_1d857jfa51lpli4ilfg1ps51s69bo.png-105.1kB"><br>（1）发起方首先随机产生g、p、a，用离散对数函数计算得出A。<br>（2）把 g、p、A 发送给接收方。<br>（3）接收方收到后，随机产生b，使用接收到的g和p，用离散对数函数计算得到 B。<br>（4）然后把 B 回送给发起方。<br>（5）接收方通过 Ab mod p 得到的结果， 等于发起方通过 Ba mod p 计算得到的结果，也等于 gab mod p。<br>（6）通过 DH 算法得到了一个共享秘密 gab mod p。<br>（7）g和p较大时，已知a求A （8）CPU计算速度很快，已知A求a几乎不可能，g和p的由1-2包交换的DH组大小决定。<br>通过DH算法双方得到共享密钥，并通过密钥衍生算法得到加密和HMAC处理IKE信息的密钥，加密感兴趣流的密钥就是由共享密钥衍生而来。</p><p>3.5-6个包交换：<br><img src="http://static.zybuluo.com/jiangpeisi/klh5p62eqrmefo302cdk0yfu/image_1d8579o971tlfd0t15ik17jek4u95.png" alt="image_1d8579o971tlfd0t15ik17jek4u95.png-24.3kB"><br>主要任务就是认证，通过前四个包协商得到了IKE策略以及共享密钥，在此基础上进行认证<br>过程：<br>（1）发起方根据接收方IP地址查询本地IPSec配置,找到与其对应的预共享密钥。<br>（2）发起方把预共享秘密和 IKE策略内容、DH计算的密钥资源，还有其他一些接收双方都知道的内容一起进行散列计算，得到的结果就是“认证散列值”。<br>（3）发起方把“认证散列值”和本地加密点IP地址放入第5个IKE数据包中，加密后发送给接收方。<br>（4）接收方首先对收到的第5个IKE数据包进行解密，提取出发起方的IP地址，并且基于发起方的IP地址查询本地<br>IPSec配置，找出对应的预共享秘密。<br>（5）接收方把查询到的共享秘密，和其他双方已知内容一起进行计算散列值，得到“认证散列值”<br>（6）将自己的“认证散列值”与发送方发来的“认证散列值”进行比较，如果相等，接收方就认证了发起方，然后通过相同的方式发起第6个包给发送方，让发送方认证接收方。 </p><p>第一阶段主要任务就是协商策略，产生共享密钥，完成认证。完成认证后会建立一个双向的IKE/ISAKMP SA 安全关联，这个安全关联仅维护了处理IKE流量的相关策略，并不用于处理实际感兴趣流。后续的第二阶段就是在此安全关联的保护下进行。</p><p><strong>第二阶段</strong><br><img src="http://static.zybuluo.com/jiangpeisi/gfkb4hcxr8i3zu9vsvo4l3jg/image_1d857cb7r1iq79ne1hh6e41avba2.png" alt="image_1d857cb7r1iq79ne1hh6e41avba2.png-25.6kB"><br>主要任务就是在第一阶段得到的安全环境下，协商处理感兴趣流的IPsec策略<br>策略包含：<br>（1）感兴趣流<br>（2）加密策略<br>（3）散列函数<br>（4）封装协议<br>（5）封装模式<br>（6）密钥有效期<br><img src="http://static.zybuluo.com/jiangpeisi/mhjkly6apra4g6p5zksurmt7/image_1d857gv5ft6i1je7f0iem71f09af.png" alt="image_1d857gv5ft6i1je7f0iem71f09af.png-97.4kB"><br>第一个包：发起方会把感兴趣流相关得到IPsec策略一起发送给接收方，并由接收方来选择适当的策略，与主模式交换策略的方式相同，但是不同的是第一阶段协商完成后会建立一个双向的SA，现在只会建立单向的Ipsec SA，即接收方选择发送方的IP sec策略后用于处理接收方发送给发送方的流量，建立接收方到发送方的IP sec SA<br>第二个包：接收方使用发送方的IP sec策略处理流量（自己的IP sec策略）发送给发送方，发送方接收后选择一个IPsec策略来处理自己到发送方的流量，建立发送方到接收方的 Ipsev SA<br>第三个包：发送方使用接收方的IP sec策略处理流量（确认？）发送给接收方。IP sec SA建立完成。</p><p>第二阶段主要任务就是基于感兴趣流来协商相应的IP sec SA</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;&lt;p&gt;IPSec本身不规定使用哪些算法，只提供框架，使用者可选择任一支持的算法，如果算法被破解，可随时更换。使用的参数如下： &lt;/p&gt;
&lt;p&gt;&lt;1
      
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>MPLS VPN</title>
    <link href="http://yoursite.com/2019/04/10/MPLS%20VPN/"/>
    <id>http://yoursite.com/2019/04/10/MPLS VPN/</id>
    <published>2019-04-10T14:45:56.000Z</published>
    <updated>2019-04-11T00:46:20.041Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p><strong>MPLS VPN基本架构拓扑</strong><br><img src="http://static.zybuluo.com/jiangpeisi/nrg8w60xrd847bvaaf52geax/image_1d83uk98siqv159r174410e64h21j.png" alt="image_1d83uk98siqv159r174410e64h21j.png-75.1kB"></p><p>  在路由层面，客户A的站点1将到达本站点的路由信息通过MPLS VPN网络传递到远在另一个城市甚至另一个国家的站点2,反过来，站点2也是如此。对于客户而言，他们希望自己的站点路由在服务提供商的MPLS VPN网络内是不可见的，而且必须是独立传输、不会存在冲突的，他们不关心MPLS VPN骨干网络的具体形态。对于服务提供商而言，他们希望自己骨干网络内的传输设备能够专注于数据转发，而不参与客户路由的学习及交互，从而避免维护大规模路由表而导致设备负担过重。更重要是，MPLS VPN网络允许大量客户同时接入，且相互隔离。</p><p>在数据层面，当客户A的站点1将发往站点2的IP报文送入MPLS VPN骨干网络时，报文在MPLS VPN网络边界被压入标签头部，并最终被送达远端PE设备，再由该PE设备将其还原成IP报文后转发到该客户的站点2,显然，客户并不希望自己站点间相互通信的数据在MPLS VPN网络中被暴露，标签化的数据交互过程起到一定的安全作用，它使得共享式的MPLS VPN网络能够允许大量的客户同时接入，这些客户的数据不会在服务提供商的网络内出现冲突或者紊乱。</p><h2 id="四种典型设备"><a href="#四种典型设备" class="headerlink" title="四种典型设备"></a>四种典型设备</h2><p>PE（Provider Edge）设备：服务供应商边缘设备，一方接入MPLS VPN骨干网络P设备，另一方接入CE设备。用于客户两个站点间的路由信息交换。VRF（Virutual Routing and Forwarding）会部署在PE设备上来隔离不同客户路由。<br>P（Provider）设备：服务供应商设备，用于标签报文转发。<br>CE（Client Edge）设备：客户边界设备，一方连着PE设备，另一方连着C设备。用于将本区域内路由信息交给PE设备，并从PE设备学习远程站点的路由信息。一般与PE设备间启用动态路由协议来互相学习路由。<br>C（Client）设备：客户网络内部设备。</p><h2 id="六个问题了解MPLS-VPN"><a href="#六个问题了解MPLS-VPN" class="headerlink" title="六个问题了解MPLS VPN"></a>六个问题了解MPLS VPN</h2><p>  <strong>问题一</strong></p><p>多个CE设备连接一个PE设备，PE设备同时学习多个CE路由，PE设备如何区分不同CE设备发送过来的相同路由条目？<br><img src="http://static.zybuluo.com/jiangpeisi/iw2017qrqvpa2cxmd6jqmxlx/image_1d83us0061qsg1svv66dft5vdp3a.png" alt="image_1d83us0061qsg1svv66dft5vdp3a.png-93.9kB"><br><strong>答：</strong><br>使用VRF。VRF（Virtual Routing and Forwarding），主要用于区分不同客户端的路由条目，PE设备上会为每一个客户创建一个VRF专门用于存储从该客户学习来的路由条目，以此防止客户间路由发送冲突。一个VRF相当于一个虚拟设备，拥有独立的路由表，FIB表，动态路由协议进程。上例中PE设备会创建两个VRF分别存储客户A和客户B的路由。</p><hr><p> <strong>问题二</strong></p><p>PE1需要将客户A在站点1的路由发送给PE2，如何实现？<br><strong>答：</strong><br>使用BGP协议。在客户连接的两个PE设备间建立BGP对等体关系，让PE1与PE2直接交换客户的路由信息，中间P设备无需使用BGP协议。这样不仅做到了将PE1的路由信息发送给PE2，而且还可以让MPLS VPN骨干网络的设备不用维护客户的路由，仅专注于数据的转发。</p><hr><p> <strong>问题三</strong></p><p>VRF用于实现客户路由隔离并解决IP地址空间冲突的问题，但是一旦PE1设备将路由条目发送出去又会出现不同客户的路由信息混淆的问题，如何对BGP所运载的路由进行区分呢？<br><strong>答：</strong><br>使用RD（Route Distinguisher）路由区分码。对路由信息进行封装，在原IPv4（32bit）路由前缀的基础上增加一个RD（64bit），一起封装成为VPNv4（96bit）路由进行传输。例如：64519:100:172.16.18.0/24 其中172.16.18.0/24为IPv4地址，64519：100为RD值。</p><p>传统的BGP协议无法运载VPNv4路由，需要使用MP-BGP（Multi-Protolocal BGP），使得BGP可以运载VPNv4路由、IPv6路由等。</p><hr><p>现在解决了PE1从不同客户学习路由并且可以加以区分，以及怎样将路由信息发送到PE2。但是当路由到达PE2时，又出现了另一个问题，如何将路由信息区分，并放入不同的VRF?<br><img src="http://static.zybuluo.com/jiangpeisi/5dirh36m0mk1i7plmabcaxxq/image_1d83vbcsj66v1kt718ko1rfnfaa65.png" alt="image_1d83vbcsj66v1kt718ko1rfnfaa65.png-104.1kB"></p><hr><p> <strong>问题四</strong></p><p>PE2如何区分从PE1学习到的路由条目并放入相应的VRF？<br><strong>答：</strong><br>使用RT（32bit）（Route Target）路由目标。<br>Export RT：发送路由器上设置。在PE1上为客户A设置Export值为64519：1，为客户B设置Export值为64520：2，这样PE1在发送VPNv4路由的时候会将RT值作为扩展Community属性一起发送给PE2。<br>Inport RT：接收路由器上设置。在PE2上为客户A设置Import值为64519：1，为客户B设置Inport值为64520：2，与发送端对应。这样PE2将RT值为64519：1的路由放进客户A的VRF中，RT值为64520：2的路由放进客户B的VRF中。<br><img src="http://static.zybuluo.com/jiangpeisi/geiilzab4w78d2ate2r983w7/image_1d83vekbfeat16a9ackvu312d76v.png" alt="image_1d83vekbfeat16a9ackvu312d76v.png-224kB"></p><hr><p>到目前为止我们以及解决了路由信息的传递过程，但是由路由信息就一定可以传送数据吗？我们使用的是BGP协议，中间的P设备是不知道客户间路由的，所以一旦数据包发送出去，到了P设备就会被丢弃，因为P设备没有客户路由。貌似还查了一点，怎么让中间设备不管三层的目的地址，直接对数据包进行转发呢？一直在说MPLS VPN但是学到现在还没有使用到一点MPLS技术在里面，现在派上用场了。</p><hr><p> <strong>问题五</strong></p><p>如何让P设备在不知道目的地址的情况下对数据包进行转发？<br><strong>答：</strong><br>使用MPLS，让路由器根据标签转发数据。在MPLS VPN骨干网络设备上启用MPLS及LDP，并且在设备间建立LDP对等体关系，在此之前骨干区域要先实现互通。以PE1为例，PE2与各个P设备会为去往PE1的路由分配标签，并形成一条LSP，这样PE2的报文就可以沿着这条LSP传送到PE1。<br><img src="http://static.zybuluo.com/jiangpeisi/d3kddwg3yduqkcqozc07ejb2/image_1d83vhk7m77c4g01gvkdhp63786.png" alt="image_1d83vhk7m77c4g01gvkdhp63786.png-79.6kB"><br><img src="http://static.zybuluo.com/jiangpeisi/nmeoih1pasyicz1oaop6wg5u/image_1d83vhr2c149u1doi10vsdg1um18j.png" alt="image_1d83vhr2c149u1doi10vsdg1um18j.png-150.2kB"></p><hr><p>现在数据报文可以从PE2发送到PE1了，PE1收到报文后将标签弹出，然后将数据包进行转发。现在又出现了一个新的问题，因为数据包不是路由条目，路由条目可以根据扩展Community属性值发放到不同的VRF中，数据包不存在这个属性，所以PE1这时候又懵逼了，这个数据包该发送给客户A还是客户B？</p><hr><p><strong>问题六</strong></p><p>PE设备收到数据包后，如何区分，并转发到相应的VRF中去？<br><strong>答：</strong><br>采用多层标签。MPLS标签包标签头可以有多个，按顺序排序，存储在标签栈中。在数据包发送时，为数据包压入两层标签，一层是外层标签或者叫公网标签，由LDP分发，用于将报文在MPLS VPN骨干网络传输。另一层是内部标签，也叫私网标签，由MP-BGP分发，用于将报文在PE设备上对应到具体的VRF中。为了实现私网标签的分发，PE2通过MP-BGP将VPNv4路由通告给PE1时，除了携带了该路由的RT值，还会将为该路由所分配的私网标签一并携带。这样PE1在发送数据包到PE2时会给数据包打上双层标签，使用公网标签将数据包发送到PE2，出去外层标签后，由于私网标签时PE2自己设置的，所以PE2会根据内层标签决定将数据包对应到哪一个VRF，最后私网标签弹出，将正常的IP报文传输给客户A或者B。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面六个问题的探讨，大致可以了解经典MPLS VPN的工作机制。总结一下，一个经典的MPLS VPN实现需要实现哪些功能：<br>1.在PE设备上，使用VRF来区分不同客户、维护不同客户的路由<br>2.在PE设备上，基于VRF使用路由协议实现与CE间的路由信息交换<br>3.在MPLS VPN骨干网络内部需要运行IGP路由协议，并在此基础上运行MPLS和LDP协议。<br>4.在PE之间需要建立BGP对等体，使用RD值将IPv4路由封装成VPNv4路由，通过MP-BGP传递VPNv4路由。<br>5.在PE上需要为VRF设置RT值区分接收到的路由条目。<br>6.为数据包压入双层标签，让数据包技能穿越MPLS VPN骨干网络，然后转发到相应的VRF中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;MPLS VPN基本架构拓扑&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;http://static.zybuluo.com
      
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>MPLS</title>
    <link href="http://yoursite.com/2019/04/10/MPLS/"/>
    <id>http://yoursite.com/2019/04/10/MPLS/</id>
    <published>2019-04-10T14:45:56.000Z</published>
    <updated>2019-04-11T00:39:26.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>传统的IP路由基于报文的IP头部的目的IP地址进行寻址及转发操作，设备需要维护路由表用于指导数据转发，根据最长匹配原则进行匹配条目，速度慢，效率低。MPLS能够为IP报文添加标签信息，让路由器基于标签信息对报文进行转发，提高了数据转发的效率。后来随着硬件技术的突破，IP路由查询的执行效率已经大大提高，MPLS的速度提升优势已经不再明显。但是MPLS在其他方面有着较多的应用，例如MPLS VPN、流量工程等。</p><hr><h2 id="MPLS的典型应用"><a href="#MPLS的典型应用" class="headerlink" title="MPLS的典型应用"></a>MPLS的典型应用</h2><p>1.基于MPLS的VPN<br>2.基于MPLS的流量工程</p><h2 id="MPLS术语"><a href="#MPLS术语" class="headerlink" title="MPLS术语"></a>MPLS术语</h2><p>LSR（Labe Switch Router，标签转发路由器）：指的是激活了MPLS标签交换功能的路由器，这些路由器维护者用于知道标签报文转发的信息，并且依据这些信息对标签报文进行处理。</p><p>Ingress LSR（入站LSR）：主要用于对刚刚进入MPLS区域的报文进行处理，在报文的IP头部前插入标签头部生成标签报文。</p><p>Transit LSR（中转LSR）：主要对标签报文进行处理，对标签的置换操作。</p><p>Egress LSR（出站LSR）：主要用于对流出MPLS的报文进行处理，在标签报文离开前将标签头部移除，使标签报文变成正常的IP报文。</p><p>Label（标签）：一个正常IP数据包在进入MPLS区域时，会在二层头部和IP头部之间插入标签头部，标签指的是标签头部‘标签’字段的具体值。一个标签报文可能有多个标签头部，按一定的顺序排列，存储在标签栈中。</p><p>FEC（Forwarding Equivalence Class，等价转发类）：FEC是指具有相同特征的标签报文，这些报文在MPLS转发过程中采用相同的处理方式。FEC可以采用多种方式划分，例如目的地址、网络掩码、DSCP等特征。最为常见的是根据目的地址划分，到达同一目的地址的报文会被归为一类，并采用相同的方式来处理这些报文。</p><p>LSP（Label Switched Path，标签转发路径）：LSP是指报文在穿越MPLS区域内所经过的路径。一个数据报文在穿越MPLS区域之前，LSP就已经建立好，同一个FEC的报文采用相同的LSP穿越MPLS区域，并且LSP是单向的，所以如果想要双方互相通信，就需要在建立双向的LSP。</p><p>标.签分发协议：类似于路由协议。一个报文在穿越MPLS区域之前LSP必须要先建立。LSP的建立又分为两种方式：静态方式，动态方式。静态方式建立LSP需要在每一台LSP上为每一个FEC手工配置标签，然后手动指定LSP。动态方式就是采用标签分发协议来完成，自动为FEC分配标签并建立LSP。</p><h2 id="MPLS标签"><a href="#MPLS标签" class="headerlink" title="MPLS标签"></a>MPLS标签</h2><p> <strong>包格式</strong></p><p><img src="http://static.zybuluo.com/jiangpeisi/qlb93xefpgaj5u11e579hgzk/image_1d83shco61n9a1la81m1l1pf0121933.png" alt="image_1d83shco61n9a1la81m1l1pf0121933.png-62.5kB"></p><p><strong>四个字段</strong></p><p>Label：用于存储标签值<br>EXP：暂未表明用处<br>BoS：栈底位，为1表示本标签为栈底标签，后面就是IP头部，为0表示本标签并非栈底标签。<br>TTL：主要用于防环，防止标签被无限转发</p><h2 id="MPLS标签的基本操作"><a href="#MPLS标签的基本操作" class="headerlink" title="MPLS标签的基本操作"></a>MPLS标签的基本操作</h2><p>Push：二层头部和三层头部之间插入标签<br>Swap：在标签报文转发时，将标签头部换成下游LSR所分配标签，通常对栈顶的标签进行操作<br>Pop：当标签报文离开MPLS区域时将标签头部移除，在最后一跳节点，标签已经没有使用价值。这种情况下，可以利用倒数第二跳弹出特性PHP（Penultimate Hop Popping），在倒数第二跳节点处将标签弹出，减少最后一跳的负担。最后一跳节点直接进行IP转发或者下一层标签转发。</p><h2 id="MPLS转发过程"><a href="#MPLS转发过程" class="headerlink" title="MPLS转发过程"></a>MPLS转发过程</h2><p><strong>三张表</strong></p><p>FIB表<br><img src="http://static.zybuluo.com/jiangpeisi/wgwmgv68j6zt9uy0nys6retr/image_1d83sipnd1jr81rbkfql1dep1k8o3g.png" alt="image_1d83sipnd1jr81rbkfql1dep1k8o3g.png-22.6kB"><br>NHLFE表<br><img src="http://static.zybuluo.com/jiangpeisi/jn0tjnqkachvb6dlz02os12r/image_1d83sj0fdqdpt801ac33n81ij3t.png" alt="image_1d83sj0fdqdpt801ac33n81ij3t.png-45.6kB"><br>ILM表<br><img src="http://static.zybuluo.com/jiangpeisi/kyimxvcsrpbpyao0tavclnyh/image_1d83sjg4njqvvb100lc55a134a.png" alt="image_1d83sjg4njqvvb100lc55a134a.png-47.2kB"></p><p><strong>具体过程</strong></p><p>当IP报文进入MPLS域时，首先查看FIB表，检查目的IP地址对应的Tunnel ID值是否为0x0。<br>如果Tunnel ID值为0x0，则进入正常的IP转发流程。<br>如果Tunnel ID值不为0x0，则进入MPLS转发流程。</p><p>在MPLS转发过程中，FIB、ILM和NHLFE表项是通过Tunnel ID关联的。</p><p>IngressLSR的处理：通过查询FIB表和NHLFE表指导报文的转发。<br>查看FIB表，根据目的IP地址找到对应的Tunnel ID。<br>根据FIB表的Tunnel ID找到对应的NHLFE表项，将FIB表项和NHLFE表项关联起来。<br>查看NHLFE表项，可以得到出接口、下一跳、出标签和标签操作类型。<br>在IP报文中压入出标签，然后将封装好的MPLS报文发送给下一跳。</p><p>Transit LSR的处理：通过查询ILM表和NHLFE表指导MPLS报文的转发。<br>根据MPLS的标签值查看对应的ILM表，可以得到Tunnel ID。<br>根据ILM表的Tunnel ID找到对应的NHLFE表项。<br>查看NHLFE表项，可以得到出接口、下一跳、出标签和标签操作类型。</p><p>Egress LSR的处理：通过查询ILM表指导MPLS报文的转发或查询路由表指导IP报文的转发。<br>如果Egress收到IP报文，则查看路由表，进行IP转发。<br>如果Egress收到MPLS报文，则查看ILM表获得标签操作类型，一般为Pop。<br>如果操作为Pop需要结合BoS位指导报文转发，如果标签中的栈底标识BoS=1，表明该标签是栈底标签，直接进行IP转发。如果标签中的栈底标识BoS=0，表明还有下一层标签，继续进行下一层标签转发。</p><h2 id="LDP协议"><a href="#LDP协议" class="headerlink" title="LDP协议"></a>LDP协议</h2><p> <strong>工作过程</strong></p><p>开启LDP的路由器会自动为路由表中的FEC分配标签，并将标签映射发送给下游路由器，下游路由器接受收到标签映射后将映射存储起来，然后自己为该FEC分配标签，并传送给下游路由器，以此重复，完成LSP的建立。</p><p><strong>LDP ID</strong></p><p>每一台运行MPLS的LSR都会有一个域内唯一的LSR ID长度为32 位。需要手工指定，否则MPLS无法激活。<br>每一台运行了LDP的LSR必须拥有LDP ID长度位48位，有32位的LSR ID以及16位的 Label Space ID（标签空间标识符）构成。LDP ID= LSR ID:Label Space ID    1.1.1.1：0</p><p><strong>LDP对等体会话建立过程</strong></p><p>1.LDP设备发现<br>主要通过Hello报文，接口激活LDP后便开始发送Hello报文。报文中包含了LDP ID以及传输地址，采用UDP封装，以组播方式发送，目的IP为224.0.0.2，端口号为646 。当两个通过Hello包发现到彼此就开始建立会话。</p><p>2.LDP会话建立<br>上一步双方发现彼此后都知道了对方的传输地址，接下来开始建立会话。<br>（1）：一般传输地址大的开始主动发起TCP会话建立请求，完成三次握手过程。<br>（2）：传输地址大的一方会主动发送一个Initialization（初始化）包，包含一些协议参数，另一方接收到包后检查参数，发送自己的Initialization包和Keepalive包，主动方收到后便知道另一方接收了自己的参数，开始检查另一方的参数，如果认可就会送一个Keepalive包。<br>（3）：双发将LDP会话置为Operational状态，LDP对等体会话建立成功</p><p>3.通过标签映射<br>LDP对等体之间相互通过标签映射</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;&lt;p&gt;传统的IP路由基于报文的IP头部的目的IP地址进行寻址及转发操作，设备需要维护路由表用于指导数据转发，根据最长匹配原则进行匹配条目，速度慢，
      
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>安装新版python导致yum不可用</title>
    <link href="http://yoursite.com/2019/03/28/%E5%AE%89%E8%A3%85%E6%96%B0%E7%89%88python%E5%AF%BC%E8%87%B4yum%E4%B8%8D%E5%8F%AF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/03/28/安装新版python导致yum不可用/</id>
    <published>2019-03-28T14:45:56.000Z</published>
    <updated>2019-03-27T16:09:46.093Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题：</strong><br>安装完新版本python导致yum命令不可用.<br><strong>错误代码：</strong></p><pre><code>File &quot;/usr/bin/yum&quot;, line 30except KeyboardInterrupt, e:^SyntaxError: invalid syntax</code></pre><p><strong>问题原因：</strong><br>yum包管理是使用python2.x写的，将python2.x升级到python3.x以后，由于python版本语法兼容性导致问题出现 .<br><strong>解决办法：</strong><br>修改yum配置文件，将python指向老版本.</p><pre><code>vim /usr/bin/yum#!/usr/bin/python2.7vim /usr/libexec/urlgrabber-ext-down#!/usr/bin/python2.7</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;问题：&lt;/strong&gt;&lt;br&gt;安装完新版本python导致yum命令不可用.&lt;br&gt;&lt;strong&gt;错误代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;File &amp;quot;/usr/bin/yum&amp;quot;, line 30
except Ke
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Centos安装python3.7</title>
    <link href="http://yoursite.com/2019/03/28/python%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2019/03/28/python安装/</id>
    <published>2019-03-28T14:45:56.000Z</published>
    <updated>2019-03-27T16:19:06.274Z</updated>
    
    <content type="html"><![CDATA[<p><strong>简介</strong><br>Centos系统本身自带python2.7版本，使用python –version可以查看当前系统python版本，由于系统内某些命令会用到python2，所以python2不可以卸载.</p><hr><p><strong>安装</strong><br>1.由于是基于源码安装，首先需要安装gcc make</p><pre><code>yum -y install gcc  make</code></pre><p>2.安装依赖的软件包</p><pre><code>yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel</code></pre><p>3.下载源码压缩包<br><a href="https://www.python.org/ftp/python/" target="_blank" rel="noopener">官网下载</a></p><pre><code>wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz</code></pre><p>4.解压编译</p><pre><code>tar -zxvf Python-3.7.0.tgzcd Python-3.7.0./configure --prefix=/usr/local/python3make &amp;&amp; make install</code></pre><p>5.设置软连接或者环境变量<br>(1)删除旧的软连接并创建新的软连接</p><pre><code>rm -f /usr/bin/{python，pip}ln -s /usr/local/python3/bin/python3.7   /usr/bin/python3ln -s /usr/local/python3/bin/pip3.7 /usr/bin/pip</code></pre><p><img src="http://static.zybuluo.com/jiangpeisi/n25m8enf3ysp9snd9eezrsze/image_1d6vu31311fbmead1o9l167m10gn34.png" alt="image_1d6vu31311fbmead1o9l167m10gn34.png-20.4kB"><br>修改完连接可能会造成yum不可用，<a href="https://jiangpeisi.github.io/2019/03/28/%E5%AE%89%E8%A3%85%E6%96%B0%E7%89%88python%E5%AF%BC%E8%87%B4yum%E4%B8%8D%E5%8F%AF%E7%94%A8/#more" target="_blank" rel="noopener">查看此处</a><br>(2)设置环境变量</p><pre><code>export PATH=&quot;$PATH:/usr/local/python3/bin/python3.7&quot;</code></pre><p>（3）两者选择一种就可以，前者直接使用python启用python解释器，后者需要使用python3启用python解释器。</p><p>6.查看python版本</p><pre><code>python --version</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;br&gt;Centos系统本身自带python2.7版本，使用python –version可以查看当前系统python版本，由于系统内某些命令会用到python2，所以python2不可以卸载.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习之数组</title>
    <link href="http://yoursite.com/2019/03/23/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2019/03/23/shell脚本学习之数组/</id>
    <published>2019-03-23T14:45:56.000Z</published>
    <updated>2019-03-23T06:15:59.660Z</updated>
    
    <content type="html"><![CDATA[<p><strong>数组定义</strong><br>方法一：</p><pre><code>array_name=(value0 value1 value2 value3)</code></pre><p>方法二：</p><pre><code>array_name[0]=value0array_name[1]=value1array_name[2]=value2</code></pre><p>方法三：</p><pre><code>array_name=(            value0            value1            value2            value3)</code></pre><p><strong>数组的引用</strong><br>1.<code>${array_name[n]}</code>  获取数组第n+1个元素<br>2.<code>${array_name[@]}</code>  获取数组所有的元素<br>3.<code>${array_name[*]}</code>  获取数组所有的元素<br>4.<code>${#array_name[n]}</code>  获取数组第n+1个元素的长度<br>5.<code>${#array_name[@]}</code>  获取数组元素个数<br>6.<code>unset array[n]</code>   删除第n+1个元素<br>7.<code>unset array</code>   删除数组<br><strong>数组的替换</strong><br>方法一：不改变原数组<code>{arrary[@]/old/new}</code></p><pre><code>[root@jiangpeisi shell]# echo ${array1[@]/php/lua}lua c++ python java[root@jiangpeisi shell]# array3=${array1[@]/php/lua}[root@jiangpeisi shell]# echo ${array3[@]}lua c++ python java</code></pre><p>方法二：改变原数组<code>array=（[1]=new1 [2]=new2 [3]=new3）</code>   </p><pre><code>[root@jiangpeisi shell]# array1=([1]=lua [2]=php)[root@jiangpeisi shell]# echo ${array1[@]}lua php</code></pre><p><strong>数组遍历</strong><br>方法一：通过元素遍历</p><pre><code>array1=(php c++ python java)for var in ${array1[@]};do    echo $vardone[root@jiangpeisi shell]# sh array.sh phpc++pythonjava</code></pre><p>方法二：通过下标遍历</p><pre><code>array1=(php c++ python java)for i in &quot;${!array1[@]}&quot;;do    printf &quot;${array1[$i]}\n&quot;done[root@jiangpeisi shell]# sh array.sh phpc++pythonjava</code></pre><p>方法三：使用while循环遍历数组</p><pre><code>array1=(php c++ python java)i=0while [ $i -lt ${#array1[@]} ]do    echo ${array1[$i]}    let i++done[root@jiangpeisi shell]# sh array.sh phpc++pythonJava</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;数组定义&lt;/strong&gt;&lt;br&gt;方法一：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;array_name=(value0 value1 value2 value3)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;方法二：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;array_name[0]=v
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>hexo渲染文章失败</title>
    <link href="http://yoursite.com/2019/03/23/hexo%E6%B8%B2%E6%9F%93%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/03/23/hexo渲染问题/</id>
    <published>2019-03-23T14:04:56.000Z</published>
    <updated>2019-03-23T06:39:40.737Z</updated>
    
    <content type="html"><![CDATA[<p><strong>简述</strong><br>今天写了一个新的笔记打算上传的博客上，结果在渲染博文的时候出现了一个错误。一个神奇的现象就是我如果删除这篇新的博文时，就可以渲染成功，添加新的博文就渲染失败。后来看了官网的文章才知道，是因为我的新博文内出现了一些无法识别的字符。例如不可见的零宽度字符、预保留字符。出现这种情况有两种可能性，一种是你的新页面/帖子，另一种是_config.yml。显然我的属于前者。</p><hr><p><strong>错误代码</strong></p><pre><code>jiang@jiang-PC MINGW64 /F/Myblog                                                                                           $ hexo g                                                                                                                   INFO  Start processing                                                                                                     FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html                    Template render error: (unknown path)                                                                                        Error: expected end of comment, got end of file                                                                              at Object._prettifyError (F:\Myblog\node_modules\nunjucks\src\lib.js:36:11)                                                at Template.render (F:\Myblog\node_modules\nunjucks\src\environment.js:526:21)                                             at Environment.renderString (F:\Myblog\node_modules\nunjucks\src\environment.js:364:17)                                    at Promise.fromCallback.cb (F:\Myblog\node_modules\hexo\lib\extend\tag.js:62:48)                                           at tryCatcher (F:\Myblog\node_modules\bluebird\js\release\util.js:16:23)                                                   at Function.Promise.fromNode.Promise.fromCallback (F:\Myblog\node_modules\bluebird\js\release\promise.js:180:30)           at Tag.render (F:\Myblog\node_modules\hexo\lib\extend\tag.js:62:18)                                                        at Object.onRenderEnd (F:\Myblog\node_modules\hexo\lib\hexo\post.js:282:20)                                                at Promise.then.then.result (F:\Myblog\node_modules\hexo\lib\hexo\render.js:65:19)                                         at tryCatcher (F:\Myblog\node_modules\bluebird\js\release\util.js:16:23)                                                   at Promise._settlePromiseFromHandler (F:\Myblog\node_modules\bluebird\js\release\promise.js:512:31)                        at Promise._settlePromise (F:\Myblog\node_modules\bluebird\js\release\promise.js:569:18)                                   at Promise._settlePromise0 (F:\Myblog\node_modules\bluebird\js\release\promise.js:614:10)                                  at Promise._settlePromises (F:\Myblog\node_modules\bluebird\js\release\promise.js:694:18)                                  at _drainQueueStep (F:\Myblog\node_modules\bluebird\js\release\async.js:138:12)                                            at _drainQueue (F:\Myblog\node_modules\bluebird\js\release\async.js:131:9)                                                 at Async._drainQueues (F:\Myblog\node_modules\bluebird\js\release\async.js:147:5)                                          at Immediate.Async.drainQueues (F:\Myblog\node_modules\bluebird\js\release\async.js:17:14)                                 at runCallback (timers.js:705:18)                                                                                          at tryOnImmediate (timers.js:676:5)                                                                                        at processImmediate (timers.js:658:5)     </code></pre><p><strong>问题原因</strong><br><img src="http://static.zybuluo.com/jiangpeisi/2c8thylc5u8rgj6cbznj580r/image_1d6kkaaka1ue91btk1v0f1npl1skbm.png" alt="image_1d6kkaaka1ue91btk1v0f1npl1skbm.png-23.5kB"></p><p><strong>解决办法</strong></p><p><img src="http://static.zybuluo.com/jiangpeisi/as1qheh918m50h356rbcs8e7/image_1d6kkbo3s128l1o632s0bml19ou1j.png" alt="image_1d6kkbo3s128l1o632s0bml19ou1j.png-17.4kB"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;简述&lt;/strong&gt;&lt;br&gt;今天写了一个新的笔记打算上传的博客上，结果在渲染博文的时候出现了一个错误。一个神奇的现象就是我如果删除这篇新的博文时，就可以渲染成功，添加新的博文就渲染失败。后来看了官网的文章才知道，是因为我的新博文内出现了一些无法识别的字符。
      
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习之正则表达式</title>
    <link href="http://yoursite.com/2019/03/22/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/03/22/shell脚本学习之正则表达式/</id>
    <published>2019-03-22T14:45:56.000Z</published>
    <updated>2019-03-22T03:25:09.084Z</updated>
    
    <content type="html"><![CDATA[<p><strong>简述</strong><br>正则表达式是对字符串（包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”））操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。正则表达式是一种文本模式，模式描述在搜索文本时要匹配的一个或多个字符串。</p><p><strong>正则表达式字符</strong></p><pre><code>\：将下一个字符标记符、或一个向后引用、或一个八进制转义符。例如，“\\n”匹配\n。“\n”匹配换行符。序列“\\”匹配“\”而“\(”则匹配“(”。即相当于多种编程语言中都有的“转义字符”的概念。^：匹配输入字行首。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。$：匹配输入行尾。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。*：匹配前面的子表达式任意次。例如，zo*能匹配“z”，也能匹配“zo”以及“zoo”。*等价于{0,}。+：匹配前面的子表达式一次或多次(大于等于1次）。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。?：匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”。?等价于{0,1}。{n}：n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。{n,}：n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。{n,m}：m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o为一组，后三个o为一组。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。?：当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少地匹配所搜索的字符串，而默认的贪婪模式则尽可能多地匹配所搜索的字符串。例如，对于字符串“oooo”，“o+”将尽可能多地匹配“o”，得到结果[“oooo”]，而“o+?”将尽可能少地匹配“o”，得到结果 [&apos;o&apos;, &apos;o&apos;, &apos;o&apos;, &apos;o&apos;].：匹配除“\n”和&quot;\r&quot;之外的任何单个字符。要匹配包括“\n”和&quot;\r&quot;在内的任何字符，请使用像“[\s\S]”的模式。(pattern)：匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\(”或“\)”。(?:pattern)：非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分时很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。(?=pattern)：非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。(?!pattern)：非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。(?&lt;=pattern)：非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。(?&lt;!patte_n)：非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。x|y：匹配x或y。例如，“z|food”能匹配“z”或“food”(此处请谨慎)。“[z|f]ood”则匹配“zood”或“food”。[xyz]：字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。[^xyz]：负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”任一字符。[a-z]：字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。注意:只有连字符在字符组内部时,并且出现在两个字符之间时,才能表示字符的范围; 如果出字符组的开头,则只能表示连字符本身[^a-z]：负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。\b：匹配一个单词的边界，也就是指单词和空格间的位置（即正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置，这里的\b就是匹配位置的）。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”；“\b1_”可以匹配“1_23”中的“1_”，但不能匹配“21_3”中的“1_”。\B：匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。\cx：匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。\d：匹配一个数字字符。等价于[0-9]。grep 要加上-P，perl正则支持\D：匹配一个非数字字符。等价于[^0-9]。grep要加上-P，perl正则支持\f：匹配一个换页符。等价于\x0c和\cL。\n：匹配一个换行符。等价于\x0a和\cJ。\r：匹配一个回车符。等价于\x0d和\cM。\s：匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。\S：匹配任何可见字符。等价于[^ \f\n\r\t\v]。\t：匹配一个制表符。等价于\x09和\cI。\v：匹配一个垂直制表符。等价于\x0b和\cK。\w：匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的&quot;单词&quot;字符使用Unicode字符集。\W：匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。</code></pre><p><strong>实例</strong><br>匹配手机号码：<code>^1[3|4|5|7|8][0-9]{9}$</code><br>匹配IP地址：<code>[0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3}</code>   不准确<br>匹配电子邮箱：<code>/^[a-z\d]+(\.[a-z\d]+)*@([\da-z](-[\da-z])?)+(\.{1,2}[a-z]+)+$/</code><br>匹配URL：<code>/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/</code><br>匹配6-18位的密码：<code>/^[a-z0-9_-]{6,18}$/</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;简述&lt;/strong&gt;&lt;br&gt;正则表达式是对字符串（包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”））操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习之四剑客grep</title>
    <link href="http://yoursite.com/2019/03/22/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9B%9B%E5%89%91%E5%AE%A2grep/"/>
    <id>http://yoursite.com/2019/03/22/shell脚本学习之四剑客grep/</id>
    <published>2019-03-22T14:45:56.000Z</published>
    <updated>2019-03-22T03:43:06.363Z</updated>
    
    <content type="html"><![CDATA[<p><strong>简述</strong><br>grep是一种强大的文本搜索工具，与正则表达式配合搜索文本，并把匹配的行打印出来。</p><hr><p><strong>语句格式：</strong></p><pre><code>grep -options ‘word’ filename</code></pre><p><strong>常用参数：</strong><br>-a：以文本文件方式搜索<br>-c：计算找到的符合行的次数<br>-i：忽略大小写<br>-n：顺便输出行号<br>-v：反向选择，输出不包含匹配的所有行<br>-h：查询多文件时不现实文件名<br>-l：查询多文件时，只输出包含匹配字符的文件名<br>-s：不显示不存在或无匹配文本的错误信息<br>-E：使用egrep扩展匹配模式<br>– color：指定匹配输出字符的颜色<br><strong>正则表达式</strong><br><a href="https://jiangpeisi.github.io/2019/03/22/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" target="_blank" rel="noopener">点这里</a><br><strong>实例</strong></p><pre><code>[root@jiangpeisi shell]# cat a.txt | grep &apos;^m.*l$&apos; mysql[root@jiangpeisi shell]# cat a.txt | grep -E &quot;\&lt;([0-9]{1,3}\.){3}([0-9]{1,3})\&gt;&quot; 192.168.32.1[root@jiangpeisi shell]# cat a.txt | grep -c  &apos;^m.*l$&apos; 1[root@jiangpeisi shell]# cat a.txt | grep  -n &apos;^m.*l$&apos; 2:mysql[root@jiangpeisi shell]# cat a.txt | grep  -i -n  &apos;^M.*l$&apos; 2:mysql[root@jiangpeisi shell]# netstat -ntlp | grep namedtcp        0      0 172.17.0.1:53           0.0.0.0:*               LISTEN      3585/named          tcp        0      0 172.16.30.80:53         0.0.0.0:*               LISTEN      3585/named          tcp        0      0 127.0.0.1:53            0.0.0.0:*               LISTEN      3585/named          tcp        0      0 127.0.0.1:953           0.0.0.0:*               LISTEN      3585/named  </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;简述&lt;/strong&gt;&lt;br&gt;grep是一种强大的文本搜索工具，与正则表达式配合搜索文本，并把匹配的行打印出来。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;语句格式：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grep -options ‘word’ f
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习之四剑客sed</title>
    <link href="http://yoursite.com/2019/03/21/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9B%9B%E5%89%91%E5%AE%A2sed/"/>
    <id>http://yoursite.com/2019/03/21/shell脚本学习之四剑客sed/</id>
    <published>2019-03-21T14:45:56.000Z</published>
    <updated>2019-03-21T06:25:04.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sed简介"><a href="#sed简介" class="headerlink" title="sed简介"></a>sed简介</h1><p>sed是一个非交互式文本编辑器，它可以对文本文件和标准输入进行编辑，标志输入可以来自键盘输入、文本重定向、字符串、变量、甚至来自于管道符。逐行处理内容，一次只处理一行内容。</p><h1 id="sed工作流程"><a href="#sed工作流程" class="headerlink" title="sed工作流程"></a>sed工作流程</h1><p>1、读新的一行到缓存空间（pattern space）<br>2、从指定的操作指令中依次取出指令执行，判断是否匹配缓存空间内容<br>3、如果不匹配则忽略后续的编辑命令，回到第2步继续取出下一条指令<br>4、如果匹配，则针对缓存的行执行后续的编辑命令；完成后，回到第2步继续取出下一条指令<br>5、当所有指令都应用之后，输出缓存行的内容；回到第1步继续读入下一行内容<br>6、当所有行都处理完之后，结束；<br>sed操作的所有数据都是pattern space缓存空间内的数据，原文件并没有发生该表。如果想保留sed操作后的数据，可以使用重定向符输出到新的文件中。或者使用- i参数更改原文件。</p><h1 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h1><h2 id="命令格式："><a href="#命令格式：" class="headerlink" title="命令格式："></a>命令格式：</h2><pre><code>sed  [options]  [commands]  filename;</code></pre><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><p>x：指定行号<br>x,y：指定从x行到y行<br>/pattern/：指定包含模式的行<br>/pattern/,n：指定包含模式的行到第n行<br>p：打印匹配行<br>n：读取下一个输入行，用下一个命令处理新的行<br>a：在匹配行后面新的一行追加内容<br>i：在匹配行前面新的一行插入内容<br>d：删除匹配的行<br>c：用指定内容替代匹配的内容，一般操作多行<br>s：用指定内容替代匹配的内容，一般替代具体单词</p><h2 id="常用参数实例"><a href="#常用参数实例" class="headerlink" title="常用参数实例"></a>常用参数实例</h2><p><strong>原文本</strong></p><pre><code>[root@jiangpeisi shell]# cat a.txt mysqlappachenginxredismemachedphppython</code></pre><p><strong>1.打印指定行内容</strong></p><pre><code>[root@jiangpeisi shell]# sed -n &apos;1,3p&apos; a.txt mysqlappachenginx</code></pre><p><strong>2.删除指定行</strong></p><pre><code>[root@jiangpeisi shell]# sed &apos;/php/,$d&apos; a.txt mysqlappachenginxredismemached</code></pre><p><strong>3.在指定行前后添加内容</strong></p><pre><code>[root@jiangpeisi shell]# sed &apos;$a java&apos; a.txt mysqlappachenginxredismemachedphppythonJava[root@jiangpeisi shell]# sed &apos;$i java&apos; a.txt mysqlappachenginxredismemachedphpjavaPython</code></pre><p><strong>4.替换指定内容</strong></p><pre><code>[root@jiangpeisi shell]# sed &apos;2,3c java&apos; a.txt mysqljavaredismemachedphppython</code></pre><p>[root@jiangpeisi shell]# sed ‘s/php/java/‘ a.txt </p><pre><code>mysqlappachenginxredismemachedjavapython</code></pre><p><strong>5.多个命令组合 使用；或者-e参数</strong></p><pre><code>[root@jiangpeisi shell]# sed -e &apos;$a java&apos; -e &apos;s/php/java/&apos; a.txt mysqlappachenginxredismemachedjavapythonjava[root@jiangpeisi shell]# sed &apos;/mysql/d ; s/php/java/&apos;  a.txt appachenginxredismemachedjavapython</code></pre><h2 id="进阶参数"><a href="#进阶参数" class="headerlink" title="进阶参数"></a>进阶参数</h2><p>N：将当前读入行的下一行读取到当前的模式空间<br><img src="http://static.zybuluo.com/jiangpeisi/kwppvxf1du6mj1c0w55iuulz/image_1d6fdc4i41r4rujbos01old5h23j.png" alt="image_1d6fdc4i41r4rujbos01old5h23j.png-2.5kB"><br>h：将模式缓存区的文本复制到保持缓冲区<br><img src="http://static.zybuluo.com/jiangpeisi/c0yf7m2q8chbvbixsh5qxii4/image_1d6fdcepm13br129vmfuh7615sm40.png" alt="image_1d6fdcepm13br129vmfuh7615sm40.png-3.4kB"><br>H：将模式缓冲区的文本追加到保持缓冲区<br><img src="http://static.zybuluo.com/jiangpeisi/hrya3jucdxeg5ayw8luxhiri/image_1d6fdcn2u1iiv3gllj7mats94d.png" alt="image_1d6fdcn2u1iiv3gllj7mats94d.png-3.4kB"><br>x：互换模式缓冲区和保持缓冲区的内容<br><img src="http://static.zybuluo.com/jiangpeisi/qu8oykohe71m6an3sipqvdms/image_1d6fdfb8cbj61u0a18rs1cfi5b470.png" alt="image_1d6fdfb8cbj61u0a18rs1cfi5b470.png-2.8kB"><br>g：将保持缓冲区的内容复制到模式缓冲区<br><img src="http://static.zybuluo.com/jiangpeisi/hlk49s1ai3igt6tviirme4xi/image_1d6fdfjoi1u9qgts1hqp4701doo7d.png" alt="image_1d6fdfjoi1u9qgts1hqp4701doo7d.png-3.3kB"><br>G：将保持缓冲区的内容追加到模式缓冲区<br><img src="http://static.zybuluo.com/jiangpeisi/479c4zr05uucdwqfijkfm2uj/image_1d6fdfom84pco1qehi1hvk1ua77q.png" alt="image_1d6fdfom84pco1qehi1hvk1ua77q.png-3.5kB"><br>两个缓冲空间pattern space与hold space。pattern space是一个临时缓冲区，用于保存当前读入的行信息，每处理完一行就会清除缓存内的信息，读取下一行。hold space 同样也是一个临时缓冲去，在处理行信息时，可以与pattern space之间进行互相拷贝。</p><h2 id="进阶参数实例"><a href="#进阶参数实例" class="headerlink" title="进阶参数实例"></a>进阶参数实例</h2><p><strong>1.在每一行后添加一个空行</strong></p><pre><code>[root@jiangpeisi shell]# sed &apos;/^ $/p;G&apos; a.txt mysqlappachenginxredismemachedphppython</code></pre><p><strong>2.将指定行的后一行与指定行合并为一行</strong></p><pre><code>[root@jiangpeisi shell]# sed  &apos;3N;s/\n/ /&apos; a.txt mysqlappachenginx redismemachedphppython</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sed简介&quot;&gt;&lt;a href=&quot;#sed简介&quot; class=&quot;headerlink&quot; title=&quot;sed简介&quot;&gt;&lt;/a&gt;sed简介&lt;/h1&gt;&lt;p&gt;sed是一个非交互式文本编辑器，它可以对文本文件和标准输入进行编辑，标志输入可以来自键盘输入、文本重定向、字符串、变
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习之四剑客awk</title>
    <link href="http://yoursite.com/2019/03/21/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9B%9B%E5%89%91%E5%AE%A2awk/"/>
    <id>http://yoursite.com/2019/03/21/shell脚本学习之四剑客awk/</id>
    <published>2019-03-21T14:45:56.000Z</published>
    <updated>2019-03-21T10:41:47.151Z</updated>
    
    <content type="html"><![CDATA[<p><strong>简述</strong><br>awk本身就是一种编程语言，它支持条件判断、循环、数组遍历等功能。我们可以使用它来对文本进行分析和处理。与sed相比，sed是逐行处理文本内数据，awk也是，不过awk又在此基础上实现对每一行每一列的操作。专业的角度来讲awk是一个报告生成器，因为awk可以对行和列进行操作，所以在awk命令下，一个文本就像是一个表格。默认列之间的分隔符是空格，行之间分隔符是\n，可以通过-F或者-v FS:指定分割符。</p><hr><p><strong>命令格式</strong></p><pre><code>awk &apos;{pattern + action}&apos; {filenames}</code></pre><p><strong>1.基本语法参数</strong><br>1.单引号‘’：为了和shell语法分开，防止混淆<br>2.大括号{}：用来表示一组命令<br>3.pattern：一个过滤器，表示匹配pattern的条件的行才可以执行action<br>4.pattern可以是以下任意一种<br>    -正则表达式：使用通配符匹配<br>    -关系表达式：使用关系运算符<br>    -模式匹配表达式：使用运算符~或者！~匹配<br>5.action：处理动作，一系列命令，常见的动作为print</p><p>实例：抓取IP地址</p><pre><code>[root@jiangpeisi ~]# ifconfig eth0 |awk  &apos;/inet/{print $2}&apos;172.16.30.80[root@jiangpeisi ~]# ifconfig eth0 | grep inet | awk &apos;{print $2}&apos;172.16.30.80[root@jiangpeisi ~]# ip addr | awk &apos;/eth0/&apos; | awk &apos;/inet/{print $2}&apos;172.16.30.80/18</code></pre><p><strong>2.内置参数</strong><br>FS：分隔符，默认是空格作为分隔符<br>OFS：输出行分隔符<br>NR：当前行数，从1开始<br>NF：当前行的字段（列）个数<br>$0：当前记录<br><code>$1~$n</code>：当前记录的第n个字段</p><p>实例：输出字段个数</p><pre><code>[root@jiangpeisi ~]# whoroot     pts/1        2019-03-21 11:14 (49.70.207.182)[root@jiangpeisi ~]# who | awk &apos;{print NF}&apos;5</code></pre><p>实例：打印奇数行的行号和第一列内容</p><pre><code>[root@jiangpeisi ~]# awk -F: &apos;NR%2==0{next}{print NR,$1}&apos; /etc/passwd1 root3 daemon5 lp7 shutdown9 mail11 games13 nobody15 systemd-network17 polkitd19 sshd21 chrony23 nscd25 admin27 dockerroot-latest29 test131 ftpuser133 dhcpd35 saslauth</code></pre><p><strong>3.内置函数</strong><br>1.gsub（r，s）：在$0中用s代替r<br>2.index（s，t）：返回s中t的第一个位置<br>3.length（s）：返回s的长度<br>4.match（s，r）：s是否匹配r<br>5.split（s，a，fs）：在fs上讲s分成序列a<br>6.substr（s，p）：返回s从p开始的子串</p><p>实例：输出字段长度</p><pre><code>[root@jiangpeisi ~]# whoroot     pts/1        2019-03-21 11:14 (49.70.207.182)[root@jiangpeisi ~]# who | awk &apos;{print length($2)}&apos;5</code></pre><p><strong>4.流程控制语句</strong><br>1.if（condition）{}else{}<br>2.while（condition）{}<br>3.for（init；condition；step）{}<br>4.Break/contitnue<br>实例：比较大小</p><pre><code>[root@jiangpeisi ~]# echo 2 3 |awk &apos;{if($1&gt;$2){print $1}else{print $2}}&apos;3[root@jiangpeisi ~]# echo 3 2 |awk &apos;{if($1&gt;$2){print $1}else{print $2}}&apos;3</code></pre><p><strong>补充</strong><br>使用awk可以对一个文件写一个脚本，格式：</p><pre><code>awk &apos;BEGIN{ commands } pattern{ commands } END{ commands }&apos; file </code></pre><p>执行顺序：<br>第一步： 执行BEGIN { commands } pattern 语句块中的语句，在对文件操作前执行<br>第二步：从文件或标准输入中读取一行，然后执行pattern{ commands }语句块。它逐行扫描文件，从第一行到最后一行重复这个过程，直到全部文件都被读取完毕。<br>第三步：当读至输入流末尾时，执行END { commands }语句块</p><p>实例：计算用户数量</p><pre><code>[root@jiangpeisi ~]# awk &apos;BEGIN {count=0;print &quot;[start] user count is &quot;,count} {;;count++} END{print &quot;[end] user count is &quot;,count}&apos; /etc/passwd[start] user count is  0[end] user count is  36</code></pre><p>实例：计算文件夹大小</p><pre><code>[root@jiangpeisi ~]# ls -lF /etc/ | awk &apos;BEGIN {sum=0}{sum+=$5}END{print &quot;The size of this dir is&quot;,sum/1024/1024,&quot;M&quot;}&apos;The size of this dir is 1.30004 M</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;简述&lt;/strong&gt;&lt;br&gt;awk本身就是一种编程语言，它支持条件判断、循环、数组遍历等功能。我们可以使用它来对文本进行分析和处理。与sed相比，sed是逐行处理文本内数据，awk也是，不过awk又在此基础上实现对每一行每一列的操作。专业的角度来讲awk是
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习之四剑客find</title>
    <link href="http://yoursite.com/2019/03/20/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9B%9B%E5%89%91%E5%AE%A2find/"/>
    <id>http://yoursite.com/2019/03/20/shell脚本学习之四剑客find/</id>
    <published>2019-03-20T14:45:56.000Z</published>
    <updated>2019-03-20T16:02:35.465Z</updated>
    
    <content type="html"><![CDATA[<p><strong>简述</strong><br>  find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。<br><strong>语句格式：</strong></p><pre><code>find path -option [ -print ] [ -exec -ok command ] {} \;-print ：表示find命令将匹配的文件输出到标准输出中，默认执行该命令-exec  ：表示find命令对匹配的文件执行该参数给出的shell命令。相应命令的形式为 cmd {} \;-ok      ：它的作用和-exec一样，只是需要用户交互，更安全</code></pre><p><strong>option参数说明：</strong></p><pre><code>-name ：按照文件名查找文件-perm  ：按照权限查找文件-prune ：使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略-user  ： 按照文件属主来查找文件-group  ：按照文件数组来查找文件-mtime -n +n  ：按照文件的更改时间来查找文件    -n ：表示从此刻算起，文件的更改是在n天以内    +n ：表示文件的更改时间是在n天以前-atime -n +n ： 按文件访问时间来查询-ctime -n +n ：按文件创建时间来查询 -nogroup  ：查找无有效属组的文件，即该文件所属的组在/etc/groups中不存在-nouser  :：查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在-newer file1 ！ file2  :查找更改时间比file1新但比file2旧的文件-type      b：表示块设备文件     block     d：表示目录         directory     c：表示字符设备文件   char     p：表示管道文件      pipe     l：表示符号链接文件   link     f：表示普通文件      file-depth ：在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找-fstype ：表示查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/etc/fstab中找到，该配置文件中包含了本系统中有关文件系统的信息-mount  ：表示在查找文件时不跨越文件系统的mount点-follow   ：表示如果find命令遇到符号链接文件，就跟踪至链接所指向的文件-cpio      ：表示对匹配的文件使用cpio命令，将这些文件备份至磁带设备中</code></pre><p><strong>实例：</strong><br>实例1：查找/root/shell目录下以.sh结尾 并且创建时间在1天以内的文件</p><pre><code>[root@jiangpeisi ~]# find /root/shell/ -name *.sh -ctime -1/root/shell/menu.sh/root/shell/apache-install.sh/root/shell/lnmp.sh/root/shell/select.sh/root/shell/sum.sh/root/shell/while.sh</code></pre><p>实例2：查找/root/shell目录下以.sh结尾 并且创建时间在1天以内的文件，并将文件移动到/opt/目录下</p><pre><code>[root@jiangpeisi ~]# find /root/shell/ -name *.sh -ctime -1 -exec mv {} /opt/ \; [root@jiangpeisi ~]# ll /opt/total 36-rw-r--r-- 1 root root  621 Mar 20 15:32 apache-install.sh-rw-r--r-- 1 root root   48 Mar 17 11:08 b.sh-rw-r--r-- 1 root root  303 Mar 18 11:28 e.sh-rw-r--r-- 1 root root  258 Mar 20 14:25 lnmp.sh-rw-r--r-- 1 root root  357 Mar 20 08:49 menu.shdrwxr-xr-x 2 root root 4096 Mar 15 15:41 nginx-rw-r--r-- 1 root root  138 Mar 20 14:12 select.sh-rw-r--r-- 1 root root   82 Mar 20 00:00 sum.sh-rw-r--r-- 1 root root   70 Mar 20 00:07 while.sh</code></pre><p>实例3：查找/data目录下以.log结尾，修改时间在1天以内，文件大小大于10M的文件，并将文件打包</p><pre><code>[root@jiangpeisi ~]# find /data/ -name *.log -ctime -1 -size +10k -exec tar -czPf /datacd/backup.tar.gz {} \;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;简述&lt;/strong&gt;&lt;br&gt;  find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。&lt;br&gt;&lt;str
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习之选择语句</title>
    <link href="http://yoursite.com/2019/03/20/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5/"/>
    <id>http://yoursite.com/2019/03/20/shell脚本学习之选择语句/</id>
    <published>2019-03-20T14:45:56.000Z</published>
    <updated>2019-03-20T14:50:35.384Z</updated>
    
    <content type="html"><![CDATA[<p><strong>case 语句格式：</strong></p><pre><code>case value in （表达式）pattern1)    command    ;;pattern2）    command    ;;*）   commandesac</code></pre><p><strong>实例：菜单选择</strong></p><pre><code>#!/bin/bashMenu=(beef,noodles,rice,juice)echo &quot;The menu is:&quot;for i in ${Menu[*]}do   echo  &quot;$i&quot;doneread -p &quot;Please choose one:&quot; foodcase $food in        beef)         echo &quot;You choose beef!&quot;        ;;        noodles)          echo &quot;You choose noodles!&quot;        ;;        rice)          echo &quot;You choose rice!&quot;        ;;        juice)          echo &quot;You choose juice!&quot;        ;;        *)          echo &quot;Don&apos;t have this one!&quot;        ;;esac[root@jiangpeisi shell]# sh menu.sh The menu is:beef,noodles,rice,juicePlease choose one:noodlesYou choose noodles!</code></pre><p><strong>select 语法格式：</strong></p><pre><code>select i in （表达式）do   commanddone</code></pre><p><strong>实例：测试服务状态</strong></p><pre><code>#!/bin/bashPS3=&quot;Please enter your select menu:&quot;select i in http php mysql quitdocase $i in        http)          echo &quot;Test http&apos;s state!&quot;        ;;        php)          echo &quot;Test php&apos;s state!&quot;        ;;        mysql)          echo &quot;Test mysql&apos;s state!&quot;        ;;        quit)          echo &quot;Exit!&quot;          exitesacdone[root@jiangpeisi shell]# sh lnmp.sh1) http2) php3) mysql4) quitPlease enter your select menu:1Test http&apos;s state!Please enter your select menu:2Test php&apos;s state!Please enter your select menu:3Test mysql&apos;s state!Please enter your select menu:4Exit!</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;case 语句格式：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;case value in （表达式）
pattern1)
    command
    ;;
pattern2）
    command
    ;;
*）
   command
es
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习之函数</title>
    <link href="http://yoursite.com/2019/03/20/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/03/20/shell脚本学习之函数/</id>
    <published>2019-03-20T14:45:56.000Z</published>
    <updated>2019-03-20T14:55:31.064Z</updated>
    
    <content type="html"><![CDATA[<p><strong>函数定义格式：</strong></p><pre><code>function name（）{command}</code></pre><p><strong>调用：</strong></p><pre><code>name argv1 argv2  </code></pre><p><strong>实例：安装Apache函数</strong></p><pre><code>#!/bin/bash#Auto install appache#By Auther jiangpeisiURL=http://mirrors.shu.edu.cn/apache//httpdFILE=httpd-2.4.38.tar.gzFILES_DIR=httpd-2.4.38PREFIX=/usr/local/apachefunction Apache_install(){if [ $1 -eq 1 ];then        yum install  openssl openssl-devel zlib zlib-devel gcc-c++ pcre pcre-devel -y &amp;&amp; cd /usr/local/src/ &amp;&amp; wget $URL/$FILE &amp;&amp; tar -xvf $FILE &amp;&amp; cd $FILES_DIR &amp;&amp; ./configure --prefix=$PREFIX  if [ $? -eq 0 ];then    make&amp;&amp;make install    echo &quot;The $FILES_DIR Server Install Sucess!&quot;    . /usr/local/apache/bin/httpd  else    echo &quot;The $FILES_DIR Server Install Fail!&quot;  fifi}Apache_install 1</code></pre><p><strong>测试：</strong></p><p><img src="http://static.zybuluo.com/jiangpeisi/369raax3bt02mth1v541lp5z/image_1d6dpfhvfkkohu3fk21gg8185116.png" alt="image_1d6dpfhvfkkohu3fk21gg8185116.png-23.1kB"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;函数定义格式：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function name（）
{
command
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;调用：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name argv1 argv2 
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习之if条件判断</title>
    <link href="http://yoursite.com/2019/03/19/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8Bif%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD/"/>
    <id>http://yoursite.com/2019/03/19/shell脚本学习之if条件判断/</id>
    <published>2019-03-19T14:45:56.000Z</published>
    <updated>2019-03-19T15:57:03.332Z</updated>
    
    <content type="html"><![CDATA[<p><strong>语句格式：</strong></p><pre><code>if(条件表达式)  commandelif(条件表达式)  commandelse  commandfi</code></pre><p><strong>if常见的判断逻辑运算符</strong></p><pre><code>-f: 判断文件是否存在,例如if[-f filename ]。-d: 判断目录是否存在,例如if[ -d dir]。-eq :等于,应用于整型比较,即equal.-ne:不等于,应用于整型比较,即not equal。-lt: 小于,应用于整型比较,即letter。-gt:大于,应用于整型比较,即greater。-le: 小于或等于,应用于整型比较。-ge: 大于或等于,应用于整型比较。-a:双方都成立(and) ,用法为逻辑表达式-a逻辑表达式-o:单方成立(or),用法为逻辑表达式-o逻辑表达式。-z:空字符串。||:单方成立。&amp;&amp;:双方都成立表达式。</code></pre><p><strong>实例：</strong><br>使用if条件判断分数</p><pre><code>#!/bin/bashscores=$1if [ $scores -eq 100 ]; then   echo &quot; very good!&quot; ;elif [ $scores -gt 85 ];then   echo &quot;good!&quot; ;elif [ $scores -gt 60 ];then   echo &quot; pass! &quot; ;elif [ $scores -lt 60 ]; then   echo &quot;no pass!&quot;;fi[root@jiangpeisi shell]# sh scores.sh 95good!</code></pre><p>判断网络主机状态</p><pre><code>#!/bin/bashping -c2 -W1 $1 &amp;&gt;/dev/nullif [ $? -eq 0 ];then  echo &quot;$1 is UP&quot;else  echo &quot;$1[root@jiangpeisi shell]# sh state.sh 192.168.32.2192.168.32.2 is DOWN</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;语句格式：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(条件表达式)
  command
elif(条件表达式)
  command
else
  command
fi
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;if常见的判断逻辑运算符&lt;/s
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习之循环语句</title>
    <link href="http://yoursite.com/2019/03/19/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"/>
    <id>http://yoursite.com/2019/03/19/shell脚本学习之循环语句/</id>
    <published>2019-03-19T14:45:56.000Z</published>
    <updated>2019-03-19T16:24:27.690Z</updated>
    
    <content type="html"><![CDATA[<p><strong>for循环语句格式</strong></p><pre><code>for var in （表达式）do    Commanddone</code></pre><p><strong>实例：计算1-100和</strong></p><pre><code>#!/bin/bashsum=0for i in `seq 1 100`do  sum=$(expr $sum + $i)doneecho $sum[root@jiangpeisi shell]# sh for.sh 5050</code></pre><p><strong>while循环语句格式</strong></p><pre><code>while（表达式）do    commanddone</code></pre><p><strong>实例：循环按行打印文件内容</strong></p><pre><code>#!/bin/bashwhile read linedo   echo $linedone &lt; /root/shell/a.txt[root@jiangpeisi shell]# sh while.sh lkitd:x:998:997:User for polkitd:/:/sbin/nologintss:x:59:59:Account used by the trousers package to sandbox the tcsd daemon:/dev/null:/sbin/nologinsshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologinpostfix:x:89:89::/var/spool/postfix:/sbin/nologinchrony:x:997:995::/var/lib/chrony:/sbin/nologinntp:x:38:38::/etc/ntp:/sbin/nologinnscd:x:28:28:NSCD Daemon:/:/sbin/nologintcpdump:x:72:72::/:/sbin/nologinadmin:x:1000:1000::/home/admin:/bin/bashdockerroot:x:996:993:Docker User:/var/lib/docker:/sbin/nologindockerroot-latest:x:995:992:Docker User:/var/lib/docker-latest:/sbin/nologinzarafa:x:994:991:Zarafa Service Account:/var/lib/zarafa:/sbin/nologintest1:x:1002:1002::/home/test1:/bin/bashjiangpeisi:x:1004:1004::/home/jiangpeisi:/bin/bashftpuser1:x:1005:1005::/home/ftpuser1:/bin/bashnamed:x:25:25:Named:/var/named:/bin/falsedhcpd:x:177:177:DHCP server:/:/sbin/nologinmysql:x:27:27:MariaDB Server:/var/lib/mysql:/sbin/nologinsaslauth:x:993:76:Saslauthd user:/run/saslauthd:/sbin/nologinapache:x:48:48:Apache:/usr/share/httpd:/sbin/nologin</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;for循环语句格式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for var in （表达式）
do
    Command
done
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;实例：计算1-100和&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;cod
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
</feed>
