<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我在看着你</title>
  
  <subtitle>by heart</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-11T00:46:20.041Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>镜子</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MPLS VPN</title>
    <link href="http://yoursite.com/2019/04/10/MPLS%20VPN/"/>
    <id>http://yoursite.com/2019/04/10/MPLS VPN/</id>
    <published>2019-04-10T14:45:56.000Z</published>
    <updated>2019-04-11T00:46:20.041Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p><strong>MPLS VPN基本架构拓扑</strong><br><img src="http://static.zybuluo.com/jiangpeisi/nrg8w60xrd847bvaaf52geax/image_1d83uk98siqv159r174410e64h21j.png" alt="image_1d83uk98siqv159r174410e64h21j.png-75.1kB"></p><p>  在路由层面，客户A的站点1将到达本站点的路由信息通过MPLS VPN网络传递到远在另一个城市甚至另一个国家的站点2,反过来，站点2也是如此。对于客户而言，他们希望自己的站点路由在服务提供商的MPLS VPN网络内是不可见的，而且必须是独立传输、不会存在冲突的，他们不关心MPLS VPN骨干网络的具体形态。对于服务提供商而言，他们希望自己骨干网络内的传输设备能够专注于数据转发，而不参与客户路由的学习及交互，从而避免维护大规模路由表而导致设备负担过重。更重要是，MPLS VPN网络允许大量客户同时接入，且相互隔离。</p><p>在数据层面，当客户A的站点1将发往站点2的IP报文送入MPLS VPN骨干网络时，报文在MPLS VPN网络边界被压入标签头部，并最终被送达远端PE设备，再由该PE设备将其还原成IP报文后转发到该客户的站点2,显然，客户并不希望自己站点间相互通信的数据在MPLS VPN网络中被暴露，标签化的数据交互过程起到一定的安全作用，它使得共享式的MPLS VPN网络能够允许大量的客户同时接入，这些客户的数据不会在服务提供商的网络内出现冲突或者紊乱。</p><h2 id="四种典型设备"><a href="#四种典型设备" class="headerlink" title="四种典型设备"></a>四种典型设备</h2><p>PE（Provider Edge）设备：服务供应商边缘设备，一方接入MPLS VPN骨干网络P设备，另一方接入CE设备。用于客户两个站点间的路由信息交换。VRF（Virutual Routing and Forwarding）会部署在PE设备上来隔离不同客户路由。<br>P（Provider）设备：服务供应商设备，用于标签报文转发。<br>CE（Client Edge）设备：客户边界设备，一方连着PE设备，另一方连着C设备。用于将本区域内路由信息交给PE设备，并从PE设备学习远程站点的路由信息。一般与PE设备间启用动态路由协议来互相学习路由。<br>C（Client）设备：客户网络内部设备。</p><h2 id="六个问题了解MPLS-VPN"><a href="#六个问题了解MPLS-VPN" class="headerlink" title="六个问题了解MPLS VPN"></a>六个问题了解MPLS VPN</h2><p>  <strong>问题一</strong></p><p>多个CE设备连接一个PE设备，PE设备同时学习多个CE路由，PE设备如何区分不同CE设备发送过来的相同路由条目？<br><img src="http://static.zybuluo.com/jiangpeisi/iw2017qrqvpa2cxmd6jqmxlx/image_1d83us0061qsg1svv66dft5vdp3a.png" alt="image_1d83us0061qsg1svv66dft5vdp3a.png-93.9kB"><br><strong>答：</strong><br>使用VRF。VRF（Virtual Routing and Forwarding），主要用于区分不同客户端的路由条目，PE设备上会为每一个客户创建一个VRF专门用于存储从该客户学习来的路由条目，以此防止客户间路由发送冲突。一个VRF相当于一个虚拟设备，拥有独立的路由表，FIB表，动态路由协议进程。上例中PE设备会创建两个VRF分别存储客户A和客户B的路由。</p><hr><p> <strong>问题二</strong></p><p>PE1需要将客户A在站点1的路由发送给PE2，如何实现？<br><strong>答：</strong><br>使用BGP协议。在客户连接的两个PE设备间建立BGP对等体关系，让PE1与PE2直接交换客户的路由信息，中间P设备无需使用BGP协议。这样不仅做到了将PE1的路由信息发送给PE2，而且还可以让MPLS VPN骨干网络的设备不用维护客户的路由，仅专注于数据的转发。</p><hr><p> <strong>问题三</strong></p><p>VRF用于实现客户路由隔离并解决IP地址空间冲突的问题，但是一旦PE1设备将路由条目发送出去又会出现不同客户的路由信息混淆的问题，如何对BGP所运载的路由进行区分呢？<br><strong>答：</strong><br>使用RD（Route Distinguisher）路由区分码。对路由信息进行封装，在原IPv4（32bit）路由前缀的基础上增加一个RD（64bit），一起封装成为VPNv4（96bit）路由进行传输。例如：64519:100:172.16.18.0/24 其中172.16.18.0/24为IPv4地址，64519：100为RD值。</p><p>传统的BGP协议无法运载VPNv4路由，需要使用MP-BGP（Multi-Protolocal BGP），使得BGP可以运载VPNv4路由、IPv6路由等。</p><hr><p>现在解决了PE1从不同客户学习路由并且可以加以区分，以及怎样将路由信息发送到PE2。但是当路由到达PE2时，又出现了另一个问题，如何将路由信息区分，并放入不同的VRF?<br><img src="http://static.zybuluo.com/jiangpeisi/5dirh36m0mk1i7plmabcaxxq/image_1d83vbcsj66v1kt718ko1rfnfaa65.png" alt="image_1d83vbcsj66v1kt718ko1rfnfaa65.png-104.1kB"></p><hr><p> <strong>问题四</strong></p><p>PE2如何区分从PE1学习到的路由条目并放入相应的VRF？<br><strong>答：</strong><br>使用RT（32bit）（Route Target）路由目标。<br>Export RT：发送路由器上设置。在PE1上为客户A设置Export值为64519：1，为客户B设置Export值为64520：2，这样PE1在发送VPNv4路由的时候会将RT值作为扩展Community属性一起发送给PE2。<br>Inport RT：接收路由器上设置。在PE2上为客户A设置Import值为64519：1，为客户B设置Inport值为64520：2，与发送端对应。这样PE2将RT值为64519：1的路由放进客户A的VRF中，RT值为64520：2的路由放进客户B的VRF中。<br><img src="http://static.zybuluo.com/jiangpeisi/geiilzab4w78d2ate2r983w7/image_1d83vekbfeat16a9ackvu312d76v.png" alt="image_1d83vekbfeat16a9ackvu312d76v.png-224kB"></p><hr><p>到目前为止我们以及解决了路由信息的传递过程，但是由路由信息就一定可以传送数据吗？我们使用的是BGP协议，中间的P设备是不知道客户间路由的，所以一旦数据包发送出去，到了P设备就会被丢弃，因为P设备没有客户路由。貌似还查了一点，怎么让中间设备不管三层的目的地址，直接对数据包进行转发呢？一直在说MPLS VPN但是学到现在还没有使用到一点MPLS技术在里面，现在派上用场了。</p><hr><p> <strong>问题五</strong></p><p>如何让P设备在不知道目的地址的情况下对数据包进行转发？<br><strong>答：</strong><br>使用MPLS，让路由器根据标签转发数据。在MPLS VPN骨干网络设备上启用MPLS及LDP，并且在设备间建立LDP对等体关系，在此之前骨干区域要先实现互通。以PE1为例，PE2与各个P设备会为去往PE1的路由分配标签，并形成一条LSP，这样PE2的报文就可以沿着这条LSP传送到PE1。<br><img src="http://static.zybuluo.com/jiangpeisi/d3kddwg3yduqkcqozc07ejb2/image_1d83vhk7m77c4g01gvkdhp63786.png" alt="image_1d83vhk7m77c4g01gvkdhp63786.png-79.6kB"><br><img src="http://static.zybuluo.com/jiangpeisi/nmeoih1pasyicz1oaop6wg5u/image_1d83vhr2c149u1doi10vsdg1um18j.png" alt="image_1d83vhr2c149u1doi10vsdg1um18j.png-150.2kB"></p><hr><p>现在数据报文可以从PE2发送到PE1了，PE1收到报文后将标签弹出，然后将数据包进行转发。现在又出现了一个新的问题，因为数据包不是路由条目，路由条目可以根据扩展Community属性值发放到不同的VRF中，数据包不存在这个属性，所以PE1这时候又懵逼了，这个数据包该发送给客户A还是客户B？</p><hr><p><strong>问题六</strong></p><p>PE设备收到数据包后，如何区分，并转发到相应的VRF中去？<br><strong>答：</strong><br>采用多层标签。MPLS标签包标签头可以有多个，按顺序排序，存储在标签栈中。在数据包发送时，为数据包压入两层标签，一层是外层标签或者叫公网标签，由LDP分发，用于将报文在MPLS VPN骨干网络传输。另一层是内部标签，也叫私网标签，由MP-BGP分发，用于将报文在PE设备上对应到具体的VRF中。为了实现私网标签的分发，PE2通过MP-BGP将VPNv4路由通告给PE1时，除了携带了该路由的RT值，还会将为该路由所分配的私网标签一并携带。这样PE1在发送数据包到PE2时会给数据包打上双层标签，使用公网标签将数据包发送到PE2，出去外层标签后，由于私网标签时PE2自己设置的，所以PE2会根据内层标签决定将数据包对应到哪一个VRF，最后私网标签弹出，将正常的IP报文传输给客户A或者B。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面六个问题的探讨，大致可以了解经典MPLS VPN的工作机制。总结一下，一个经典的MPLS VPN实现需要实现哪些功能：<br>1.在PE设备上，使用VRF来区分不同客户、维护不同客户的路由<br>2.在PE设备上，基于VRF使用路由协议实现与CE间的路由信息交换<br>3.在MPLS VPN骨干网络内部需要运行IGP路由协议，并在此基础上运行MPLS和LDP协议。<br>4.在PE之间需要建立BGP对等体，使用RD值将IPv4路由封装成VPNv4路由，通过MP-BGP传递VPNv4路由。<br>5.在PE上需要为VRF设置RT值区分接收到的路由条目。<br>6.为数据包压入双层标签，让数据包技能穿越MPLS VPN骨干网络，然后转发到相应的VRF中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;MPLS VPN基本架构拓扑&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;http://static.zybuluo.com
      
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>MPLS</title>
    <link href="http://yoursite.com/2019/04/10/MPLS/"/>
    <id>http://yoursite.com/2019/04/10/MPLS/</id>
    <published>2019-04-10T14:45:56.000Z</published>
    <updated>2019-04-11T00:39:26.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>传统的IP路由基于报文的IP头部的目的IP地址进行寻址及转发操作，设备需要维护路由表用于指导数据转发，根据最长匹配原则进行匹配条目，速度慢，效率低。MPLS能够为IP报文添加标签信息，让路由器基于标签信息对报文进行转发，提高了数据转发的效率。后来随着硬件技术的突破，IP路由查询的执行效率已经大大提高，MPLS的速度提升优势已经不再明显。但是MPLS在其他方面有着较多的应用，例如MPLS VPN、流量工程等。</p><hr><h2 id="MPLS的典型应用"><a href="#MPLS的典型应用" class="headerlink" title="MPLS的典型应用"></a>MPLS的典型应用</h2><p>1.基于MPLS的VPN<br>2.基于MPLS的流量工程</p><h2 id="MPLS术语"><a href="#MPLS术语" class="headerlink" title="MPLS术语"></a>MPLS术语</h2><p>LSR（Labe Switch Router，标签转发路由器）：指的是激活了MPLS标签交换功能的路由器，这些路由器维护者用于知道标签报文转发的信息，并且依据这些信息对标签报文进行处理。</p><p>Ingress LSR（入站LSR）：主要用于对刚刚进入MPLS区域的报文进行处理，在报文的IP头部前插入标签头部生成标签报文。</p><p>Transit LSR（中转LSR）：主要对标签报文进行处理，对标签的置换操作。</p><p>Egress LSR（出站LSR）：主要用于对流出MPLS的报文进行处理，在标签报文离开前将标签头部移除，使标签报文变成正常的IP报文。</p><p>Label（标签）：一个正常IP数据包在进入MPLS区域时，会在二层头部和IP头部之间插入标签头部，标签指的是标签头部‘标签’字段的具体值。一个标签报文可能有多个标签头部，按一定的顺序排列，存储在标签栈中。</p><p>FEC（Forwarding Equivalence Class，等价转发类）：FEC是指具有相同特征的标签报文，这些报文在MPLS转发过程中采用相同的处理方式。FEC可以采用多种方式划分，例如目的地址、网络掩码、DSCP等特征。最为常见的是根据目的地址划分，到达同一目的地址的报文会被归为一类，并采用相同的方式来处理这些报文。</p><p>LSP（Label Switched Path，标签转发路径）：LSP是指报文在穿越MPLS区域内所经过的路径。一个数据报文在穿越MPLS区域之前，LSP就已经建立好，同一个FEC的报文采用相同的LSP穿越MPLS区域，并且LSP是单向的，所以如果想要双方互相通信，就需要在建立双向的LSP。</p><p>标.签分发协议：类似于路由协议。一个报文在穿越MPLS区域之前LSP必须要先建立。LSP的建立又分为两种方式：静态方式，动态方式。静态方式建立LSP需要在每一台LSP上为每一个FEC手工配置标签，然后手动指定LSP。动态方式就是采用标签分发协议来完成，自动为FEC分配标签并建立LSP。</p><h2 id="MPLS标签"><a href="#MPLS标签" class="headerlink" title="MPLS标签"></a>MPLS标签</h2><p> <strong>包格式</strong></p><p><img src="http://static.zybuluo.com/jiangpeisi/qlb93xefpgaj5u11e579hgzk/image_1d83shco61n9a1la81m1l1pf0121933.png" alt="image_1d83shco61n9a1la81m1l1pf0121933.png-62.5kB"></p><p><strong>四个字段</strong></p><p>Label：用于存储标签值<br>EXP：暂未表明用处<br>BoS：栈底位，为1表示本标签为栈底标签，后面就是IP头部，为0表示本标签并非栈底标签。<br>TTL：主要用于防环，防止标签被无限转发</p><h2 id="MPLS标签的基本操作"><a href="#MPLS标签的基本操作" class="headerlink" title="MPLS标签的基本操作"></a>MPLS标签的基本操作</h2><p>Push：二层头部和三层头部之间插入标签<br>Swap：在标签报文转发时，将标签头部换成下游LSR所分配标签，通常对栈顶的标签进行操作<br>Pop：当标签报文离开MPLS区域时将标签头部移除，在最后一跳节点，标签已经没有使用价值。这种情况下，可以利用倒数第二跳弹出特性PHP（Penultimate Hop Popping），在倒数第二跳节点处将标签弹出，减少最后一跳的负担。最后一跳节点直接进行IP转发或者下一层标签转发。</p><h2 id="MPLS转发过程"><a href="#MPLS转发过程" class="headerlink" title="MPLS转发过程"></a>MPLS转发过程</h2><p><strong>三张表</strong></p><p>FIB表<br><img src="http://static.zybuluo.com/jiangpeisi/wgwmgv68j6zt9uy0nys6retr/image_1d83sipnd1jr81rbkfql1dep1k8o3g.png" alt="image_1d83sipnd1jr81rbkfql1dep1k8o3g.png-22.6kB"><br>NHLFE表<br><img src="http://static.zybuluo.com/jiangpeisi/jn0tjnqkachvb6dlz02os12r/image_1d83sj0fdqdpt801ac33n81ij3t.png" alt="image_1d83sj0fdqdpt801ac33n81ij3t.png-45.6kB"><br>ILM表<br><img src="http://static.zybuluo.com/jiangpeisi/kyimxvcsrpbpyao0tavclnyh/image_1d83sjg4njqvvb100lc55a134a.png" alt="image_1d83sjg4njqvvb100lc55a134a.png-47.2kB"></p><p><strong>具体过程</strong></p><p>当IP报文进入MPLS域时，首先查看FIB表，检查目的IP地址对应的Tunnel ID值是否为0x0。<br>如果Tunnel ID值为0x0，则进入正常的IP转发流程。<br>如果Tunnel ID值不为0x0，则进入MPLS转发流程。</p><p>在MPLS转发过程中，FIB、ILM和NHLFE表项是通过Tunnel ID关联的。</p><p>IngressLSR的处理：通过查询FIB表和NHLFE表指导报文的转发。<br>查看FIB表，根据目的IP地址找到对应的Tunnel ID。<br>根据FIB表的Tunnel ID找到对应的NHLFE表项，将FIB表项和NHLFE表项关联起来。<br>查看NHLFE表项，可以得到出接口、下一跳、出标签和标签操作类型。<br>在IP报文中压入出标签，然后将封装好的MPLS报文发送给下一跳。</p><p>Transit LSR的处理：通过查询ILM表和NHLFE表指导MPLS报文的转发。<br>根据MPLS的标签值查看对应的ILM表，可以得到Tunnel ID。<br>根据ILM表的Tunnel ID找到对应的NHLFE表项。<br>查看NHLFE表项，可以得到出接口、下一跳、出标签和标签操作类型。</p><p>Egress LSR的处理：通过查询ILM表指导MPLS报文的转发或查询路由表指导IP报文的转发。<br>如果Egress收到IP报文，则查看路由表，进行IP转发。<br>如果Egress收到MPLS报文，则查看ILM表获得标签操作类型，一般为Pop。<br>如果操作为Pop需要结合BoS位指导报文转发，如果标签中的栈底标识BoS=1，表明该标签是栈底标签，直接进行IP转发。如果标签中的栈底标识BoS=0，表明还有下一层标签，继续进行下一层标签转发。</p><h2 id="LDP协议"><a href="#LDP协议" class="headerlink" title="LDP协议"></a>LDP协议</h2><p> <strong>工作过程</strong></p><p>开启LDP的路由器会自动为路由表中的FEC分配标签，并将标签映射发送给下游路由器，下游路由器接受收到标签映射后将映射存储起来，然后自己为该FEC分配标签，并传送给下游路由器，以此重复，完成LSP的建立。</p><p><strong>LDP ID</strong></p><p>每一台运行MPLS的LSR都会有一个域内唯一的LSR ID长度为32 位。需要手工指定，否则MPLS无法激活。<br>每一台运行了LDP的LSR必须拥有LDP ID长度位48位，有32位的LSR ID以及16位的 Label Space ID（标签空间标识符）构成。LDP ID= LSR ID:Label Space ID    1.1.1.1：0</p><p><strong>LDP对等体会话建立过程</strong></p><p>1.LDP设备发现<br>主要通过Hello报文，接口激活LDP后便开始发送Hello报文。报文中包含了LDP ID以及传输地址，采用UDP封装，以组播方式发送，目的IP为224.0.0.2，端口号为646 。当两个通过Hello包发现到彼此就开始建立会话。</p><p>2.LDP会话建立<br>上一步双方发现彼此后都知道了对方的传输地址，接下来开始建立会话。<br>（1）：一般传输地址大的开始主动发起TCP会话建立请求，完成三次握手过程。<br>（2）：传输地址大的一方会主动发送一个Initialization（初始化）包，包含一些协议参数，另一方接收到包后检查参数，发送自己的Initialization包和Keepalive包，主动方收到后便知道另一方接收了自己的参数，开始检查另一方的参数，如果认可就会送一个Keepalive包。<br>（3）：双发将LDP会话置为Operational状态，LDP对等体会话建立成功</p><p>3.通过标签映射<br>LDP对等体之间相互通过标签映射</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;&lt;p&gt;传统的IP路由基于报文的IP头部的目的IP地址进行寻址及转发操作，设备需要维护路由表用于指导数据转发，根据最长匹配原则进行匹配条目，速度慢，
      
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>安装新版python导致yum不可用</title>
    <link href="http://yoursite.com/2019/03/28/%E5%AE%89%E8%A3%85%E6%96%B0%E7%89%88python%E5%AF%BC%E8%87%B4yum%E4%B8%8D%E5%8F%AF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/03/28/安装新版python导致yum不可用/</id>
    <published>2019-03-28T14:45:56.000Z</published>
    <updated>2019-03-27T16:09:46.093Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题：</strong><br>安装完新版本python导致yum命令不可用.<br><strong>错误代码：</strong></p><pre><code>File &quot;/usr/bin/yum&quot;, line 30except KeyboardInterrupt, e:^SyntaxError: invalid syntax</code></pre><p><strong>问题原因：</strong><br>yum包管理是使用python2.x写的，将python2.x升级到python3.x以后，由于python版本语法兼容性导致问题出现 .<br><strong>解决办法：</strong><br>修改yum配置文件，将python指向老版本.</p><pre><code>vim /usr/bin/yum#!/usr/bin/python2.7vim /usr/libexec/urlgrabber-ext-down#!/usr/bin/python2.7</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;问题：&lt;/strong&gt;&lt;br&gt;安装完新版本python导致yum命令不可用.&lt;br&gt;&lt;strong&gt;错误代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;File &amp;quot;/usr/bin/yum&amp;quot;, line 30
except Ke
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Centos安装python3.7</title>
    <link href="http://yoursite.com/2019/03/28/python%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2019/03/28/python安装/</id>
    <published>2019-03-28T14:45:56.000Z</published>
    <updated>2019-03-27T16:19:06.274Z</updated>
    
    <content type="html"><![CDATA[<p><strong>简介</strong><br>Centos系统本身自带python2.7版本，使用python –version可以查看当前系统python版本，由于系统内某些命令会用到python2，所以python2不可以卸载.</p><hr><p><strong>安装</strong><br>1.由于是基于源码安装，首先需要安装gcc make</p><pre><code>yum -y install gcc  make</code></pre><p>2.安装依赖的软件包</p><pre><code>yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel</code></pre><p>3.下载源码压缩包<br><a href="https://www.python.org/ftp/python/" target="_blank" rel="noopener">官网下载</a></p><pre><code>wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz</code></pre><p>4.解压编译</p><pre><code>tar -zxvf Python-3.7.0.tgzcd Python-3.7.0./configure --prefix=/usr/local/python3make &amp;&amp; make install</code></pre><p>5.设置软连接或者环境变量<br>(1)删除旧的软连接并创建新的软连接</p><pre><code>rm -f /usr/bin/{python，pip}ln -s /usr/local/python3/bin/python3.7   /usr/bin/python3ln -s /usr/local/python3/bin/pip3.7 /usr/bin/pip</code></pre><p><img src="http://static.zybuluo.com/jiangpeisi/n25m8enf3ysp9snd9eezrsze/image_1d6vu31311fbmead1o9l167m10gn34.png" alt="image_1d6vu31311fbmead1o9l167m10gn34.png-20.4kB"><br>修改完连接可能会造成yum不可用，<a href="https://jiangpeisi.github.io/2019/03/28/%E5%AE%89%E8%A3%85%E6%96%B0%E7%89%88python%E5%AF%BC%E8%87%B4yum%E4%B8%8D%E5%8F%AF%E7%94%A8/#more" target="_blank" rel="noopener">查看此处</a><br>(2)设置环境变量</p><pre><code>export PATH=&quot;$PATH:/usr/local/python3/bin/python3.7&quot;</code></pre><p>（3）两者选择一种就可以，前者直接使用python启用python解释器，后者需要使用python3启用python解释器。</p><p>6.查看python版本</p><pre><code>python --version</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;br&gt;Centos系统本身自带python2.7版本，使用python –version可以查看当前系统python版本，由于系统内某些命令会用到python2，所以python2不可以卸载.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习之数组</title>
    <link href="http://yoursite.com/2019/03/23/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2019/03/23/shell脚本学习之数组/</id>
    <published>2019-03-23T14:45:56.000Z</published>
    <updated>2019-03-23T06:15:59.660Z</updated>
    
    <content type="html"><![CDATA[<p><strong>数组定义</strong><br>方法一：</p><pre><code>array_name=(value0 value1 value2 value3)</code></pre><p>方法二：</p><pre><code>array_name[0]=value0array_name[1]=value1array_name[2]=value2</code></pre><p>方法三：</p><pre><code>array_name=(            value0            value1            value2            value3)</code></pre><p><strong>数组的引用</strong><br>1.<code>${array_name[n]}</code>  获取数组第n+1个元素<br>2.<code>${array_name[@]}</code>  获取数组所有的元素<br>3.<code>${array_name[*]}</code>  获取数组所有的元素<br>4.<code>${#array_name[n]}</code>  获取数组第n+1个元素的长度<br>5.<code>${#array_name[@]}</code>  获取数组元素个数<br>6.<code>unset array[n]</code>   删除第n+1个元素<br>7.<code>unset array</code>   删除数组<br><strong>数组的替换</strong><br>方法一：不改变原数组<code>{arrary[@]/old/new}</code></p><pre><code>[root@jiangpeisi shell]# echo ${array1[@]/php/lua}lua c++ python java[root@jiangpeisi shell]# array3=${array1[@]/php/lua}[root@jiangpeisi shell]# echo ${array3[@]}lua c++ python java</code></pre><p>方法二：改变原数组<code>array=（[1]=new1 [2]=new2 [3]=new3）</code>   </p><pre><code>[root@jiangpeisi shell]# array1=([1]=lua [2]=php)[root@jiangpeisi shell]# echo ${array1[@]}lua php</code></pre><p><strong>数组遍历</strong><br>方法一：通过元素遍历</p><pre><code>array1=(php c++ python java)for var in ${array1[@]};do    echo $vardone[root@jiangpeisi shell]# sh array.sh phpc++pythonjava</code></pre><p>方法二：通过下标遍历</p><pre><code>array1=(php c++ python java)for i in &quot;${!array1[@]}&quot;;do    printf &quot;${array1[$i]}\n&quot;done[root@jiangpeisi shell]# sh array.sh phpc++pythonjava</code></pre><p>方法三：使用while循环遍历数组</p><pre><code>array1=(php c++ python java)i=0while [ $i -lt ${#array1[@]} ]do    echo ${array1[$i]}    let i++done[root@jiangpeisi shell]# sh array.sh phpc++pythonJava</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;数组定义&lt;/strong&gt;&lt;br&gt;方法一：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;array_name=(value0 value1 value2 value3)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;方法二：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;array_name[0]=v
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>hexo渲染文章失败</title>
    <link href="http://yoursite.com/2019/03/23/hexo%E6%B8%B2%E6%9F%93%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/03/23/hexo渲染问题/</id>
    <published>2019-03-23T14:04:56.000Z</published>
    <updated>2019-03-23T06:39:40.737Z</updated>
    
    <content type="html"><![CDATA[<p><strong>简述</strong><br>今天写了一个新的笔记打算上传的博客上，结果在渲染博文的时候出现了一个错误。一个神奇的现象就是我如果删除这篇新的博文时，就可以渲染成功，添加新的博文就渲染失败。后来看了官网的文章才知道，是因为我的新博文内出现了一些无法识别的字符。例如不可见的零宽度字符、预保留字符。出现这种情况有两种可能性，一种是你的新页面/帖子，另一种是_config.yml。显然我的属于前者。</p><hr><p><strong>错误代码</strong></p><pre><code>jiang@jiang-PC MINGW64 /F/Myblog                                                                                           $ hexo g                                                                                                                   INFO  Start processing                                                                                                     FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html                    Template render error: (unknown path)                                                                                        Error: expected end of comment, got end of file                                                                              at Object._prettifyError (F:\Myblog\node_modules\nunjucks\src\lib.js:36:11)                                                at Template.render (F:\Myblog\node_modules\nunjucks\src\environment.js:526:21)                                             at Environment.renderString (F:\Myblog\node_modules\nunjucks\src\environment.js:364:17)                                    at Promise.fromCallback.cb (F:\Myblog\node_modules\hexo\lib\extend\tag.js:62:48)                                           at tryCatcher (F:\Myblog\node_modules\bluebird\js\release\util.js:16:23)                                                   at Function.Promise.fromNode.Promise.fromCallback (F:\Myblog\node_modules\bluebird\js\release\promise.js:180:30)           at Tag.render (F:\Myblog\node_modules\hexo\lib\extend\tag.js:62:18)                                                        at Object.onRenderEnd (F:\Myblog\node_modules\hexo\lib\hexo\post.js:282:20)                                                at Promise.then.then.result (F:\Myblog\node_modules\hexo\lib\hexo\render.js:65:19)                                         at tryCatcher (F:\Myblog\node_modules\bluebird\js\release\util.js:16:23)                                                   at Promise._settlePromiseFromHandler (F:\Myblog\node_modules\bluebird\js\release\promise.js:512:31)                        at Promise._settlePromise (F:\Myblog\node_modules\bluebird\js\release\promise.js:569:18)                                   at Promise._settlePromise0 (F:\Myblog\node_modules\bluebird\js\release\promise.js:614:10)                                  at Promise._settlePromises (F:\Myblog\node_modules\bluebird\js\release\promise.js:694:18)                                  at _drainQueueStep (F:\Myblog\node_modules\bluebird\js\release\async.js:138:12)                                            at _drainQueue (F:\Myblog\node_modules\bluebird\js\release\async.js:131:9)                                                 at Async._drainQueues (F:\Myblog\node_modules\bluebird\js\release\async.js:147:5)                                          at Immediate.Async.drainQueues (F:\Myblog\node_modules\bluebird\js\release\async.js:17:14)                                 at runCallback (timers.js:705:18)                                                                                          at tryOnImmediate (timers.js:676:5)                                                                                        at processImmediate (timers.js:658:5)     </code></pre><p><strong>问题原因</strong><br><img src="http://static.zybuluo.com/jiangpeisi/2c8thylc5u8rgj6cbznj580r/image_1d6kkaaka1ue91btk1v0f1npl1skbm.png" alt="image_1d6kkaaka1ue91btk1v0f1npl1skbm.png-23.5kB"></p><p><strong>解决办法</strong></p><p><img src="http://static.zybuluo.com/jiangpeisi/as1qheh918m50h356rbcs8e7/image_1d6kkbo3s128l1o632s0bml19ou1j.png" alt="image_1d6kkbo3s128l1o632s0bml19ou1j.png-17.4kB"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;简述&lt;/strong&gt;&lt;br&gt;今天写了一个新的笔记打算上传的博客上，结果在渲染博文的时候出现了一个错误。一个神奇的现象就是我如果删除这篇新的博文时，就可以渲染成功，添加新的博文就渲染失败。后来看了官网的文章才知道，是因为我的新博文内出现了一些无法识别的字符。
      
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习之正则表达式</title>
    <link href="http://yoursite.com/2019/03/22/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/03/22/shell脚本学习之正则表达式/</id>
    <published>2019-03-22T14:45:56.000Z</published>
    <updated>2019-03-22T03:25:09.084Z</updated>
    
    <content type="html"><![CDATA[<p><strong>简述</strong><br>正则表达式是对字符串（包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”））操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。正则表达式是一种文本模式，模式描述在搜索文本时要匹配的一个或多个字符串。</p><p><strong>正则表达式字符</strong></p><pre><code>\：将下一个字符标记符、或一个向后引用、或一个八进制转义符。例如，“\\n”匹配\n。“\n”匹配换行符。序列“\\”匹配“\”而“\(”则匹配“(”。即相当于多种编程语言中都有的“转义字符”的概念。^：匹配输入字行首。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。$：匹配输入行尾。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。*：匹配前面的子表达式任意次。例如，zo*能匹配“z”，也能匹配“zo”以及“zoo”。*等价于{0,}。+：匹配前面的子表达式一次或多次(大于等于1次）。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。?：匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”。?等价于{0,1}。{n}：n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。{n,}：n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。{n,m}：m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o为一组，后三个o为一组。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。?：当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少地匹配所搜索的字符串，而默认的贪婪模式则尽可能多地匹配所搜索的字符串。例如，对于字符串“oooo”，“o+”将尽可能多地匹配“o”，得到结果[“oooo”]，而“o+?”将尽可能少地匹配“o”，得到结果 [&apos;o&apos;, &apos;o&apos;, &apos;o&apos;, &apos;o&apos;].：匹配除“\n”和&quot;\r&quot;之外的任何单个字符。要匹配包括“\n”和&quot;\r&quot;在内的任何字符，请使用像“[\s\S]”的模式。(pattern)：匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\(”或“\)”。(?:pattern)：非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分时很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。(?=pattern)：非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。(?!pattern)：非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。(?&lt;=pattern)：非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。(?&lt;!patte_n)：非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。x|y：匹配x或y。例如，“z|food”能匹配“z”或“food”(此处请谨慎)。“[z|f]ood”则匹配“zood”或“food”。[xyz]：字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。[^xyz]：负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”任一字符。[a-z]：字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。注意:只有连字符在字符组内部时,并且出现在两个字符之间时,才能表示字符的范围; 如果出字符组的开头,则只能表示连字符本身[^a-z]：负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。\b：匹配一个单词的边界，也就是指单词和空格间的位置（即正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置，这里的\b就是匹配位置的）。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”；“\b1_”可以匹配“1_23”中的“1_”，但不能匹配“21_3”中的“1_”。\B：匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。\cx：匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。\d：匹配一个数字字符。等价于[0-9]。grep 要加上-P，perl正则支持\D：匹配一个非数字字符。等价于[^0-9]。grep要加上-P，perl正则支持\f：匹配一个换页符。等价于\x0c和\cL。\n：匹配一个换行符。等价于\x0a和\cJ。\r：匹配一个回车符。等价于\x0d和\cM。\s：匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。\S：匹配任何可见字符。等价于[^ \f\n\r\t\v]。\t：匹配一个制表符。等价于\x09和\cI。\v：匹配一个垂直制表符。等价于\x0b和\cK。\w：匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的&quot;单词&quot;字符使用Unicode字符集。\W：匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。</code></pre><p><strong>实例</strong><br>匹配手机号码：<code>^1[3|4|5|7|8][0-9]{9}$</code><br>匹配IP地址：<code>[0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3}</code>   不准确<br>匹配电子邮箱：<code>/^[a-z\d]+(\.[a-z\d]+)*@([\da-z](-[\da-z])?)+(\.{1,2}[a-z]+)+$/</code><br>匹配URL：<code>/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/</code><br>匹配6-18位的密码：<code>/^[a-z0-9_-]{6,18}$/</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;简述&lt;/strong&gt;&lt;br&gt;正则表达式是对字符串（包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”））操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习之四剑客grep</title>
    <link href="http://yoursite.com/2019/03/22/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9B%9B%E5%89%91%E5%AE%A2grep/"/>
    <id>http://yoursite.com/2019/03/22/shell脚本学习之四剑客grep/</id>
    <published>2019-03-22T14:45:56.000Z</published>
    <updated>2019-03-22T03:43:06.363Z</updated>
    
    <content type="html"><![CDATA[<p><strong>简述</strong><br>grep是一种强大的文本搜索工具，与正则表达式配合搜索文本，并把匹配的行打印出来。</p><hr><p><strong>语句格式：</strong></p><pre><code>grep -options ‘word’ filename</code></pre><p><strong>常用参数：</strong><br>-a：以文本文件方式搜索<br>-c：计算找到的符合行的次数<br>-i：忽略大小写<br>-n：顺便输出行号<br>-v：反向选择，输出不包含匹配的所有行<br>-h：查询多文件时不现实文件名<br>-l：查询多文件时，只输出包含匹配字符的文件名<br>-s：不显示不存在或无匹配文本的错误信息<br>-E：使用egrep扩展匹配模式<br>– color：指定匹配输出字符的颜色<br><strong>正则表达式</strong><br><a href="https://jiangpeisi.github.io/2019/03/22/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" target="_blank" rel="noopener">点这里</a><br><strong>实例</strong></p><pre><code>[root@jiangpeisi shell]# cat a.txt | grep &apos;^m.*l$&apos; mysql[root@jiangpeisi shell]# cat a.txt | grep -E &quot;\&lt;([0-9]{1,3}\.){3}([0-9]{1,3})\&gt;&quot; 192.168.32.1[root@jiangpeisi shell]# cat a.txt | grep -c  &apos;^m.*l$&apos; 1[root@jiangpeisi shell]# cat a.txt | grep  -n &apos;^m.*l$&apos; 2:mysql[root@jiangpeisi shell]# cat a.txt | grep  -i -n  &apos;^M.*l$&apos; 2:mysql[root@jiangpeisi shell]# netstat -ntlp | grep namedtcp        0      0 172.17.0.1:53           0.0.0.0:*               LISTEN      3585/named          tcp        0      0 172.16.30.80:53         0.0.0.0:*               LISTEN      3585/named          tcp        0      0 127.0.0.1:53            0.0.0.0:*               LISTEN      3585/named          tcp        0      0 127.0.0.1:953           0.0.0.0:*               LISTEN      3585/named  </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;简述&lt;/strong&gt;&lt;br&gt;grep是一种强大的文本搜索工具，与正则表达式配合搜索文本，并把匹配的行打印出来。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;语句格式：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grep -options ‘word’ f
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习之四剑客sed</title>
    <link href="http://yoursite.com/2019/03/21/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9B%9B%E5%89%91%E5%AE%A2sed/"/>
    <id>http://yoursite.com/2019/03/21/shell脚本学习之四剑客sed/</id>
    <published>2019-03-21T14:45:56.000Z</published>
    <updated>2019-03-21T06:25:04.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sed简介"><a href="#sed简介" class="headerlink" title="sed简介"></a>sed简介</h1><p>sed是一个非交互式文本编辑器，它可以对文本文件和标准输入进行编辑，标志输入可以来自键盘输入、文本重定向、字符串、变量、甚至来自于管道符。逐行处理内容，一次只处理一行内容。</p><h1 id="sed工作流程"><a href="#sed工作流程" class="headerlink" title="sed工作流程"></a>sed工作流程</h1><p>1、读新的一行到缓存空间（pattern space）<br>2、从指定的操作指令中依次取出指令执行，判断是否匹配缓存空间内容<br>3、如果不匹配则忽略后续的编辑命令，回到第2步继续取出下一条指令<br>4、如果匹配，则针对缓存的行执行后续的编辑命令；完成后，回到第2步继续取出下一条指令<br>5、当所有指令都应用之后，输出缓存行的内容；回到第1步继续读入下一行内容<br>6、当所有行都处理完之后，结束；<br>sed操作的所有数据都是pattern space缓存空间内的数据，原文件并没有发生该表。如果想保留sed操作后的数据，可以使用重定向符输出到新的文件中。或者使用- i参数更改原文件。</p><h1 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h1><h2 id="命令格式："><a href="#命令格式：" class="headerlink" title="命令格式："></a>命令格式：</h2><pre><code>sed  [options]  [commands]  filename;</code></pre><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><p>x：指定行号<br>x,y：指定从x行到y行<br>/pattern/：指定包含模式的行<br>/pattern/,n：指定包含模式的行到第n行<br>p：打印匹配行<br>n：读取下一个输入行，用下一个命令处理新的行<br>a：在匹配行后面新的一行追加内容<br>i：在匹配行前面新的一行插入内容<br>d：删除匹配的行<br>c：用指定内容替代匹配的内容，一般操作多行<br>s：用指定内容替代匹配的内容，一般替代具体单词</p><h2 id="常用参数实例"><a href="#常用参数实例" class="headerlink" title="常用参数实例"></a>常用参数实例</h2><p><strong>原文本</strong></p><pre><code>[root@jiangpeisi shell]# cat a.txt mysqlappachenginxredismemachedphppython</code></pre><p><strong>1.打印指定行内容</strong></p><pre><code>[root@jiangpeisi shell]# sed -n &apos;1,3p&apos; a.txt mysqlappachenginx</code></pre><p><strong>2.删除指定行</strong></p><pre><code>[root@jiangpeisi shell]# sed &apos;/php/,$d&apos; a.txt mysqlappachenginxredismemached</code></pre><p><strong>3.在指定行前后添加内容</strong></p><pre><code>[root@jiangpeisi shell]# sed &apos;$a java&apos; a.txt mysqlappachenginxredismemachedphppythonJava[root@jiangpeisi shell]# sed &apos;$i java&apos; a.txt mysqlappachenginxredismemachedphpjavaPython</code></pre><p><strong>4.替换指定内容</strong></p><pre><code>[root@jiangpeisi shell]# sed &apos;2,3c java&apos; a.txt mysqljavaredismemachedphppython</code></pre><p>[root@jiangpeisi shell]# sed ‘s/php/java/‘ a.txt </p><pre><code>mysqlappachenginxredismemachedjavapython</code></pre><p><strong>5.多个命令组合 使用；或者-e参数</strong></p><pre><code>[root@jiangpeisi shell]# sed -e &apos;$a java&apos; -e &apos;s/php/java/&apos; a.txt mysqlappachenginxredismemachedjavapythonjava[root@jiangpeisi shell]# sed &apos;/mysql/d ; s/php/java/&apos;  a.txt appachenginxredismemachedjavapython</code></pre><h2 id="进阶参数"><a href="#进阶参数" class="headerlink" title="进阶参数"></a>进阶参数</h2><p>N：将当前读入行的下一行读取到当前的模式空间<br><img src="http://static.zybuluo.com/jiangpeisi/kwppvxf1du6mj1c0w55iuulz/image_1d6fdc4i41r4rujbos01old5h23j.png" alt="image_1d6fdc4i41r4rujbos01old5h23j.png-2.5kB"><br>h：将模式缓存区的文本复制到保持缓冲区<br><img src="http://static.zybuluo.com/jiangpeisi/c0yf7m2q8chbvbixsh5qxii4/image_1d6fdcepm13br129vmfuh7615sm40.png" alt="image_1d6fdcepm13br129vmfuh7615sm40.png-3.4kB"><br>H：将模式缓冲区的文本追加到保持缓冲区<br><img src="http://static.zybuluo.com/jiangpeisi/hrya3jucdxeg5ayw8luxhiri/image_1d6fdcn2u1iiv3gllj7mats94d.png" alt="image_1d6fdcn2u1iiv3gllj7mats94d.png-3.4kB"><br>x：互换模式缓冲区和保持缓冲区的内容<br><img src="http://static.zybuluo.com/jiangpeisi/qu8oykohe71m6an3sipqvdms/image_1d6fdfb8cbj61u0a18rs1cfi5b470.png" alt="image_1d6fdfb8cbj61u0a18rs1cfi5b470.png-2.8kB"><br>g：将保持缓冲区的内容复制到模式缓冲区<br><img src="http://static.zybuluo.com/jiangpeisi/hlk49s1ai3igt6tviirme4xi/image_1d6fdfjoi1u9qgts1hqp4701doo7d.png" alt="image_1d6fdfjoi1u9qgts1hqp4701doo7d.png-3.3kB"><br>G：将保持缓冲区的内容追加到模式缓冲区<br><img src="http://static.zybuluo.com/jiangpeisi/479c4zr05uucdwqfijkfm2uj/image_1d6fdfom84pco1qehi1hvk1ua77q.png" alt="image_1d6fdfom84pco1qehi1hvk1ua77q.png-3.5kB"><br>两个缓冲空间pattern space与hold space。pattern space是一个临时缓冲区，用于保存当前读入的行信息，每处理完一行就会清除缓存内的信息，读取下一行。hold space 同样也是一个临时缓冲去，在处理行信息时，可以与pattern space之间进行互相拷贝。</p><h2 id="进阶参数实例"><a href="#进阶参数实例" class="headerlink" title="进阶参数实例"></a>进阶参数实例</h2><p><strong>1.在每一行后添加一个空行</strong></p><pre><code>[root@jiangpeisi shell]# sed &apos;/^ $/p;G&apos; a.txt mysqlappachenginxredismemachedphppython</code></pre><p><strong>2.将指定行的后一行与指定行合并为一行</strong></p><pre><code>[root@jiangpeisi shell]# sed  &apos;3N;s/\n/ /&apos; a.txt mysqlappachenginx redismemachedphppython</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sed简介&quot;&gt;&lt;a href=&quot;#sed简介&quot; class=&quot;headerlink&quot; title=&quot;sed简介&quot;&gt;&lt;/a&gt;sed简介&lt;/h1&gt;&lt;p&gt;sed是一个非交互式文本编辑器，它可以对文本文件和标准输入进行编辑，标志输入可以来自键盘输入、文本重定向、字符串、变
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习之四剑客awk</title>
    <link href="http://yoursite.com/2019/03/21/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9B%9B%E5%89%91%E5%AE%A2awk/"/>
    <id>http://yoursite.com/2019/03/21/shell脚本学习之四剑客awk/</id>
    <published>2019-03-21T14:45:56.000Z</published>
    <updated>2019-03-21T10:41:47.151Z</updated>
    
    <content type="html"><![CDATA[<p><strong>简述</strong><br>awk本身就是一种编程语言，它支持条件判断、循环、数组遍历等功能。我们可以使用它来对文本进行分析和处理。与sed相比，sed是逐行处理文本内数据，awk也是，不过awk又在此基础上实现对每一行每一列的操作。专业的角度来讲awk是一个报告生成器，因为awk可以对行和列进行操作，所以在awk命令下，一个文本就像是一个表格。默认列之间的分隔符是空格，行之间分隔符是\n，可以通过-F或者-v FS:指定分割符。</p><hr><p><strong>命令格式</strong></p><pre><code>awk &apos;{pattern + action}&apos; {filenames}</code></pre><p><strong>1.基本语法参数</strong><br>1.单引号‘’：为了和shell语法分开，防止混淆<br>2.大括号{}：用来表示一组命令<br>3.pattern：一个过滤器，表示匹配pattern的条件的行才可以执行action<br>4.pattern可以是以下任意一种<br>    -正则表达式：使用通配符匹配<br>    -关系表达式：使用关系运算符<br>    -模式匹配表达式：使用运算符~或者！~匹配<br>5.action：处理动作，一系列命令，常见的动作为print</p><p>实例：抓取IP地址</p><pre><code>[root@jiangpeisi ~]# ifconfig eth0 |awk  &apos;/inet/{print $2}&apos;172.16.30.80[root@jiangpeisi ~]# ifconfig eth0 | grep inet | awk &apos;{print $2}&apos;172.16.30.80[root@jiangpeisi ~]# ip addr | awk &apos;/eth0/&apos; | awk &apos;/inet/{print $2}&apos;172.16.30.80/18</code></pre><p><strong>2.内置参数</strong><br>FS：分隔符，默认是空格作为分隔符<br>OFS：输出行分隔符<br>NR：当前行数，从1开始<br>NF：当前行的字段（列）个数<br>$0：当前记录<br><code>$1~$n</code>：当前记录的第n个字段</p><p>实例：输出字段个数</p><pre><code>[root@jiangpeisi ~]# whoroot     pts/1        2019-03-21 11:14 (49.70.207.182)[root@jiangpeisi ~]# who | awk &apos;{print NF}&apos;5</code></pre><p>实例：打印奇数行的行号和第一列内容</p><pre><code>[root@jiangpeisi ~]# awk -F: &apos;NR%2==0{next}{print NR,$1}&apos; /etc/passwd1 root3 daemon5 lp7 shutdown9 mail11 games13 nobody15 systemd-network17 polkitd19 sshd21 chrony23 nscd25 admin27 dockerroot-latest29 test131 ftpuser133 dhcpd35 saslauth</code></pre><p><strong>3.内置函数</strong><br>1.gsub（r，s）：在$0中用s代替r<br>2.index（s，t）：返回s中t的第一个位置<br>3.length（s）：返回s的长度<br>4.match（s，r）：s是否匹配r<br>5.split（s，a，fs）：在fs上讲s分成序列a<br>6.substr（s，p）：返回s从p开始的子串</p><p>实例：输出字段长度</p><pre><code>[root@jiangpeisi ~]# whoroot     pts/1        2019-03-21 11:14 (49.70.207.182)[root@jiangpeisi ~]# who | awk &apos;{print length($2)}&apos;5</code></pre><p><strong>4.流程控制语句</strong><br>1.if（condition）{}else{}<br>2.while（condition）{}<br>3.for（init；condition；step）{}<br>4.Break/contitnue<br>实例：比较大小</p><pre><code>[root@jiangpeisi ~]# echo 2 3 |awk &apos;{if($1&gt;$2){print $1}else{print $2}}&apos;3[root@jiangpeisi ~]# echo 3 2 |awk &apos;{if($1&gt;$2){print $1}else{print $2}}&apos;3</code></pre><p><strong>补充</strong><br>使用awk可以对一个文件写一个脚本，格式：</p><pre><code>awk &apos;BEGIN{ commands } pattern{ commands } END{ commands }&apos; file </code></pre><p>执行顺序：<br>第一步： 执行BEGIN { commands } pattern 语句块中的语句，在对文件操作前执行<br>第二步：从文件或标准输入中读取一行，然后执行pattern{ commands }语句块。它逐行扫描文件，从第一行到最后一行重复这个过程，直到全部文件都被读取完毕。<br>第三步：当读至输入流末尾时，执行END { commands }语句块</p><p>实例：计算用户数量</p><pre><code>[root@jiangpeisi ~]# awk &apos;BEGIN {count=0;print &quot;[start] user count is &quot;,count} {;;count++} END{print &quot;[end] user count is &quot;,count}&apos; /etc/passwd[start] user count is  0[end] user count is  36</code></pre><p>实例：计算文件夹大小</p><pre><code>[root@jiangpeisi ~]# ls -lF /etc/ | awk &apos;BEGIN {sum=0}{sum+=$5}END{print &quot;The size of this dir is&quot;,sum/1024/1024,&quot;M&quot;}&apos;The size of this dir is 1.30004 M</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;简述&lt;/strong&gt;&lt;br&gt;awk本身就是一种编程语言，它支持条件判断、循环、数组遍历等功能。我们可以使用它来对文本进行分析和处理。与sed相比，sed是逐行处理文本内数据，awk也是，不过awk又在此基础上实现对每一行每一列的操作。专业的角度来讲awk是
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习之函数</title>
    <link href="http://yoursite.com/2019/03/20/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/03/20/shell脚本学习之函数/</id>
    <published>2019-03-20T14:45:56.000Z</published>
    <updated>2019-03-20T14:55:31.064Z</updated>
    
    <content type="html"><![CDATA[<p><strong>函数定义格式：</strong></p><pre><code>function name（）{command}</code></pre><p><strong>调用：</strong></p><pre><code>name argv1 argv2  </code></pre><p><strong>实例：安装Apache函数</strong></p><pre><code>#!/bin/bash#Auto install appache#By Auther jiangpeisiURL=http://mirrors.shu.edu.cn/apache//httpdFILE=httpd-2.4.38.tar.gzFILES_DIR=httpd-2.4.38PREFIX=/usr/local/apachefunction Apache_install(){if [ $1 -eq 1 ];then        yum install  openssl openssl-devel zlib zlib-devel gcc-c++ pcre pcre-devel -y &amp;&amp; cd /usr/local/src/ &amp;&amp; wget $URL/$FILE &amp;&amp; tar -xvf $FILE &amp;&amp; cd $FILES_DIR &amp;&amp; ./configure --prefix=$PREFIX  if [ $? -eq 0 ];then    make&amp;&amp;make install    echo &quot;The $FILES_DIR Server Install Sucess!&quot;    . /usr/local/apache/bin/httpd  else    echo &quot;The $FILES_DIR Server Install Fail!&quot;  fifi}Apache_install 1</code></pre><p><strong>测试：</strong></p><p><img src="http://static.zybuluo.com/jiangpeisi/369raax3bt02mth1v541lp5z/image_1d6dpfhvfkkohu3fk21gg8185116.png" alt="image_1d6dpfhvfkkohu3fk21gg8185116.png-23.1kB"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;函数定义格式：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function name（）
{
command
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;调用：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name argv1 argv2 
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习之选择语句</title>
    <link href="http://yoursite.com/2019/03/20/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5/"/>
    <id>http://yoursite.com/2019/03/20/shell脚本学习之选择语句/</id>
    <published>2019-03-20T14:45:56.000Z</published>
    <updated>2019-03-20T14:50:35.384Z</updated>
    
    <content type="html"><![CDATA[<p><strong>case 语句格式：</strong></p><pre><code>case value in （表达式）pattern1)    command    ;;pattern2）    command    ;;*）   commandesac</code></pre><p><strong>实例：菜单选择</strong></p><pre><code>#!/bin/bashMenu=(beef,noodles,rice,juice)echo &quot;The menu is:&quot;for i in ${Menu[*]}do   echo  &quot;$i&quot;doneread -p &quot;Please choose one:&quot; foodcase $food in        beef)         echo &quot;You choose beef!&quot;        ;;        noodles)          echo &quot;You choose noodles!&quot;        ;;        rice)          echo &quot;You choose rice!&quot;        ;;        juice)          echo &quot;You choose juice!&quot;        ;;        *)          echo &quot;Don&apos;t have this one!&quot;        ;;esac[root@jiangpeisi shell]# sh menu.sh The menu is:beef,noodles,rice,juicePlease choose one:noodlesYou choose noodles!</code></pre><p><strong>select 语法格式：</strong></p><pre><code>select i in （表达式）do   commanddone</code></pre><p><strong>实例：测试服务状态</strong></p><pre><code>#!/bin/bashPS3=&quot;Please enter your select menu:&quot;select i in http php mysql quitdocase $i in        http)          echo &quot;Test http&apos;s state!&quot;        ;;        php)          echo &quot;Test php&apos;s state!&quot;        ;;        mysql)          echo &quot;Test mysql&apos;s state!&quot;        ;;        quit)          echo &quot;Exit!&quot;          exitesacdone[root@jiangpeisi shell]# sh lnmp.sh1) http2) php3) mysql4) quitPlease enter your select menu:1Test http&apos;s state!Please enter your select menu:2Test php&apos;s state!Please enter your select menu:3Test mysql&apos;s state!Please enter your select menu:4Exit!</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;case 语句格式：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;case value in （表达式）
pattern1)
    command
    ;;
pattern2）
    command
    ;;
*）
   command
es
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习之四剑客find</title>
    <link href="http://yoursite.com/2019/03/20/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9B%9B%E5%89%91%E5%AE%A2find/"/>
    <id>http://yoursite.com/2019/03/20/shell脚本学习之四剑客find/</id>
    <published>2019-03-20T14:45:56.000Z</published>
    <updated>2019-03-20T16:02:35.465Z</updated>
    
    <content type="html"><![CDATA[<p><strong>简述</strong><br>  find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。<br><strong>语句格式：</strong></p><pre><code>find path -option [ -print ] [ -exec -ok command ] {} \;-print ：表示find命令将匹配的文件输出到标准输出中，默认执行该命令-exec  ：表示find命令对匹配的文件执行该参数给出的shell命令。相应命令的形式为 cmd {} \;-ok      ：它的作用和-exec一样，只是需要用户交互，更安全</code></pre><p><strong>option参数说明：</strong></p><pre><code>-name ：按照文件名查找文件-perm  ：按照权限查找文件-prune ：使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略-user  ： 按照文件属主来查找文件-group  ：按照文件数组来查找文件-mtime -n +n  ：按照文件的更改时间来查找文件    -n ：表示从此刻算起，文件的更改是在n天以内    +n ：表示文件的更改时间是在n天以前-atime -n +n ： 按文件访问时间来查询-ctime -n +n ：按文件创建时间来查询 -nogroup  ：查找无有效属组的文件，即该文件所属的组在/etc/groups中不存在-nouser  :：查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在-newer file1 ！ file2  :查找更改时间比file1新但比file2旧的文件-type      b：表示块设备文件     block     d：表示目录         directory     c：表示字符设备文件   char     p：表示管道文件      pipe     l：表示符号链接文件   link     f：表示普通文件      file-depth ：在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找-fstype ：表示查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/etc/fstab中找到，该配置文件中包含了本系统中有关文件系统的信息-mount  ：表示在查找文件时不跨越文件系统的mount点-follow   ：表示如果find命令遇到符号链接文件，就跟踪至链接所指向的文件-cpio      ：表示对匹配的文件使用cpio命令，将这些文件备份至磁带设备中</code></pre><p><strong>实例：</strong><br>实例1：查找/root/shell目录下以.sh结尾 并且创建时间在1天以内的文件</p><pre><code>[root@jiangpeisi ~]# find /root/shell/ -name *.sh -ctime -1/root/shell/menu.sh/root/shell/apache-install.sh/root/shell/lnmp.sh/root/shell/select.sh/root/shell/sum.sh/root/shell/while.sh</code></pre><p>实例2：查找/root/shell目录下以.sh结尾 并且创建时间在1天以内的文件，并将文件移动到/opt/目录下</p><pre><code>[root@jiangpeisi ~]# find /root/shell/ -name *.sh -ctime -1 -exec mv {} /opt/ \; [root@jiangpeisi ~]# ll /opt/total 36-rw-r--r-- 1 root root  621 Mar 20 15:32 apache-install.sh-rw-r--r-- 1 root root   48 Mar 17 11:08 b.sh-rw-r--r-- 1 root root  303 Mar 18 11:28 e.sh-rw-r--r-- 1 root root  258 Mar 20 14:25 lnmp.sh-rw-r--r-- 1 root root  357 Mar 20 08:49 menu.shdrwxr-xr-x 2 root root 4096 Mar 15 15:41 nginx-rw-r--r-- 1 root root  138 Mar 20 14:12 select.sh-rw-r--r-- 1 root root   82 Mar 20 00:00 sum.sh-rw-r--r-- 1 root root   70 Mar 20 00:07 while.sh</code></pre><p>实例3：查找/data目录下以.log结尾，修改时间在1天以内，文件大小大于10M的文件，并将文件打包</p><pre><code>[root@jiangpeisi ~]# find /data/ -name *.log -ctime -1 -size +10k -exec tar -czPf /datacd/backup.tar.gz {} \;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;简述&lt;/strong&gt;&lt;br&gt;  find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。&lt;br&gt;&lt;str
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习之循环语句</title>
    <link href="http://yoursite.com/2019/03/19/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"/>
    <id>http://yoursite.com/2019/03/19/shell脚本学习之循环语句/</id>
    <published>2019-03-19T14:45:56.000Z</published>
    <updated>2019-03-19T16:24:27.690Z</updated>
    
    <content type="html"><![CDATA[<p><strong>for循环语句格式</strong></p><pre><code>for var in （表达式）do    Commanddone</code></pre><p><strong>实例：计算1-100和</strong></p><pre><code>#!/bin/bashsum=0for i in `seq 1 100`do  sum=$(expr $sum + $i)doneecho $sum[root@jiangpeisi shell]# sh for.sh 5050</code></pre><p><strong>while循环语句格式</strong></p><pre><code>while（表达式）do    commanddone</code></pre><p><strong>实例：循环按行打印文件内容</strong></p><pre><code>#!/bin/bashwhile read linedo   echo $linedone &lt; /root/shell/a.txt[root@jiangpeisi shell]# sh while.sh lkitd:x:998:997:User for polkitd:/:/sbin/nologintss:x:59:59:Account used by the trousers package to sandbox the tcsd daemon:/dev/null:/sbin/nologinsshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologinpostfix:x:89:89::/var/spool/postfix:/sbin/nologinchrony:x:997:995::/var/lib/chrony:/sbin/nologinntp:x:38:38::/etc/ntp:/sbin/nologinnscd:x:28:28:NSCD Daemon:/:/sbin/nologintcpdump:x:72:72::/:/sbin/nologinadmin:x:1000:1000::/home/admin:/bin/bashdockerroot:x:996:993:Docker User:/var/lib/docker:/sbin/nologindockerroot-latest:x:995:992:Docker User:/var/lib/docker-latest:/sbin/nologinzarafa:x:994:991:Zarafa Service Account:/var/lib/zarafa:/sbin/nologintest1:x:1002:1002::/home/test1:/bin/bashjiangpeisi:x:1004:1004::/home/jiangpeisi:/bin/bashftpuser1:x:1005:1005::/home/ftpuser1:/bin/bashnamed:x:25:25:Named:/var/named:/bin/falsedhcpd:x:177:177:DHCP server:/:/sbin/nologinmysql:x:27:27:MariaDB Server:/var/lib/mysql:/sbin/nologinsaslauth:x:993:76:Saslauthd user:/run/saslauthd:/sbin/nologinapache:x:48:48:Apache:/usr/share/httpd:/sbin/nologin</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;for循环语句格式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for var in （表达式）
do
    Command
done
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;实例：计算1-100和&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;cod
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习之if条件判断</title>
    <link href="http://yoursite.com/2019/03/19/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8Bif%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD/"/>
    <id>http://yoursite.com/2019/03/19/shell脚本学习之if条件判断/</id>
    <published>2019-03-19T14:45:56.000Z</published>
    <updated>2019-03-19T15:57:03.332Z</updated>
    
    <content type="html"><![CDATA[<p><strong>语句格式：</strong></p><pre><code>if(条件表达式)  commandelif(条件表达式)  commandelse  commandfi</code></pre><p><strong>if常见的判断逻辑运算符</strong></p><pre><code>-f: 判断文件是否存在,例如if[-f filename ]。-d: 判断目录是否存在,例如if[ -d dir]。-eq :等于,应用于整型比较,即equal.-ne:不等于,应用于整型比较,即not equal。-lt: 小于,应用于整型比较,即letter。-gt:大于,应用于整型比较,即greater。-le: 小于或等于,应用于整型比较。-ge: 大于或等于,应用于整型比较。-a:双方都成立(and) ,用法为逻辑表达式-a逻辑表达式-o:单方成立(or),用法为逻辑表达式-o逻辑表达式。-z:空字符串。||:单方成立。&amp;&amp;:双方都成立表达式。</code></pre><p><strong>实例：</strong><br>使用if条件判断分数</p><pre><code>#!/bin/bashscores=$1if [ $scores -eq 100 ]; then   echo &quot; very good!&quot; ;elif [ $scores -gt 85 ];then   echo &quot;good!&quot; ;elif [ $scores -gt 60 ];then   echo &quot; pass! &quot; ;elif [ $scores -lt 60 ]; then   echo &quot;no pass!&quot;;fi[root@jiangpeisi shell]# sh scores.sh 95good!</code></pre><p>判断网络主机状态</p><pre><code>#!/bin/bashping -c2 -W1 $1 &amp;&gt;/dev/nullif [ $? -eq 0 ];then  echo &quot;$1 is UP&quot;else  echo &quot;$1[root@jiangpeisi shell]# sh state.sh 192.168.32.2192.168.32.2 is DOWN</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;语句格式：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(条件表达式)
  command
elif(条件表达式)
  command
else
  command
fi
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;if常见的判断逻辑运算符&lt;/s
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习之变量得使用</title>
    <link href="http://yoursite.com/2019/03/18/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8F%98%E9%87%8F%E5%BE%97%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/03/18/shell脚本学习之变量得使用/</id>
    <published>2019-03-18T14:45:56.000Z</published>
    <updated>2019-03-27T16:08:29.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量得定义"><a href="#变量得定义" class="headerlink" title="变量得定义"></a>变量得定义</h2><p>格式：变量名称 = 变量值</p><pre><code>[root@jiangpeisi ~]# name=Andy[root@jiangpeisi ~]# echo $nameAndy</code></pre><p>1.变量名称不能以数字、特殊字符开头<br>2.=代表为变量赋值<br>3.变量的值可以是数字、字符串、文件的位置、命令、命令的结果</p><hr><h2 id="变量的分类"><a href="#变量的分类" class="headerlink" title="变量的分类"></a>变量的分类</h2><p><strong>自定义变量</strong></p><pre><code>Hostname=AndyIP=192.168.32.1echo $Hostname &quot;- $IP&quot;echo $Hostname &apos;- $IP&apos;[root@jiangpeisi ~]# sh d.sh Andy - 192.168.32.1Andy - $IP</code></pre><p>引号的区别：<br>    单引号与双引号的区别在于：单引号内若存在变量，存在的变量当做字符串不会被解析，原样输出；而双引号中若存在变量，该变量会被解析出其具体的值再加入到字符串中。<br>引号用法：<br>    1.不加引号可以直接定义内容包含数字、字符串、路径名等，适合定义数字<br>    2.单引号适合于纯定义字符串，<br>    3.而双引号适合于字符串的内容中包含有变量的内容的定义。</p><p><strong>环境变量</strong><br>使用env命令显示当前系统的环境变量</p><pre><code>[root@jiangpeisi ~]# envXDG_SESSION_ID=1189HOSTNAME=jiangpeisiTERM=xtermSHELL=/bin/bashHISTSIZE=1000SSH_CLIENT=49.70.204.253 2085 22SSH_TTY=/dev/pts/0USER=rootLS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=01;05;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=01;36:*.au=01;36:*.flac=01;36:*.mid=01;36:*.midi=01;36:*.mka=01;36:*.mp3=01;36:*.mpc=01;36:*.ogg=01;36:*.ra=01;36:*.wav=01;36:*.axa=01;36:*.oga=01;36:*.spx=01;36:*.xspf=01;36:MAIL=/var/spool/mail/rootPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/binPWD=/rootLANG=en_US.UTF-8HISTCONTROL=ignoredupsSHLVL=1HOME=/rootLOGNAME=rootSSH_CONNECTION=49.70.204.253 2085 172.16.30.80 22LESSOPEN=||/usr/bin/lesspipe.sh %sXDG_RUNTIME_DIR=/run/user/0_=/usr/bin/env</code></pre><p>定义全局变量</p><pre><code>export 变量名=变量值</code></pre><p>定义路径变量</p><pre><code>export PATH=$PATH:/root/bin    Export PATH=$PATH:格式不能错</code></pre><p>  单纯使用export命令设置全局变量仅临时有效，在机器重启后会失效，若想设置永久全局变量需要将环境变量的定义写在开机加载的配置文件中。例如：/etc/profile、/etc/profile.d、/etc/bashrc</p><p><strong>位置变量</strong><br>主要是向脚本中传递数据，变量名不能自定义，变量作用是固定的$n</p><pre><code>$0：代表命令本身，$1-9代表接受的第1-9个参数，10以上需要用{}括起来比如${10}代表接收的第10个参数$*：代表接收所有的参数，将所有参数看作一个整体$@：代表接收的所有参数，将每个参数区别对待$#：代表接收的参数个数dirname $0     获取目录名部分basename $0   获取文件名部分</code></pre><p>实例：</p><pre><code>echo &quot;path of script : $0&quot;echo &quot;name of script : $(basename $0)&quot;echo &quot;parameter 1 : $1&quot;echo &quot;parameter 2 : $2&quot;echo &quot;parameter 3 : $3&quot;echo &quot;parameter 4 : $4&quot;echo &quot;parameter 5 : $5&quot;echo &quot;The number of arguments passed : $#&quot;echo &quot;Show all arguments : $*&quot;echo &quot;Prncess TD : $$&quot;echo &quot;errors : $?&quot;[root@jiangpeisi ~]# sh /opt/e.sh a b c d e path of script : /opt/e.shname of script : e.shparameter 1 : aparameter 2 : bparameter 3 : cparameter 4 : dparameter 5 : eThe number of arguments passed : 5Show all arguments : a b c d ePrncess TD : 12807errors : 0</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;变量得定义&quot;&gt;&lt;a href=&quot;#变量得定义&quot; class=&quot;headerlink&quot; title=&quot;变量得定义&quot;&gt;&lt;/a&gt;变量得定义&lt;/h2&gt;&lt;p&gt;格式：变量名称 = 变量值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@jiangpeisi ~]# name=And
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/categories/linux/shell/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Docker镜像构建</title>
    <link href="http://yoursite.com/2019/03/15/Docker%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA/"/>
    <id>http://yoursite.com/2019/03/15/Docker镜像构建/</id>
    <published>2019-03-15T14:45:56.000Z</published>
    <updated>2019-03-15T15:36:18.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>Docker镜像的制作一共有两种方法，一种是手动构建，另一种是使用Dockerfile自动构建Docker镜像。本例使用两种方法，基于centos镜像重新构建两个nginx镜像。</p><hr><h2 id="手动构建Docker镜像"><a href="#手动构建Docker镜像" class="headerlink" title="手动构建Docker镜像"></a>手动构建Docker镜像</h2><p><strong>基于centos 创建容器</strong></p><pre><code>run -it --name yum_nginx centos </code></pre><p><strong>进入容器安装需要用到的软件包</strong></p><pre><code>yum install  openssl openssl-devel zlib zlib-devel gcc-c++ pcre pcre-devel wget -y</code></pre><p><strong>下载nginx源码</strong></p><pre><code>cd  /usr/local/src/ wget http://nginx.org/download/nginx-1.14.2.tar.gz   </code></pre><p><strong>解压源码</strong></p><pre><code>tar -xvf nginx-1.14.2.tar.gz</code></pre><p><strong>添加nginx用户</strong></p><pre><code>useradd -M nginx -s /sbin/nologin </code></pre><p><strong>编译源码</strong></p><pre><code>cd nginx-1.14.2./configure --prefix=/usr/local/nginx --user=nginx --group=nginx --with-pcremake &amp;&amp; make install</code></pre><p><strong>修改配置文件，让nginx在前台运行，放置容器主进程退出后，nginx也终止运行</strong></p><pre><code>echo &quot;daemon off;&quot; &gt;&gt;  /usr/local/nginx/conf/nginx.conf</code></pre><p><strong>退出容器，并让容器处于退出状态</strong><br><img src="http://static.zybuluo.com/jiangpeisi/wjfsy1e6st7hmvifj2ru1hr8/image_1d60ttqhs1mp31qgb5bhn7h8f21t.png" alt="image_1d60ttqhs1mp31qgb5bhn7h8f21t.png-16.5kB"><br><strong>构建镜像</strong></p><pre><code>docker commit -m &quot;my nginx&quot;  ac7b398c89a5  jiangpeisi/my-nginx:v1</code></pre><p><strong>查看构建的镜像</strong></p><pre><code>docker images</code></pre><p><img src="http://static.zybuluo.com/jiangpeisi/rqxhkol42uggjsyzwiq8yfoh/image_1d60u01la1qov1iasd541t2c1jp33n.png" alt="image_1d60u01la1qov1iasd541t2c1jp33n.png-12.7kB"><br><strong>使用新构建镜像创建容器</strong></p><pre><code>docker run -d -p 8080:80 jiangpeisi/my-nginx:v1 /usr/local/nginx/sbin/nginxlinks 47.107.103.142:8080</code></pre><p><img src="http://static.zybuluo.com/jiangpeisi/zcrz47yv76c7lgfplwx0i9x8/image_1d60u265915ev19t78rb1a0qo7a4u.png" alt="image_1d60u265915ev19t78rb1a0qo7a4u.png-17.1kB"></p><hr><h2 id="使用Dockerfile自动创建镜像"><a href="#使用Dockerfile自动创建镜像" class="headerlink" title="使用Dockerfile自动创建镜像"></a>使用Dockerfile自动创建镜像</h2><p><strong>创建Dockerfile目录</strong></p><pre><code>mkdir /opt/nginx/</code></pre><p><strong>下载需要用到的文件</strong></p><pre><code>wget http://nginx.org/download/nginx-1.14.2.tar.gz  #下载到Dockerfile目录下</code></pre><p><strong>创建Dockerfile</strong></p><pre><code>vim /opt/nginx/Dockerfile  #Dockerfile一定要写正确#This is my first Dockerfile#Version 1.0#Base images FROM centos#MAINTAINERMAINTAINER Jiang Pei Si#ADDADD nginx-1.14.2.tar.gz /usr/local/src#RUNRUN yum install  openssl openssl-devel zlib zlib-devel gcc-c++ pcre pcre-devel wget -yRUN useradd -M nginx -s /sbin/nologin#WORKDIRWORKDIR /usr/local/src/nginx-1.14.2RUN ./configure --prefix=/usr/local/nginx --user=nginx --group=nginx --with-pcreRUN make &amp;&amp; make installRUN echo &quot;daemon off;&quot; &gt;&gt; /usr/local/nginx/conf/nginx.confEXPOSE 80ENV PATH /usr/local/nginx/sbin:$PATHCMD [&quot;nginx&quot;]</code></pre><p><strong>构建镜像</strong></p><pre><code>docker build -t my-nginx:v1 /opt/nginx/ </code></pre><p><img src="http://static.zybuluo.com/jiangpeisi/eaqp4j0r9xnrgl3ieimtxqfy/image_1d60u8mfd9drpr3127bcravt477.png" alt="image_1d60u8mfd9drpr3127bcravt477.png-15.3kB"><br><strong>使用新构造的镜像创建容器</strong></p><pre><code>docker run -d -p 8088:80 my-nginx:v1 links 47.107.103.142：8088 </code></pre><p><img src="http://static.zybuluo.com/jiangpeisi/ompae3nlc8znrszripxmlvii/image_1d60urjrues3170a7opndck3m8e.png" alt="image_1d60urjrues3170a7opndck3m8e.png-16.9kB"></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>  docker 容器默认会把容器内部第一个进程，也就是pid=1的程序作为docker容器是否正在运行的依据，如果docker 容器pid挂了，那么docker容器便会直接退出。<br>  dockerrun的时候把command做为容器内部命令，如果你使用nginx，那么nginx程序将后台运行，这个时候nginx并不是pid为1的程序，而是执行的bash，这个bash执行了nginx指令后就挂了，所以容器也就退出了<br>  daemon off     nginx可以在没有主进程的情况下在前台运行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;&lt;p&gt;Docker镜像的制作一共有两种方法，一种是手动构建，另一种是使用Dockerfile自动构建Docker镜像。本例使用两种方法，基于cen
      
    
    </summary>
    
      <category term="虚拟化" scheme="http://yoursite.com/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="Docker" scheme="http://yoursite.com/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/Docker/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="虚拟化" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>DNS服务配置</title>
    <link href="http://yoursite.com/2019/03/13/DNS%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/03/13/DNS配置/</id>
    <published>2019-03-13T14:45:56.000Z</published>
    <updated>2019-03-14T06:11:49.644Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><strong>基本IP配置</strong><br>服务器：</p><p> BOOTPROTO=static<br> IPADDR=192.168.32.152<br> NETMASK=255.255.255.0<br> GATEWAY=192.168.32.2<br> ONBOOT=yes<br>客户端：</p><p> BOOTPROTO=static<br> ONBOOT=yes<br> IPADDR=192.168.32.151<br> NETMASK=255.255.255.0<br> GATEWAY=192.168.32.2</p></li><li><p><strong>安装bind</strong></p><p> yum install bind bind-devel bind-utils bind-libs bind-chroot -y</p></li><li><p><strong>修改主配置文件：/etc/named.conf</strong><br><img src="http://static.zybuluo.com/jiangpeisi/6y4auc81ay92fwny3fobq8fs/image_1d5qnrnal1sip1p47198s1m7712le4h.png" alt="image_1d5qnrnal1sip1p47198s1m7712le4h.png-128.6kB"><br> listen-on port 53 { any; };  //监听所有IP地址<br> listen-on-v6 port 53 { ::1; };  //可以注释掉<br> directory       “/var/named”;  //定义区域数据库文件位置<br> dump-file       “/var/named/data/cache_dump.db”;  //域名缓存数据库文件位置<br> statistics-file “/var/named/data/named_stats.txt”; //状态统计文件位置<br> memstatistics-file “/var/named/data/named_mem_stats.txt”;  //内存使用统计文件位置<br> allow-query     { any; };  //允许查询的客户端IP地址<br> recursion yes;  //是否企业轮询查询模式<br> dnssec-enable yes;  //是否启用DNSSEC支持<br> severity dynamic;  //定义日志输出的安全级别<br> include “/etc/named.rfc1912.zones”;  //包含辅助区域配置文件的所有配置</p></li><li><strong>修改服务区域文件：/etc/named.rfc1912.zones</strong><br>设置正向区域<br><img src="http://static.zybuluo.com/jiangpeisi/t4ufb51tooz40udtyppgem1k/image_1d5qnvdrp1lgs7jg1ro71ree2lk5b.png" alt="image_1d5qnvdrp1lgs7jg1ro71ree2lk5b.png-4.4kB"><br>设置逆向区域<br><img src="http://static.zybuluo.com/jiangpeisi/ozeiepuknyo7hfauan0zixqe/image_1d5qnvstf78b166r1nk499iap25o.png" alt="image_1d5qnvstf78b166r1nk499iap25o.png-5.7kB"></li><li><strong>设置正向解析区域数据配置文件：/var/named/mirror.com.zone</strong><br><img src="http://static.zybuluo.com/jiangpeisi/tnc15ph3708hdhdhsbjgzskl/image_1d5qo7b0s1obg1qv5vmo614miu9b.png" alt="image_1d5qo7b0s1obg1qv5vmo614miu9b.png-10.2kB"><br>@       IN      NS      <a href="http://www.mirror.com" target="_blank" rel="noopener">www.mirror.com</a>.  //指定DNS服务器域名，必须有一天A记录与之对应<br>www     IN      A       192.168.32.152  //www表示域的名称</li><li><p><strong>设置逆向解析区域配置文件：/var/named/192.168.32.arpa</strong><br><img src="http://static.zybuluo.com/jiangpeisi/xm1ohm3ajuiwiae761ksw7l7/image_1d5qoba55qdtag31v30ps49n9o.png" alt="image_1d5qoba55qdtag31v30ps49n9o.png-9kB"><br> 152     IN      PTR     <a href="http://www.mirror.com" target="_blank" rel="noopener">www.mirror.com</a>.  //152表示192.168.32.152</p></li><li><p><strong>防火墙放行服务</strong></p><p> firewall-cmd –add-service=dns </p></li><li><p><strong>重启named.service</strong></p><p> systemctl restart named.service</p></li><li><p><strong>修改dns配置文件：/etc/resolv.conf</strong></p><p> nameserver 192.168.32.152</p></li><li><p><strong>正向解析测试</strong></p><p> [root@jiangpeisi named]# nslookup <a href="http://www.mirror.com" target="_blank" rel="noopener">www.mirror.com</a><br> Server:        192.168.32.152<br> Address:    192.168.32.152#53</p><p> Name:    <a href="http://www.mirror.com" target="_blank" rel="noopener">www.mirror.com</a><br> Address: 192.168.32.152</p></li><li><p><strong>逆向解析测试</strong></p><p> [root@jiangpeisi named]# nslookup 192.168.32.152<br> Server:        192.168.32.152<br> Address:    192.168.32.152#53</p><p> 152.32.168.192.in-addr.arpa    name = <a href="http://www.mirror.com" target="_blank" rel="noopener">www.mirror.com</a>.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;基本IP配置&lt;/strong&gt;&lt;br&gt;服务器：&lt;/p&gt;
&lt;p&gt; BOOTPROTO=static&lt;br&gt; IPADDR=192.168.32.152&lt;br&gt; NETMASK=255.255.255.0&lt;br&gt; GATEWAY=192.168
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="DNS" scheme="http://yoursite.com/categories/linux/DNS/"/>
    
    
      <category term="DNS" scheme="http://yoursite.com/tags/DNS/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>自动部署博客</title>
    <link href="http://yoursite.com/2019/03/11/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2019/03/11/自动部署博客/</id>
    <published>2019-03-11T14:04:56.000Z</published>
    <updated>2019-03-10T16:58:54.531Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><strong>创建.bat文件</strong></p><p> @echo off<br> F:<br> cd F:\Myblog<br> hexo clean&amp;&amp;hexo g&amp;&amp;hexo d</p></li><li><p><strong>指令解释</strong><br>第一条指令@echo off，关闭回显。<br>第二叫指令F:，切换到博客站点目录所在的盘符，我这里是F盘，<br>第三条指令cd F:\Myblog，进入站点目录，我这里是cd F:\Myblog<br>第四条指令hexo clean&amp;&amp;hexo g&amp;&amp;hexo d，清楚本地缓存，重新在本地部署，在推送到GitHub上。</p></li><li><p><strong>运行</strong><br><img src="http://static.zybuluo.com/jiangpeisi/j8ot6tcf8hoof0njcrsdkqpw/image_1d5k75ao212b417581b3af55n2l9.png" alt="image_1d5k75ao212b417581b3af55n2l9.png-65.5kB"></p></li><li><p><strong>添加定时任务</strong><br>Win+R 输入 compmgmt.msc 打开计算机管理，添加计划任务<br><img src="http://static.zybuluo.com/jiangpeisi/cwatgva011d8kkyfh8wmwu11/image_1d5k7ni3vhidici170ilj7t9im.png" alt="image_1d5k7ni3vhidici170ilj7t9im.png-35.1kB"></p><p> 设置计划任务执行时间<br> <img src="http://static.zybuluo.com/jiangpeisi/hc4rw8qux0q4wqxgwyot9bv4/image_1d5k7oebm1tcq9rcj810s81us613.png" alt="image_1d5k7oebm1tcq9rcj810s81us613.png-39.6kB"></p><p> 设置计划任务执行程序<br> <img src="http://static.zybuluo.com/jiangpeisi/cor89r9jlgzq10c1yf890rt2/image_1d5k7r28bbak1il4fauih41h2p1g.png" alt="image_1d5k7r28bbak1il4fauih41h2p1g.png-18.9kB"></p><p> 添加完成<br> <img src="http://static.zybuluo.com/jiangpeisi/m13bs2pvltlgrhx578qnpbvz/image_1d5k7sspa1jog1nlo10jlicb1gc2d.png" alt="image_1d5k7sspa1jog1nlo10jlicb1gc2d.png-117kB"></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;创建.bat文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; @echo off&lt;br&gt; F:&lt;br&gt; cd F:\Myblog&lt;br&gt; hexo clean&amp;amp;&amp;amp;hexo g&amp;amp;&amp;amp;hexo d&lt;/p&gt;
&lt;/li&gt;
&lt;li
      
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>DNS解析过程及查询模式</title>
    <link href="http://yoursite.com/2019/03/09/DNS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B%E5%8F%8A%E6%9F%A5%E8%AF%A2%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/03/09/DNS解析过程及查询模式/</id>
    <published>2019-03-09T14:45:56.000Z</published>
    <updated>2019-03-13T05:35:49.345Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>DNS简介</strong><br> DNS（Domain Name Server）是一种主机域名和IP地址转换机制，使用一种分层的分布式数据库来处理Internet上成千上万个主机和IP地址的转换。基于C/S模式设计</li><li><strong>域名层次结构</strong><br><img src="http://static.zybuluo.com/jiangpeisi/yo9xyl3z4p3lt133f9btnyw3/image_1d5gj25qdr8k1jsc1mkn1dj8kq03n.png" alt="image_1d5gj25qdr8k1jsc1mkn1dj8kq03n.png-27.2kB"><br><img src="http://static.zybuluo.com/jiangpeisi/dy5ox1fmut0rykilknfx5isc/image_1d5giqc091h5di6rphm1gpuepg1g.png" alt="image_1d5giqc091h5di6rphm1gpuepg1g.png-89.4kB"></li><li><strong>DNS解析过程</strong><br><img src="http://static.zybuluo.com/jiangpeisi/7r01q8cf9wow42cuksr79cxv/image_1d5gis09d1b5s1seu1k781f57ed92t.png" alt="image_1d5gis09d1b5s1seu1k781f57ed92t.png-47.3kB"><br> 当我们去解析一个域名时，比如解析xxx.sh.com,会经过如下步骤:<br> 1.查看本机的缓存有无该域名记录，如果没有，查看本机的host文件有无该域名记录，如果没有，则发个请求到本地DNS服务器。<br> 2.本地DNS服务器收到请求后，查看是否有该域名的解析，如果有，返回解析记录给主机，如果没有，则请求根域名服务器.。<br> 3.根域名服务器收到请求后，返回该域名对应的顶级域名服务器,比如这次请求返回.com的服务器地址。<br> 4.本地域名服务器接到顶级域名服务器地址后，向该顶级域名服务器请求。<br> 5.顶级域名服务器返回该域名的二级域名务器地址，返回.sh.com对应的二级服务器地址。<br> 6.本地域名服务器获得该地址后，发请求到该域名的二级域名服务器。<br> 7.二级域名服务器解析xxx.sh.com，并将解析结果返回给本地域名服务器。<br> 8.本地域名服务器获取该解析后，返回给主机，解析完成。</li><li><strong>DNS解析模式</strong><br> 1.递归查询 ：当服务器收到DNS客户发来的请求，如果本地没有客户请求的数据就代替客户向其他DNS服务器请求，并将结果返回给客户，所以递归查询只会向客户返回查询结果或查询失败两种信息。<br> 2.迭代查询：当服务器收到DNS客户发来的请求，如果在服务器内没有查到客户需要的数据，会返回给客户另外一台DNS服务器的地址。客户就会向下一台DNS服务器进行查询，这样一直查询下去，一直查询到所需要的数据或没有DNS服务器可以查询为止。</li><li><strong>常用DNS服务器地址</strong><br>国内：114.114.114.114 备用：114.114.114.115<br>国外：8.8.8.8 备用：8.8.4.4</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;DNS简介&lt;/strong&gt;&lt;br&gt; DNS（Domain Name Server）是一种主机域名和IP地址转换机制，使用一种分层的分布式数据库来处理Internet上成千上万个主机和IP地址的转换。基于C/S模式设计&lt;/li&gt;
&lt;li&gt;&lt;str
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="DNS" scheme="http://yoursite.com/categories/linux/DNS/"/>
    
    
      <category term="DNS" scheme="http://yoursite.com/tags/DNS/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
</feed>
