<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我在看着你</title>
  
  <subtitle>by heart</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-03T08:32:22.038Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>镜子</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LNMP架构中Nginx如何与PHP进行交互</title>
    <link href="http://yoursite.com/2019/03/02/LNMP%E6%9E%B6%E6%9E%84%E4%B8%ADNginx%E5%A6%82%E4%BD%95%E4%B8%8EPHP%E4%BA%A4%E4%BA%92/"/>
    <id>http://yoursite.com/2019/03/02/LNMP架构中Nginx如何与PHP交互/</id>
    <published>2019-03-02T14:45:56.000Z</published>
    <updated>2019-03-03T08:32:22.038Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p><strong>简述</strong><br>因为nginx不支持对动态脚本文件的解析，所以如果客户端浏览器有对动态脚本文件的请求时，nginx就需要调用动态文本解析程序即php来处理请求。</p></li><li><p><strong>原理：</strong><br>1.nginx紧紧作为一个web服务器，接收和响应客户浏览器发送来的请求，其worker进程直接管理每一个请求。<br>2.php作为后端程序，处理客户端请求动态脚本文件，并将处理后的结果返回给web服务器，web服务器在将处理结果按一定的格式封装返回给浏览器。<br>3.对于nginx而言，php是与之同级别的一个外部程序，两者之间的交互需要通过CGI（通用网关接口），及nginx通过CGI对php进行调用来处理浏览器请求。<br>4.普通的CGI每接收到一次请求会重新解析配置文件php.ini，效率低，其衍生协议FastCGI解决了这个问题，服务端会通过php-fpm创建一个master进程，同时加载配置文件，然后在创建多个worker进程，处理客户端请求。当请求到来时master会将请求传递给worker进程处理，然后立即可以接收下一个请求，这样可以提高并发性。（真正解析动态文件的是php.cgi，php-fpm是管理php-cgi的软件）<br>5.FastCGI接口方式采用C/S架构，可以将HTTP服务器和脚本解析服务器分开，同时在脚本解析服务器上启动一个或多个脚本解析守护进程。当HTTP服务器每次遇到动态程序时，可以将其直接交付给脚本分析服务器执行，然后将得到的结构返回给浏览器。这种方式可以让HTTP服务器专一地处理静态请求或者将动态脚本服务器的结果返回给客户端，这在很大程度上提高了整个应用系统的性能。<br>6.FastCGI上游为nginx服务器，作为FastCGI的客户端，下游为外部程序，在LNMP架构中指的时PHP。<br>原理图：<br><img src="http://static.zybuluo.com/jiangpeisi/pnhxcqlstwg4ajivhfebzx1l/image_1d51agce9ssucna1v2qnoq118616.png" alt="image_1d51agce9ssucna1v2qnoq118616.png-75.9kB"></p></li><li><p><strong>过程分析</strong><br>1.用户发送http请求报文给nginx服务器<br>2.nginx会根据文件url和后缀来判断请求<br>3.如果请求的是静态内容,nginx会将结果直接返回给用户<br>4.如果请求的是动态内容,nginx会将请求交给fastcgi客户端,通过fastcgi_pass将这个请求发送给php-fpm<br>5.php-fpm会将请求交给wrapper（即master进程）<br>6.wrapper收到请求会生成新的线程（worker进程）调用php动态程序解析服务器<br>7.如果用户请求的是博文、或者内容、PHP会请求MySQL查询结果<br>8.如果用户请求的是图片、附件、PHP会请求nfs存储查询结果<br>9.php会将查询到的结果交给Nginx<br>10.nginx会生成一个响应报文返还给用户</p></li><li><p><strong>通信方式</strong><br>1.TCP方式<br>nginx配置文件：<br>fastcgi_pass 127.0.0.1:9000;<br>php-fpm配置文件：<br>listen = 127.0.0.1:9000<br>2.socket方式<br>nginx配置文件：<br>fastcgi_pass unix:/run/php/php7.0-fpm.sock;<br>php-fpm配置文件：<br>listen = /run/php/php7.0-fpm.sock</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;简述&lt;/strong&gt;&lt;br&gt;因为nginx不支持对动态脚本文件的解析，所以如果客户端浏览器有对动态脚本文件的请求时，nginx就需要调用动态文本解析程序即php来处理请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;原理：&lt;/st
      
    
    </summary>
    
      <category term="liux" scheme="http://yoursite.com/categories/liux/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>nginx之Location</title>
    <link href="http://yoursite.com/2019/03/02/Nginx%E4%B9%8BLocation/"/>
    <id>http://yoursite.com/2019/03/02/Nginx之Location/</id>
    <published>2019-03-02T14:45:56.000Z</published>
    <updated>2019-03-03T14:00:13.965Z</updated>
    
    <content type="html"><![CDATA[<ol><li><strong>什么是location，location都做些什么工作</strong><br>上文有提到，nginx内核完成的工作就是查找配置文件，将客户请求映射到一个location block，然后再执行location中的相应指令，所以说，location的作用就是用于匹配客户请求，并做出相应动作。<br>location如何匹配用户请求呢，先对URL进行剖析你就会知道，URL的格式由下列三部分组成：<br>第一部分是协议（或称为服务方式）；<br>第二部分是存有该资源的主机IP地址（有时也包括端口号）；<br>第三部分是主机资源的具体地址。，如目录和文件名等；<br>当一个请求到达服务器后，服务器接受到这个请求时，前两部分的匹配工作就已经完成，现在要做的就是在服务器上找到资源，location就是匹配的URL的第三部分内容。</li><li><strong>匹配模式</strong><br>location = /uri =开头表示精确匹配，只有完全匹配上才能生效。<br>location ^~ /uri ^~ 开头对URL路径进行前缀匹配，并且在正则之前。<br>location ~ pattern ~开头表示区分大小写的正则匹配。<br>location ~<em> pattern ~</em>开头表示不区分大小写的正则匹配。<br>location /uri 不带任何修饰符，也表示前缀匹配，但是在正则匹配之后。<br>location / 通用匹配，任何未匹配到其它location的请求都会匹配到，相当于switch中的default。</li><li><strong>匹配顺序</strong><br><img src="http://static.zybuluo.com/jiangpeisi/guoanpfc3d7zixyx7pynowiu/qqqq%20%282%29.png" alt="qqqq (2).png-42.5kB"><br>精确匹配&gt;正则匹配&gt;普通字符匹配  普通匹配看字符串长短，正则匹配看顺序</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;strong&gt;什么是location，location都做些什么工作&lt;/strong&gt;&lt;br&gt;上文有提到，nginx内核完成的工作就是查找配置文件，将客户请求映射到一个location block，然后再执行location中的相应指令，所以说，locatio
      
    
    </summary>
    
      <category term="liux" scheme="http://yoursite.com/categories/liux/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Memcached缓存服务器</title>
    <link href="http://yoursite.com/2019/03/02/Memcache/"/>
    <id>http://yoursite.com/2019/03/02/Memcache/</id>
    <published>2019-03-02T14:45:56.000Z</published>
    <updated>2019-03-03T13:58:44.863Z</updated>
    
    <content type="html"><![CDATA[<ol><li><strong>Memcache概述</strong><br>memcache:是高性能的分布式内存缓存服务器.通过缓存数据库的查询结果,减少数据库的访问次数,以提高web应用的速度,提高可扩展性.缓存方式是将缓存结果存储在内存中,通过内存来维护一个hash表.<br>Memcache是一个c/s软件,默认间通过端口为11211</li><li><strong>Memcache工作原理</strong><br>1.memcached是以守护程序方式运行于一个或多个服务器中，随时会接收客户端的连接和操作。<br>2.如何减轻数据库压力：当web访问数据库时，首先会先访问Memcache缓存服务器，查找是否有相应的数据，若没有则去访问数据库查询，返回结果给web应用并且再Memcache服务器留一份缓存，如果web访问Memcache服务器查询得到相应数据，就不会再去访问数据库，以此来减轻数据库的I/O。</li><li><strong>Memcache作为高速运行的分布式内存缓存服务器,具有以下几点</strong><br>1&gt; 本身是开源的,占用资源小,协议简单的软件,将数据库和web之间的数据缓存,减少数据库的检索次数,减少数据库的i/o<br>2&gt; 基于livevent的时间处理,因为libevent库将linux,bsd,solaris等这些操作系统上的kqueue等时间处理功能功能封装成统一接口,面对连接数增加,也能在linux,bsd,solaris等操作系统上发挥其高性能(i/o).<br>3&gt; 存储方式:内置于内存存储方式,存取的效率高,执行的速度快<br>4&gt; memcache不互相通信的分布式:同个客户端使得key有规律的封装,实现memcache实现分布式,采用多台cached服务器,增加缓存的横向延伸</li><li><strong>Memcache具体实现方式</strong><br>Memcached 的目前版本是通过C实现，采用了单进程，单线程，异步I/O，基于事件 (event_based) 的服务方式.使用 libevent 作为事件通知实现。多个 Server 可以协同工作，但这些 Server 之间是没有任何通讯联系的，每个 Server 只是对自己的数据进行管理。Client 端通过指定 Server 端的 ip 地址(通过域名应该也可以)。需要缓存的对象或数据是以 key-&gt;value 对的形式保存在Server端。key 的值通过 hash 进行转换，根据 hash 值把 value 传递到对应的具体的某个 Server 上。当需要获取对象数据时，也根据 key 进行。首先对 key 进行 hash，通过获得的值可以确定它被保存在了哪台 Server 上，然后再向该 Server 发出请求。Client 端只需要知道保存 hash(key) 的值在哪台服务器上就可以了。 memcache的工作就是在专门的机器的内存里维护一张巨大的hash表，来存储经常请求的数据。</li><li><strong>安装Memcache</strong><br>1 安装libevent时<br>./configure –prefix=/usr/local/libevent<br>Make &amp;&amp; make install<br>2 安装memcached<br>./configure –prefix=/usr/local/memcached –with-libevent=/usr/local/libevent<br>Make &amp;&amp; make install</li><li><strong>管理Memcache</strong><br>启动Memcache：<br>/usr/local/bin/memcached -d -m 2048 -u root -l 192.168.1.20 -p 12111 -c 1024 -P /tmp/memcached.pid<br>停止Memcache:<br>kill ‘cat /tmp/memcached.pid’;<br>Kill all memcached<br>参数说明：<br>-d 启动为守护进程<br>-m <num> 分配给Memcached使用的内存数量，单位是MB，默认为64MB<br>-u <username> 运行Memcached的用户，仅当作为root运行时<br>-l &lt;ip_addr&gt; 监听的服务器IP地址，默认为环境变量INDRR_ANY的值<br>-p <num> 设置Memcached监听的端口，最好是1024以上的端口<br>-c <num> 设置最大并发连接数，默认为1024<br>-P <file> 设置保存Memcached的pid文件，与-d选择同时使用 </file></num></num></username></num></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Memcache概述&lt;/strong&gt;&lt;br&gt;memcache:是高性能的分布式内存缓存服务器.通过缓存数据库的查询结果,减少数据库的访问次数,以提高web应用的速度,提高可扩展性.缓存方式是将缓存结果存储在内存中,通过内存来维护一个hash表.
      
    
    </summary>
    
      <category term="liux" scheme="http://yoursite.com/categories/liux/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Rewrite重写URL</title>
    <link href="http://yoursite.com/2019/03/02/Rewrite%E9%87%8D%E5%86%99URL/"/>
    <id>http://yoursite.com/2019/03/02/Rewrite重写URL/</id>
    <published>2019-03-02T14:45:56.000Z</published>
    <updated>2019-03-03T14:01:27.899Z</updated>
    
    <content type="html"><![CDATA[<ol><li><strong>Rewrite重写用来做些什么</strong><br>URL重写就是首先获得一个进入的URL请求，然后使用nginx提供的全局变量或自己设置的变量，结合正则表达式和标志位把它重新写成网站可以处理的另一个URL的过程。rewrite只能放在配置文件的server{},location{},if{}中，并且只能对域名后边的除去传递的参数外的字符串起作用。</li><li><strong>Rewrite执行顺序</strong><br>1.执行server块的rewrite指令<br>2.执行location匹配<br>3.执行选定的location中的rewrite指令<br>4.执行if条件匹配<br>5.执行if块中的rewrite指令</li><li><strong>rewrite语法</strong><br><img src="http://static.zybuluo.com/jiangpeisi/mi0e0s061is56an6tkuxmmud/image_1d5142otn17uq1lmmhis17l21jr52a.png" alt="image_1d5142otn17uq1lmmhis17l21jr52a.png-4kB"><br>关键字：其中关键字error_log不能改变<br>正则： perl兼容正则表达式语句进行规则匹配<br>替代内容：将正则匹配的内容替换成repl acement<br>filag标记： rewrite支持的fl ag标记<br>flag标记说明：<br>Last #本条规则匹配完成后，继续向下匹配新的location URI规则<br>break #本条规则匹配完成即终止，不再匹配后面的任何规则<br>redirect #返回302临时重定向，浏览器地址会显示跳转后的URL.地址<br>permanent #返回301永久重定向，浏览器地址栏会显示跳转后的URL她址</li><li><strong>指令详解</strong><br>1.if指令<br>语法为if(condition){…}<br>condition常用判断条件：<br>-f和!-f用来判断请求文件是否存在<br>-d和!-d用来判断请求目录是否存在<br>-e和!-e用来判断是请求的文件或者目录否存在<br>-x和!-x用来判断请求的文件是否可执行<br>condition可用的nginx变量：<br><img src="http://static.zybuluo.com/jiangpeisi/vbwm6czsg5ns6990jucbve0t/image_1d518ruaobbb1vcict8pvjal03h.png" alt="image_1d518ruaobbb1vcict8pvjal03h.png-810.5kB"><br>2.break指令<br>用于中断当前相同作用域中的Nginx配置，和Java中的break语法类似，可以在server块和location以及if块中使用。<br>3.return指令<br>该指令用于完成对请求的处理，直接向客户端响应状态的代码。和Java中的return语法类似。可以再server块和location以及if块中使用。<br>4.set指令<br>用来设置新的变量<br>  语法: set variable value</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Rewrite重写用来做些什么&lt;/strong&gt;&lt;br&gt;URL重写就是首先获得一个进入的URL请求，然后使用nginx提供的全局变量或自己设置的变量，结合正则表达式和标志位把它重新写成网站可以处理的另一个URL的过程。rewrite只能放在配置文
      
    
    </summary>
    
      <category term="liux" scheme="http://yoursite.com/categories/liux/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>日志切割</title>
    <link href="http://yoursite.com/2019/03/02/%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2/"/>
    <id>http://yoursite.com/2019/03/02/日志切割/</id>
    <published>2019-03-02T14:45:56.000Z</published>
    <updated>2019-03-03T14:02:34.254Z</updated>
    
    <content type="html"><![CDATA[<ol><li><strong>日志分类</strong><br>access.log 记录哪些用户,哪些页面以及用户浏览器,IP等访问信息；<br>error.log 记录服务器错误的日志</li><li><strong>日志配置</strong><br>配置日志的存储路径：<br>location / {<pre><code>access_log          /usr/local/nginx/logs/access.log;error_log           /usr/local/nginx/logs/error.log;</code></pre>}<br>配置日志格式：<br><img src="http://static.zybuluo.com/jiangpeisi/n4fibrzee1r5ku7hb41mmrux/image_1d4vf79fh5k2m2j1si8ada19dj4r.png" alt="image_1d4vf79fh5k2m2j1si8ada19dj4r.png-20.5kB"></li><li><strong>日志切割脚本</strong><br><img src="http://static.zybuluo.com/jiangpeisi/18tztm3bn4ygddpy3bjhle69/image_1d4veqc8v177mam71tlgseh160p2n.png" alt="image_1d4veqc8v177mam71tlgseh160p2n.png-31.2kB"></li><li><strong>创建定时任务每日零点切割日志</strong><br>crontab –e<br>59 23 <em> </em> * bash /usr/local/nginx/shell/cut_ngnix_log.sh</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;strong&gt;日志分类&lt;/strong&gt;&lt;br&gt;access.log 记录哪些用户,哪些页面以及用户浏览器,IP等访问信息；&lt;br&gt;error.log 记录服务器错误的日志&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;日志配置&lt;/strong&gt;&lt;br&gt;配置日志的存储路径
      
    
    </summary>
    
      <category term="liux" scheme="http://yoursite.com/categories/liux/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Nginx模块与工作原理</title>
    <link href="http://yoursite.com/2019/02/28/Nginx%E6%A8%A1%E5%9D%97%E5%88%86%E7%B1%BB%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/28/Nginx模块分类与工作原理/</id>
    <published>2019-02-28T01:40:56.000Z</published>
    <updated>2019-03-03T13:56:33.146Z</updated>
    
    <content type="html"><![CDATA[<p>nginx主要是由内核和模块组成的。</p><ol><li><strong>内核</strong><br>内核的设计非常简洁，完成的工作主要是查找配置文件找到访问的URL所匹配的location block，并实现location中的相应指令。而location中的每个指令会调用不同的模块去完成相应的工作<br><img src="http://static.zybuluo.com/jiangpeisi/01ebv3v6btag0lzdyl0h1rf4/qqqq.png" alt="qqqq.png-278.1kB"></li><li><strong>模块</strong><br>从结构上分：<br>核心模块：HTTP模块、event模块和mail模块等<br>基础模块：HTTP access 模块HTTP FastCGI模块、HTTP proxy 模块和HTTP rewrite模块等<br>第三方模块：HTTP upstream request hash模块、notice 模块 和HTTP access key模块、limit_req模块等<br>从功能上分：<br>handers（处理器模块）：用于处理请求，并进行输出内容和修改headers信息等操作，一般只能有一个<br>filters（过滤模块）：主要对其他模块处理后的数据进行修改，最后交给nginx返回给浏览器<br>proxies（代理模块）：主要与后端的一些服务进行交互，例如FastCGI等，实现服务代理及负载均衡</li><li><strong>nginx高并发</strong><br>nginx高并发是因为采用了epoll模块，异步非阻塞。与Apache相比，Apache采用的时select模块，select模块在选择句柄的时候是遍历所有句柄，选择其中有事件通知的句柄去响应。而epoll模块是不需要遍历句柄链表，一但有句柄有事件通知立马就可以做出响应，所以效率更高一些。</li><li><strong>master进程</strong><br>nginx在服务端默认监听80端口，服务一旦启动服务器就会创建一个master进程，同时由mater进程可以生成多个worker进程对请求做出响应。<br><img src="http://static.zybuluo.com/jiangpeisi/l9m2d3wifpmyykcg3nepjnmk/z.png" alt="z.png-326.6kB"><br>服务器启动后创建master进程，并在master进程内创建一个监听80端口的socket，master进程会fork多个woker进程，每个worker进程一旦获得连接处理，会把listend变的仅可读，这样可以保证每个worker进程只对一个连接进行处理，当一个worker进程在accept一个连接后就会读取请求、解析请求、处理请求、产生数据，并将产生的数据返回给客户端，并断开连接。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;nginx主要是由内核和模块组成的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;内核&lt;/strong&gt;&lt;br&gt;内核的设计非常简洁，完成的工作主要是查找配置文件找到访问的URL所匹配的location block，并实现location中的相应指令。而location中的每个
      
    
    </summary>
    
      <category term="liux" scheme="http://yoursite.com/categories/liux/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Nginx安装</title>
    <link href="http://yoursite.com/2019/02/28/Nginx%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2019/02/28/Nginx安装/</id>
    <published>2019-02-27T16:24:56.000Z</published>
    <updated>2019-02-27T16:31:25.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Nginx是一个轻量型web服务器，也可以用来做负载均衡及反向代理。</p><hr><h2 id="安装环境准备"><a href="#安装环境准备" class="headerlink" title="安装环境准备"></a>安装环境准备</h2><p>nginx是C语言开发，建议在linux上运行，本次使用Centos7.3作为安装环境。</p><ol><li><p>gcc<br>nginx是用c语言编写，如果使用源码安装，需要先对源码进行编译，gcc作为linux上的c编译器来完成这个工作，所以事先要安装好gcc</p><p>yum install gcc-c++ -y</p></li><li><p>pcre<br>PCRE(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。</p><p>yum install pcre pcre-devel -y</p></li><li><p>zlib<br>zlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。</p><p>yum install zlib zlib-devel -y</p></li><li><p>openssl<br>OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。</p><p>yum install openssl openssl-devel -y</p></li></ol><hr><h2 id="下载编译安装nginx"><a href="#下载编译安装nginx" class="headerlink" title="下载编译安装nginx"></a>下载编译安装nginx</h2><ol><li><p>下载nginx源码</p><p>cd /usr/local/src<br>wget <a href="http://nginx.org/download/nginx-1.14.2.tar.gz" target="_blank" rel="noopener">http://nginx.org/download/nginx-1.14.2.tar.gz</a></p></li><li><p>解压源码</p><p>tar -xvf nginx-1.14.2.tar.gz </p></li><li><p>编译安装</p><p>cd nginx-1.14.2<br>./configure –prefix=/usr/local/nginx<br>make &amp;&amp; make install</p></li><li><p>启动服务</p><p>cd /usr/local/nginx/<br>./sbin/nginx </p></li></ol><p>若出现如下情况：<br><img src="http://static.zybuluo.com/jiangpeisi/ualmx38mtswvj4wv2oejoafk/aaa.png" alt="aaa.png-9.4kB"><br>说明80端口已经被其他进程占用，需要把占用端口的进程先杀掉在重新启动服务。有两种解决办法：</p><pre><code>1.使用netstat命令查看占用端口的进程![q.png-9.2kB][2]kill -9 [进程号]  杀死占用80端口的进程即可2.修改nginx配置文件中监听的端口号server {        listen       80;  #修改为8080        server_name  localhost;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location / {            root   html;            index  index.html index.htm;        }浏览器访问时使用   IP：8080  访问即可</code></pre><p> 5.安装成功</p><p><img src="http://static.zybuluo.com/jiangpeisi/blkn5f588xbdg772ct0pa0tn/ads.png" alt="ads.png-8.5kB"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Nginx是一个轻量型web服务器，也可以用来做负载均衡及反向代理。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;安装环境准备&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="liux" scheme="http://yoursite.com/categories/liux/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo+GitHub搭建个人博客</title>
    <link href="http://yoursite.com/2019/02/27/hexo+GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2019/02/27/hexo+GitHub搭建个人博客/</id>
    <published>2019-02-27T14:04:56.000Z</published>
    <updated>2019-02-27T14:10:52.012Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo-GitHub搭建个人博客"><a href="#hexo-GitHub搭建个人博客" class="headerlink" title="hexo+GitHub搭建个人博客"></a>hexo+GitHub搭建个人博客</h2><h1 id="一、基本环境"><a href="#一、基本环境" class="headerlink" title="一、基本环境"></a>一、基本环境</h1><ol><li>注册GitHub账户<br><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">GitHub注册教程</a></li><li>安装Node.js<br><a href="https://jingyan.baidu.com/article/48b37f8dd141b41a646488bc.html" target="_blank" rel="noopener">Node.js安装教程</a></li><li>安装git并且配置好git的基本环境<br><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">官网</a>下载自己电脑对应的版本直接安装即可</li></ol><hr><h1 id="二、本地部署Hexo"><a href="#二、本地部署Hexo" class="headerlink" title="二、本地部署Hexo"></a>二、本地部署Hexo</h1><ol><li>首先在合适的地方创建一个本地文件夹，用于部署hexo。</li><li>打开上面安装Git Bash,进入刚刚创建的本地目录<br><img src="http://static.zybuluo.com/jiangpeisi/3nl5jgu8pxbp4ahm8w3foq37/image_1d4n4ll4i17ms1hhu1565hsu8mi11.png" alt="image_1d4n4ll4i17ms1hhu1565hsu8mi11.png-4.7kB"></li><li>安装hexo</li></ol><blockquote><p>npm install hexo-cli -g</p><p>hexo -v 检查版本</p></blockquote><ol start="4"><li>初始化文件夹</li></ol><blockquote><p>hexo init</p></blockquote><ol start="5"><li>安装所需组件</li></ol><blockquote><p>npm install</p></blockquote><ol start="6"><li>在本地生成静态文件</li></ol><blockquote><p>hexo generate</p></blockquote><ol start="7"><li>启动本地服务</li></ol><blockquote><p>hexo server</p></blockquote><p>  此时我们就可以通过浏览器访问本地部署的博客了，浏览器输入localhost：4000 查看刚刚部署的博客框架了，若是界面一直加载不出，可能是因为4000端口被其他端口占用了，此时需要用ctrl+c停止服务，重新用hexo -s -p 5000  指定使用5000端口，然后在访问localhost：5000即可。</p><ol start="8"><li>完成结果<br><img src="http://static.zybuluo.com/jiangpeisi/6iv0zcf9ity2eywtme9q4az3/N_HY4B2PTW%7D2O4FX4G@2BX5.png" alt="N_HY4B2PTW}2O4FX4G@2BX5.png-80.3kB"></li></ol><hr><h1 id="三、GitHub托管"><a href="#三、GitHub托管" class="headerlink" title="三、GitHub托管"></a>三、GitHub托管</h1><ol><li>更改Git的name和email</li></ol><blockquote><p>git config –list</p></blockquote><p> 查看当前name和email是否与注册GitHub时的相同若不相同 </p><blockquote><p>git config –global user.name “你的GitHub用户名”</p><p>git config –global user.email “你的GitHub邮箱”</p></blockquote><ol start="2"><li>创建SSH Key</li></ol><blockquote><p>ssh-keygen -t rsa -C “你的邮箱”</p></blockquote><p>一路回车，然后进入.ssh目录可以看到以下文件<br><img src="http://static.zybuluo.com/jiangpeisi/jxjji70g1rxltwkgg3bf5aan/sdas.png" alt="sdas.png-7.9kB"><br>id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p><ol start="3"><li>在GitHub上添加SSH Key<br>1.登陆GitHub，打开“settings”，“SSH and GPG Keys”页面<br>2.填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容<br>3.点“Add Key”，你就应该看到已经添加的Key<br>4.输入ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了<br><img src="http://static.zybuluo.com/jiangpeisi/6zekv8cd5t02kiiyrajbz8le/adasd.png" alt="adasd.png-5kB"></li><li>关联hexo与GitHub<br>在创建博客的根目录下找到_config.yml，这个文件是站点配置文件，关于站点的基本配置都在此文件中。</li></ol><blockquote><p>deploy:<br>    type: git<br>    repo: <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:Jiangpeisi/Jiangpeisi.github.io.git<br>    branch: master</p></blockquote><p>repo后面跟你自己注册的GitHub仓库地址</p><ol start="5"><li>安装拓展模块</li></ol><blockquote><p>npm install hexo-deployer-git –save</p></blockquote><ol start="6"><li>将本地部署推送到GitHub上</li></ol><blockquote><p>hexo g</p><p>hexo d</p></blockquote><ol start="7"><li>访问</li></ol><blockquote><p>http://用户名.github.io 将看到自己的博客</p></blockquote><hr><h1 id="四、设置主题"><a href="#四、设置主题" class="headerlink" title="四、设置主题"></a>四、设置主题</h1><p>在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。</p><ol><li>安装next<br>在站点目录下执行以下代码：</li></ol><blockquote><p>git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> themes/next</p></blockquote><ol start="2"><li>使用主题<br>当克隆/下载完成后，打开站点配置文件，找到 theme 字段，并将其值更改为 next。</li><li>验证主题</li></ol><blockquote><p>hexo clean 清楚之前的缓存</p><p>hexo g 本地部署</p><p>hexo s   浏览器访问localhost：4000</p><p>hexo d   浏览器访问看到笑过后推送到GitHub进行托管即可</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;hexo-GitHub搭建个人博客&quot;&gt;&lt;a href=&quot;#hexo-GitHub搭建个人博客&quot; class=&quot;headerlink&quot; title=&quot;hexo+GitHub搭建个人博客&quot;&gt;&lt;/a&gt;hexo+GitHub搭建个人博客&lt;/h2&gt;&lt;h1 id=&quot;一、基本环
      
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
